// Copyright (c) 2025, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/// @assertion A primary constructor declaration consists of a
/// `<primaryConstructor>` in the declaration header plus optionally a member
/// declaration in the body that starts with a
/// `<primaryConstructorBodySignature>`.
///
/// @description Check that primary constructors invocation and declaration
/// can be debugged.
/// @author sgrekhov22@gmail.com

// SharedOptions=--enable-experiment=primary-constructors

import 'dart:developer';
import 'package:vm_service/vm_service.dart';

import '../../../../pkg/vm_service/test/common/service_test_common.dart';
import '../../../../pkg/vm_service/test/common/test_helper.dart';
import '../Utils/expect.dart';

const String shortFile = 'primary_constructors_t01.dart';

// AUTOGENERATED START
//
// Update these constants by running:
//
// dart pkg/vm_service/test/update_line_numbers.dart tests/co19/src/VM/primary_constructors_t01.dart
//
const LINE_A = 40;
const LINE_B = 45;
const LINE_C = 50;
const LINE_D = 51;
// AUTOGENERATED END

class C1(var int v1, final int v2); // LINE_A

class C2(int v1, int v2) {
  int v1;
  final int v2;
  this: v1 = v1, v2 = v2;   // LINE_B
}

void testeeMain() {
  debugger();
  var c1 = C1(1, 2);  // LINE_C
  var c2 = C2(5, 6);  // LINE_D
}

List<String> stops = [];

const List<String> expected = [
  '$shortFile:$LINE_C:10', // on '='
  '$shortFile:$LINE_C:12', // on 'C1'
  '$shortFile:$LINE_A:32', // on 'v2'
  '$shortFile:$LINE_A:35', // on ';'
  '$shortFile:$LINE_D:10', // on '='
  '$shortFile:$LINE_D:12', // on 'C2'
  '$shortFile:$LINE_B:18', // on 'v2'
  '$shortFile:$LINE_B:25', // on ';'
];

final tests = <IsolateTest>[
  hasStoppedAtBreakpoint,

  // Test interaction of expression evaluation with invocation of primary constructors
  (VmService service, IsolateRef isolateRef) async {
    final isolateId = isolateRef.id!;

    InstanceRef response =
        await service.evaluateInFrame(isolateId, 0, 'C1(1, 2).v1')
            as InstanceRef;
    Expect.equals('1', response.valueAsString);

    response =
        await service.evaluateInFrame(isolateId, 0, 'C2(3, 4).v1')
            as InstanceRef;
    Expect.equals('3', response.valueAsString);
  },

  // Test interaction of breakpoints with primary constructors.
  (VmService service, IsolateRef isolateRef) async {
    final isolateId = isolateRef.id!;
    final isolate = await service.getIsolate(isolateId);
    final lib =
        (await service.getObject(isolateId, isolate.rootLib!.id!)) as Library;
    final scriptId = lib.scripts!.first.id!;

    var breakpoint = await service.addBreakpoint(isolateId, scriptId, LINE_C);
    var (_, (line, column)) = await breakpoint.getLocation(service, isolateRef);
    Expect.isTrue(breakpoint.enabled);
    Expect.equals(LINE_C, line);
    Expect.equals(10, column); // on '='

    breakpoint = await service.addBreakpoint(isolateId, scriptId, LINE_D);
    (_, (line, column)) = await breakpoint.getLocation(service, isolateRef);
    Expect.isTrue(breakpoint.enabled);
    Expect.equals(LINE_D, line);
    Expect.equals(10, column); // on '='
    await service.removeBreakpoint(isolateId, breakpoint.id!);
  },

  // Test interaction of single-stepping with primary constructors.
  runStepIntoThroughProgramRecordingStops(stops),
  checkRecordedStops(stops, expected),
];

void main([args = const <String>[]]) => runIsolateTests(
  args,
  tests,
  'primary_constructors_t01.dart',
  pauseOnExit: true,
  testeeConcurrent: testeeMain,
);
