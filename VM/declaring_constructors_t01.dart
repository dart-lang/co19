// Copyright (c) 2025, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/// @assertion A declaring constructor declaration is a declaration that
/// contains a `<declaringConstructorSignature>` with a
/// `<declaringParameterList>`, or a declaration that contains a
/// `<declaringConstantConstructorSignature>`, or it is a
/// `<primaryConstructorNoConst>` in the header of a class, enum, or extension
/// type declaration, together with a declaration in the body that contains a
/// `<declaringConstructorSignature>`.
///
/// @description Check that declaring constructors invocation and declaration
/// can be debugged.
/// @author sgrekhov22@gmail.com

// SharedOptions=--enable-experiment=declaring-constructors

import 'dart:developer';
import 'package:vm_service/vm_service.dart';

import '../../../../pkg/vm_service/test/common/service_test_common.dart';
import '../../../../pkg/vm_service/test/common/test_helper.dart';
import '../Utils/expect.dart';

const String shortFile = 'declaring_constructors_t01.dart';

// AUTOGENERATED START
//
// Update these constants by running:
//
// dart pkg/vm_service/test/update_line_numbers.dart tests/co19/src/VM/declaring_constructors_t01.dart
//
const LINE_A = 44;
const LINE_B = 47;
const LINE_C = 53;
const LINE_D = 59;
const LINE_E = 64;
const LINE_F = 65;
const LINE_G = 66;
const LINE_H = 67;
// AUTOGENERATED END

class C1(var int v1, final int v2); // LINE_A

class C2 {
  this(var int v1, final int v2); // LINE_B
}

class C3(int v1, int v2) {
  int v1;
  final int v2;
  this: v1 = v1, v2 = v2;   // LINE_C
}

class C4 {
  int v1;
  final int v2;
  this(int v1, int v2) : v1 = v1, v2 = v2; // LINE_D
}

void testeeMain() {
  debugger();
  var c1 = C1(1, 2);  // LINE_E
  var c2 = C2(3, 4);  // LINE_F
  var c3 = C3(5, 6);  // LINE_G
  var c4 = C4(7, 8);  // LINE_H
}

List<String> stops = [];

const List<String> expected = [
  '$shortFile:$LINE_E:10', // on '='
  '$shortFile:$LINE_E:12', // on 'C1'
  '$shortFile:$LINE_A:32', // on 'v2'
  '$shortFile:$LINE_A:35', // on ';'
  '$shortFile:$LINE_F:10', // on '='
  '$shortFile:$LINE_F:12', // on 'C2'
  '$shortFile:$LINE_B:30', // on 'v2'
  '$shortFile:$LINE_B:33', // on ';'
  '$shortFile:$LINE_G:10', // on '='
  '$shortFile:$LINE_G:12', // on 'C3'
  '$shortFile:$LINE_C:18', // on 'v2'
  '$shortFile:$LINE_C:25', // on ';'
  '$shortFile:$LINE_H:10', // on '='
  '$shortFile:$LINE_H:12', // on 'C4'
  '$shortFile:$LINE_D:35', // on 'v2'
  '$shortFile:$LINE_D:42', // on ';'
];

final tests = <IsolateTest>[
  hasStoppedAtBreakpoint,

  // Test interaction of expression evaluation with declaring constructors invocation
  (VmService service, IsolateRef isolateRef) async {
    final isolateId = isolateRef.id!;

    InstanceRef response =
        await service.evaluateInFrame(isolateId, 0, 'C1(1, 2).v1')
            as InstanceRef;
    Expect.equals('1', response.valueAsString);

    response =
        await service.evaluateInFrame(isolateId, 0, 'C2(3, 4).v2')
            as InstanceRef;
    Expect.equals('4', response.valueAsString);

    response =
        await service.evaluateInFrame(isolateId, 0, 'C3(5, 6).v1')
            as InstanceRef;
    Expect.equals('5', response.valueAsString);

    response =
        await service.evaluateInFrame(isolateId, 0, 'C4(7, 8).v2')
            as InstanceRef;
    Expect.equals('8', response.valueAsString);
  },

  // Test interaction of breakpoints with declaring constructors.
  (VmService service, IsolateRef isolateRef) async {
    final isolateId = isolateRef.id!;
    final isolate = await service.getIsolate(isolateId);
    final lib =
        (await service.getObject(isolateId, isolate.rootLib!.id!)) as Library;
    final scriptId = lib.scripts!.first.id!;

    var breakpoint = await service.addBreakpoint(isolateId, scriptId, LINE_E);
    var (_, (line, column)) = await breakpoint.getLocation(service, isolateRef);
    Expect.isTrue(breakpoint.enabled);
    Expect.equals(LINE_E, line);
    Expect.equals(10, column); // on '='

    breakpoint = await service.addBreakpoint(isolateId, scriptId, LINE_F);
    var (_, (line, column)) = await breakpoint.getLocation(service, isolateRef);
    Expect.isTrue(breakpoint.enabled);
    Expect.equals(LINE_F, line);
    Expect.equals(10, column); // on '='
    await service.removeBreakpoint(isolateId, breakpoint.id!);

    breakpoint = await service.addBreakpoint(isolateId, scriptId, LINE_G);
    var (_, (line, column)) = await breakpoint.getLocation(service, isolateRef);
    Expect.isTrue(breakpoint.enabled);
    Expect.equals(LINE_G, line);
    Expect.equals(10, column); // on '='
    await service.removeBreakpoint(isolateId, breakpoint.id!);

    breakpoint = await service.addBreakpoint(isolateId, scriptId, LINE_H);
    var (_, (line, column)) = await breakpoint.getLocation(service, isolateRef);
    Expect.isTrue(breakpoint.enabled);
    Expect.equals(LINE_H, line);
    Expect.equals(10, column); // on '='
    await service.removeBreakpoint(isolateId, breakpoint.id!);
  },

  // Test interaction of single-stepping with declaring constructors.
  runStepIntoThroughProgramRecordingStops(stops),
  checkRecordedStops(stops, expected),
];

void main([args = const <String>[]]) => runIsolateTests(
  args,
  tests,
  'declaring_constructors_t01.dart',
  pauseOnExit: true,
  testeeConcurrent: testeeMain,
);
