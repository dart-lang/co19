// Copyright (c) 2025, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/// @assertion A declaring constructor declaration is a declaration that
/// contains a `<declaringConstructorSignature>` with a
/// `<declaringParameterList>`, or a declaration that contains a
/// `<declaringConstantConstructorSignature>`, or it is a
/// `<primaryConstructorNoConst>` in the header of a class, enum, or extension
/// type declaration, together with a declaration in the body that contains a
/// `<declaringConstructorSignature>`.
///
/// @description Check that members initialized in primary initializer scope can
/// be debugged.
/// @author sgrekhov22@gmail.com

// SharedOptions=--enable-experiment=declaring-constructors

import 'dart:developer';
import 'package:vm_service/vm_service.dart';

import '../../../../pkg/vm_service/test/common/service_test_common.dart';
import '../../../../pkg/vm_service/test/common/test_helper.dart';
import '../Utils/expect.dart';

const String shortFile = 'declaring_constructors_t02.dart';

// AUTOGENERATED START
//
// Update these constants by running:
//
// dart pkg/vm_service/test/update_line_numbers.dart tests/co19/src/VM/declaring_constructors_t02.dart
//
const LINE_A = 45;
const LINE_B = 46;
const LINE_C = 47;
const LINE_D = 48;
const LINE_E = 50;
const LINE_F = 51;
const LINE_G = 57;
const LINE_H = 58;
const LINE_I = 59;
// AUTOGENERATED END

class C(var String x) {                               // LINE_A
  String Function() captureAtDeclaration = () => x;   // LINE_B
  String Function() captureInInitializer;             // LINE_C
  String Function()? captureInBody;                   // LINE_D

  this : captureInInitializer = (() => x) {           // LINE_E
    captureInBody = () => x;                          // LINE_F
  }
}

void testeeMain() {
  debugger();
  var c = C("test");        // LINE_G
  c.captureInInitializer(); // LINE_H
  c.captureAtDeclaration(); // LINE_I
}

List<String> stops = [];

const List<String> expected = [
  '$shortFile:$LINE_G:9',   // on '='
  '$shortFile:$LINE_G:11',  // on 'C'
  '$shortFile:$LINE_A:20',  // on 'x'
  '$shortFile:$LINE_F:5',   // on 'captureInBody'
  '$shortFile:$LINE_H:5',   // on 'captureInInitializer'
  '$shortFile:$LINE_H:25',  // on '()'
  '$shortFile:$LINE_E:34',  // on '() =>'
  '$shortFile:$LINE_E:40',  // on 'x'
  '$shortFile:$LINE_I:5',   // on 'captureAtDeclaration'
  '$shortFile:$LINE_I:25',  // on '()'
  '$shortFile:$LINE_B:44',  // on '() =>'
  '$shortFile:$LINE_B:50',  // on 'x'
];

final tests = <IsolateTest>[

  // Test interaction of breakpoints with declaring constructors.
  (VmService service, IsolateRef isolateRef) async {
    final isolateId = isolateRef.id!;
    final isolate = await service.getIsolate(isolateId);
    final lib =
        (await service.getObject(isolateId, isolate.rootLib!.id!)) as Library;
    final scriptId = lib.scripts!.first.id!;

    var breakpoint = await service.addBreakpoint(isolateId, scriptId, LINE_G);
    var (_, (line, column)) = await breakpoint.getLocation(service, isolateRef);
  },

  // Test interaction of single-stepping with declaring constructors.
  runStepIntoThroughProgramRecordingStops(stops),
  checkRecordedStops(stops, expected),
];

void main([args = const <String>[]]) => runIsolateTests(
  args,
  tests,
  'declaring_constructors_t02.dart',
  pauseOnExit: true,
  testeeConcurrent: testeeMain,
);
