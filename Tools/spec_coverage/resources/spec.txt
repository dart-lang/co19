






















































































































































































































































































































































































































































Dart Programming Language Specification

6th edition draft

Version 2.13-dev
    
    March 13, 2025
============================================================================





myheadings
Dart Programming Language Specification





¬ß SCOPE

ecmaScope


This Ecma standard specifies the syntax and semantics of
the Dart programming language.
It does not specify the APIs of the Dart libraries
except where those library elements are essential to
the correct functioning of the language itself
(e.g., the existence of class Object with methods
such as noSuchMethod, runtimeType).




¬ß CONFORMANCE

ecmaConformance


A conforming implementation of the Dart programming language
must provide and support all the APIs
(libraries, types, functions, getters, setters,
whether top-level, static, instance or local)
mandated in this specification.


A conforming implementation is permitted to provide additional APIs,
but not additional syntax,
except for experimental features.




¬ß NORMATIVE REFERENCES

ecmaNormativeReferences


The following referenced documents are indispensable for
the application of this document.
For dated references, only the edition cited applies.
For undated references, the latest edition of the referenced document
(including any amendments) applies.



  * The Unicode Standard, Version 5.0, as amended by Unicode 5.1.0, or successor.

  * Dart API Reference, https://api.dartlang.org/





¬ß TERMS AND DEFINITIONS

ecmaTermsAndDefinitions


Terms and definitions used in this specification are given in
the body of the specification proper.





¬ß NOTATION

notation


We distinguish between normative and non-normative text.
Normative text defines the rules of Dart.
It is given in this font.
At this time, non-normative text includes:


  Rationale
  Discussion of the motivation for language design decisions appears in italics.

Distinguishing normative from non-normative helps clarify
what part of the text is binding and what part is merely expository.


  Commentary
  Comments such as
  ‚Äú
    The careful reader will have noticed
    that the name Dart has four characters
  ‚Äù
  serve to illustrate or clarify the specification,
  but are redundant with the normative text.

The difference between commentary and rationale can be subtle.


Commentary is more general than rationale,
and may include illustrative examples or clarifications.




Reserved words and built-in identifiers
(<ref>)
appear in bold.


Examples would be  or .



Grammar productions are given in a common variant of EBNF.
The left hand side of a production ends with `::='.
On the right hand side, alternation is represented by vertical bars,
and sequencing by spacing.
As in PEGs, alternation gives priority to the left.
Optional elements of a production are suffixed by a question mark
like so: anElephant?.
Appending a star to an element of a production means
it may be repeated zero or more times.
Appending a plus sign to a production means it occurs one or more times.
Parentheses are used for grouping.
Negation is represented by prefixing an element of a production with a tilde.
Negation is similar to the not combinator of PEGs,
but it consumes input if it matches.
In the context of a lexical production it consumes
a single character if there is one;
otherwise, a single token if there is one.


An example would be:



<aProduction> ::= <anAlternative>
  <anotherAlternative>
  <oneThing> <after> <another>
  <zeroOrMoreThings>*
  <oneOrMoreThings>+
  <anOptionalThing>?
  (<some> <grouped> <things>)
  <notAThing>
  `aTerminal'
  <A_LEXICAL_THING>



Both syntactic and lexical productions are represented this way.
Lexical productions are distinguished by their names.
The names of lexical productions consist exclusively of
upper case characters and underscores.
As always, within grammatical productions,
whitespace and comments between elements of the production
are implicitly ignored unless stated otherwise.
Punctuation tokens appear in quotes.


Productions are embedded, as much as possible,
in the discussion of the constructs they represent.


A term is a syntactic construct.
It may be considered to be a piece of text which is derivable in the grammar,
and it may be considered to be a tree created by such a derivation.
An immediate subterm of a given term t is a syntactic construct
which corresponds to an immediate subtree of t
considered as a derivation tree.
A subterm of a given term t is t,
or an immediate subterm of t,
or a subterm of an immediate subterm of t.


A list x_1, ‚Ä¶, x_n denotes any list of
n elements of the form x_i, 1 ‚â§ i ‚â§ n.
Note that n may be zero, in which case the list is empty.
We use such lists extensively throughout this specification.

j, y_j, x_j

For j ‚àà 1 .. n,
let y_j be an atomic syntactic entity (like an identifier),
x_j a composite syntactic entity (like an expression or a type),
and E again a composite syntactic entity.
The notation
[x_1/y_1, ‚Ä¶, x_n/y_n]E[x1/y1, ..., xn/yn]E@[x/y‚Ä¶]E
then denotes a copy of E
in which each occurrence of y_i, 1 ‚â§ i ‚â§ n has been replaced by x_i.


This operation is also known as substitution,
and it is the variant that avoids capture.
That is, when E contains a construct that introduces y_i into
a nested scope for some i ‚àà 1 .. n,
the substitution will not replace y_i in that scope.
Conversely, if such a replacement would put an identifier ùïÄ
(a subterm of x_i) into a scope where ùïÄ is declared,
the relevant declarations in E are systematically renamed to fresh names.


In short, capture freedom ensures that the ‚Äúmeaning‚Äù of each identifier
is preserved during substitution.



We sometimes abuse list or map literal syntax, writing [o1n]
(respectively {k_1: o_1, ‚Ä¶, k_n: o_n})
where the o_i and k_i may be objects rather than expressions.
The intent is to denote a list (respectively map) object
whose elements are the o_i
(respectively, whose keys are the k_i and values are the o_i).


x, op, y
The specifications of operators often involve statements such as
x op y is equivalent to the method invocation
x.op(y)
  x.op(y)@x.op(y).
Such specifications should be understood as a shorthand for:


  * x op y is equivalent to the method invocation
  x.op'(y),
  assuming the class of x actually declared a non-operator method named op'
  defining the same function as the operator op.



This circumlocution is required because
x.op(y), where op is an operator, is not legal syntax.
However, it is painfully verbose, and we prefer to state this rule once here,
and use a concise and clear notation across the specification.



When the specification refers to the order given in the program,
it means the order of the program source code text,
scanning left-to-right and top-to-bottom.


When the specification refers to a
fresh variablevariable!fresh,
it means a local variable with a name that doesn't occur anywhere
in the current program.
When the specification introduces a fresh variable bound to an object,
the fresh variable is implicitly bound in a surrounding scope.


References to otherwise unspecified names of program entities
(such as classes or functions)
are interpreted as the names of members of the Dart core library.


Examples would be the classes Object and Type
representing, respectively, the root of the class hierarchy and
the reification of run-time types.

It would be possible to declare, e.g.,
a local variable named Object,
so it is generally incorrect to assume that
the name Object will actually resolve to said core class.
However, we will generally omit mentioning this, for brevity.










When the specification says that one piece of syntax is equivalent to
another piece of syntax, it means that it is equivalent in all ways,
and the former syntax should generate the same compile-time errors
and have the same run-time behavior as the latter, if any.

Error messages, if any, should always refer to the original syntax.

If execution or evaluation of a construct is said to be
equivalent to execution or evaluation of another construct,
then only the run-time behavior is equivalent,
and compile-time errors apply only for the original syntax.


s, s'
When the specification says that one piece of syntax s is
treated as
another piece of syntax s',
it means that the static analysis of s is the static analysis of s'
(in particular, exactly the same compile-time errors occur).
Moreover, if s has no compile-time errors then
the behavior of s at run time is exactly the behavior of s'.


Error messages, if any, should always refer to the original syntax s.



In short, whenever s is treated as s',
the reader should immediately switch to the section about s'
in order to get any further information about
the static analysis and dynamic semantics of s.



The notion of being `treated as' is similar to the notion of syntactic sugar:
‚Äús is treated as s'‚Äù
could as well have been worded
‚Äús is desugared into s'‚Äù.
Of course, it should then actually be called ‚Äúsemantic sugar‚Äù,
because the applicability of the transformation and the construction of s'
may rely on information from static analysis.

The point is that we only specify the static analysis and dynamic semantics
of a core language which is a subset of Dart
(just slightly smaller than Dart),
and desugaring transforms any given Dart program to
a program in that core language.
This helps keeping the language specification consistent and comprehensible,
because it shows directly
that some language features are introducing essential semantics,
and others are better described as mere abbreviations of existing constructs.



The specification uses one syntactic construct, the
 expressionlet expression@ expression,
which is not derivable in the grammar
(that is, no Dart source code contains such an expression).
This expression is helpful in specifying certain syntactic forms
that are treated as other syntactic forms,
because it allows for introducing and initializing one or more fresh variables,
and using them in an expression.


That is, a  expression is only introduced as a tool
to define the evaluation semantics of an expression
in terms of other expressions containing  expressions.



The syntax of a  expression is as follows:


<letExpression> ::=  <staticFinalDeclarationList>  <expression>



e_let, e_j, v_j, k
Let e_let be a  expression of the form
v_1e_1v_ke_ke.
It is tacitly assumed that v_j is a fresh variable, j ‚àà 1 .. k,
unless something is stated to the contrary.


e_let contains k nested scopes, S1k.
The enclosing scope for S_1 is the current scope for e_let,
and the enclosing scope for S_j is S_j-1, j ‚àà 2 .. k.
The current scope of e_1 is the current scope of e_let,
the current scope of e_j is S_j-1, j ‚àà 2 .. k,
and the current scope of e is S_k.
For j ‚àà 1 .. k, v_j introduces a final, local variable into S_j,
with the static type of e_j as its declared type.


Type inference of e_j and the context type used for inference of e_j
are not relevant.
It is generally assumed that type inference has occurred already
(<ref>).



Evaluation of e_let proceeds by
evaluating e_j to an object o_j and binding v_j to o_j,
where j ‚àà 1 .. k, in that order.
Finally, e is evaluated to an object o and then
e_let evaluates to o.


The right margin of each page in this document is used to indicate
referenced entities.


The document contains an index at the end.
Each entry in the index refers to a page number, p.
On page p there is a `‚ô¢' in the margin
at the definition of the given indexed phrase,
and the phrase itself is shown using this typeface.
We have hereby introduced the
index marker ‚ô¢
itself.


The right margin also contains symbols.
Whenever a symbol
C
x_j
(say, C or x_j)
is introduced and used in more than a few lines of text,
it is shown in the margin.


The point is that it is easy to find the definition of a symbol
by scanning back in the text until that symbol occurs in the margin.
To avoid useless verbosity, some symbols are not mentioned in the margin.
For instance, we may introduce e1k,
but only show e_j and k in the margin.

Note that it may be necessary to look at a few lines of text
above the `‚ô¢' or symbol,
because the margin markers can be pushed down one line
when there is more than one marker for a single line.





¬ß OVERVIEW

overview


Dart is a class-based, single-inheritance, pure
object-oriented programming language.
Dart is optionally typed (<ref>) and supports reified generics.
The run-time type of every object is represented as
an instance of class Type which can be obtained
by calling the getter runtimeType declared in class Object,
the root of the Dart class hierarchy.


Dart programs may be statically checked.
Programs with compile-time errors do not have a specified dynamic semantics.
This specification makes no attempt to answer additional questions
about a library or program at the point
where it is known to have a compile-time error.


However, tools may choose to support execution of some programs with errors.
For instance, a compiler may compile certain constructs with errors such that
a dynamic error will be raised if an attempt is made to
execute such a construct,
or an IDE integrated runtime may support opening
an editor window when such a construct is executed,
allowing developers to correct the error.
It is expected that such features would amount to a natural extension of the
dynamic semantics of Dart as specified here, but, as mentioned,
this specification makes no attempt to specify exactly what that means.



As specified in this document,
dynamic checks are guaranteed to be performed in certain situations,
and certain violations of the type system throw exceptions at run time.


An implementation is free to omit such checks whenever they are
guaranteed to succeed, e.g., based on results from the static analysis.



The coexistence between optional typing and reification
is based on the following:


  * Reified type information reflects the types of objects at run time
  and may always be queried by dynamic typechecking constructs
  (the analogs of instanceOf, casts, typecase etc. in other languages).
  Reified type information includes
  access to instances of class Type representing types,
  the run-time type (aka class) of an object,
  and the actual values of type parameters
  to constructors and generic function invocations.

  * Type annotations declare the types of
  variables and functions (including methods and constructors).

  * 
  Type annotations may be omitted, in which case they are generally
  filled in with the type 
  (<ref>).





Dart as implemented includes extensive support for inference of omitted types.
This specification makes the assumption that inference has taken place,
and hence inferred types are considered to be present in the program already.
However, in some cases no information is available
to infer an omitted type annotation,
and hence this specification still needs to specify how to deal with that.
A future version of this specification will also specify type inference.



Dart programs are organized in a modular fashion into
units called libraries (<ref>).
Libraries are units of encapsulation and may be mutually recursive.


However they are not first class.
To get multiple copies of a library running simultaneously,
one needs to spawn an isolate.



A dart program execution may occur with assertions enabled or disabled.
The method used to enable or disable assertions is implementation specific.




 ¬ß.¬ß Scoping

scoping


A compile-time namespacenamespace!compile-time
is a partial function that maps names to namespace values.
Compile-time namespaces are used much more frequently than run-time namespaces
(defined later in this section),
so when the word namespace is used alone,
it means compile-time namespace.
A name is a lexical token which is an IDENTIFIER,
an IDENTIFIER followed by =, or
an operator,
or unary-;
and a namespace value is
a declaration, a namespace, or the special value 
(<ref>).


If n = V then we say that 
mapsnamespace!maps a key to a value
the
keynamespace!key
n to the
valuenamespace!value
V,
and that 
has the bindingnamespace!has a binding
n‚Ü¶V.

The fact that  is a partial function just means that
each name is mapped to at most one namespace value.
That is, if  has the bindings
n‚Ü¶V_1 and n‚Ü¶V_2
then V_1 = V_2.



Let  be a namespace.
We say that a name n is in 
if n is a key of .
We say a declaration d is in 
if a key of  is mapped to d.


A scope S_0 has an associated namespace 0.
The bindings of 0 is specified in this document by saying that
a given declaration D, nD named n
introducesdeclaration!introduces an entity into a scope
a specific entity V into S_0,
which means that the binding n‚Ü¶V is added to 0.


In some cases, the name of the declaration differs from
the identifier that occurs in the declaration syntax used to declare it.
Setters have names that are distinct from the corresponding getters
because they always have an = automatically added at the end,
and the unary minus operator has the special name unary-.



It is typically the case that V is the declaration D itself,
but there are exceptions.
For example,
a variable declaration introduces an implicitly induced getter declaration,
and in some cases also an implicitly induced setter declaration into the
given scope.



Note that labels (<ref>) are not included in the namespace of a scope.
They are resolved lexically rather then being looked up in a namespace.



It is a compile-time error if there is more than one entity with the same name
declared in the same scope.


It is therefore impossible, e.g., to define a class that declares
a method and a getter with the same name in Dart.
Similarly one cannot declare a top-level function with
the same name as a library variable or a class
which is declared in the same library.



We introduce the notion of a
run-time namespace.
This is a partial function from names to run-time entities,
in particular storage locations and functions.
Each run-time namespace corresponds to a namespace with the same keys,
but with values that correspond to the semantics of the namespace values.


A namespace typically maps a name to a declaration,
and it can be used statically to figure out what that name refers to.
For example,
a variable is associated with an actual storage location at run time.
We introduce the notion of a run-time namespace based on a namespace,
such that the dynamic semantics can access run-time entities
like that storage location.
The same code may be executed multiple times with the same run-time namespace,
or with different run-time namespaces for each execution.
E.g., local variables declared inside a function
are specific to each invocation of the function,
and instance variables are specific to an object.



Dart is lexically scoped.
Scopes may nest.
A name or declaration d is available in scope S
if d is in the namespace induced by S or
if d is available in the lexically enclosing scope of S.
We say that a name or declaration d is in scope
if d is available in the current scope.


If a declaration d named n is in the namespace induced by a scope S,
then d hides any declaration named n that is available
in the lexically enclosing scope of S.


A consequence of these rules is that it is possible to hide a type
with a method or variable.
Naming conventions usually prevent such abuses.
Nevertheless, the following program is legal:



 HighlyStrung {
  String() => "?";
}



Names may be introduced into a scope by declarations within the scope
or by other mechanisms such as imports or inheritance.


The interaction of lexical scoping and inheritance is a subtle one.
Ultimately, the question is whether lexical scoping
takes precedence over inheritance or vice versa.
Dart chooses the former.

Allowing inherited names to take precedence over locally declared names
could create unexpected situations as code evolves.
Specifically, the behavior of code in a subclass could silently change
if a new name is introduced in a superclass.
Consider:



 L1;
 S {}

 L2;
 `L1.dart';
foo() => 42;
 C  S{ bar() => foo();}



Now assume a method foo() is added to S.



 L1;
 S {foo() => 91;}



If inheritance took precedence over the lexical scope,
the behavior of C would change in an unexpected way.
Neither the author of S nor the author of C
are necessarily aware of this.
In Dart, if there is a lexically visible method foo(),
it will always be called.

Now consider the opposite scenario.
We start with a version of S that contains foo(),
but do not declare foo() in library L2.
Again, there is a change in behavior‚Äîbut the author of L2
is the one who introduced the discrepancy that effects their code,
and the new code is lexically visible.
Both these factors make it more likely that the problem will be detected.

These considerations become even more important
if one introduces constructs such as nested classes,
which might be considered in future versions of the language.

Good tooling should of course endeavor to inform programmers
of such situations (discreetly).
For example, an identifier that is both inherited and lexically visible
could be highlighted (via underlining or colorization).
Better yet, tight integration of source control with language aware tools
would detect such changes when they occur.





 ¬ß.¬ß Privacy

privacy


Dart supports two levels of privacy: public and private.
A declaration is privateprivate!declaration
iff its name is private,
otherwise it is publicpublic!declaration.
A name q is privateprivate!name
iff any one of the identifiers that comprise q is private,
otherwise it is publicpublic!name.
An identifier is privateprivate!identifier
iff it begins with an underscore (the _ character)
otherwise it is publicpublic!identifier.


A declaration m is accessible to a library L
if m is declared in L or if m is public.


This means private declarations may only be accessed within
the library in which they are declared.



Privacy applies only to declarations within a library,
not to the library declaration as a whole.
This is because libraries do not reference each other by name,
and so the idea of a private library is meaningless
(<ref>).
Thus, if the name of a library begins with an underscore,
it has no effect on the accessibility of the library or its members.



Privacy is, at this point, a static notion tied to
a particular piece of code (a library).
It is designed to support software engineering concerns
rather than security concerns.
Untrusted code should always run in an another isolate.

Privacy is indicated by the name of a declaration‚Äîhence
privacy and naming are not orthogonal.
This has the advantage that both humans and machines
can recognize access to private declarations at the point of use
without knowledge of the context from which the declaration is derived.





 ¬ß.¬ß Concurrency

concurrency


Dart code is always single threaded.
There is no shared-state concurrency in Dart.
Concurrency is supported via actor-like entities called isolates.


An isolate is a unit of concurrency.
It has its own memory and its own thread of control.
Isolates communicate by message passing (<ref>).
No state is ever shared between isolates.
Isolates are created by spawning (<ref>).




¬ß ERRORS AND WARNINGS

errorsAndWarnings


This specification distinguishes between several kinds of errors.


Compile-time errorscompile-time error
are errors that preclude execution.
A compile-time error must be reported by a Dart compiler
before the erroneous code is executed.


A Dart implementation has considerable freedom
as to when compilation takes place.
Modern programming language implementations
often interleave compilation and execution,
so that compilation of a method may be delayed, e.g.,
until it is first invoked.
Consequently, compile-time errors in a method m may be reported
as late as the time of m's first invocation.

Dart is often loaded directly from source,
with no intermediate binary representation.
In the interests of rapid loading, Dart implementations
may choose to avoid full parsing of method bodies, for example.
This can be done by tokenizing the input and
checking for balanced curly braces on method body entry.
In such an implementation, even syntax errors will be detected
only when the method needs to be executed,
at which time it will be compiled (JITed).

In a development environment a compiler should of course
report compilation errors eagerly so as to best serve the programmer.

A Dart development environment might choose to support
 error eliminating program transformations, e.g.,
replacing an erroneous expression by the invocation of a debugger.
It is outside the scope of this document
to specify how such transformations work,
and where they may be applied.



If an uncaught compile-time error occurs
within the code of a running isolate A, A is immediately suspended.
The only circumstance where a compile-time error could be caught would be
via code run reflectively, where the mirror system can catch it.


Typically, once a compile-time error is thrown and A is suspended,
A will then be terminated.
However, this depends on the overall environment.
A Dart engine runs in the context of a runtime,
a program that interfaces between the engine and
the surrounding computing environment.
The runtime may be, for instance, a C++ program on the server.
When an isolate fails with a compile-time error as described above,
control returns to the runtime,
along with an exception describing the problem.
This is necessary so that the runtime can clean up resources etc.
It is then the runtime's decision whether to terminate the isolate or not.



Static warningsstatic warning
are situations that do not preclude execution,
but which are unlikely to be intended,
and likely to cause bugs or inconveniences.
A Dart compiler is free to report some, all,
or none of the specified static warnings before the associated code is executed.
A Dart compiler may also choose to report additional warnings
not defined by this specification.


When this specification says that a dynamic error occurs,
it means that a corresponding error object is thrown.
When it says that a dynamic type error occurs,
it represents a failed type check at run time,
and the object which is thrown implements TypeError.


Whenever we say that an exception ex is
thrownthrowing an exception,
it acts like an expression had thrown (<ref>)
with ex as exception object and with a stack trace
corresponding to the current system state.
When we say that a C is thrownthrowing a class,
where C is a class, we mean that an instance of class C is thrown.


If an uncaught exception is thrown by a running isolate A,
A is immediately suspended.




¬ß VARIABLES

variables


Variables are storage locations in memory.


<finalConstVarOrType> ::= ?  <type>?
   <type>?
  ? <varOrType>

<varOrType> ::= 
  <type>

<initializedVariableDeclaration> ::= 
  <declaredIdentifier> (`=' <expression>)? (`,' <initializedIdentifier>)*

<initializedIdentifier> ::= <identifier> (`=' <expression>)?

<initializedIdentifierList> ::=
  <initializedIdentifier> (`,' <initializedIdentifier>)*



An initializedVariableDeclaration
that declares two or more variables
is equivalent to multiple variable declarations declaring
the same set of variable names, in the same order,
with the same initialization, type, and modifiers.


For example,
 x, y;
is equivalent to
 x;  y;
and
     String s1, s2 = "foo";
is equivalent to having both
     String s1;
and
     String s2 = "foo";.



It is possible for a variable declaration to include the modifier .
The effect of doing this with an instance variable is described elsewhere
(<ref>).
It is a compile-time error for the declaration of a variable
which is not an instance variable to include the modifier .


A formal parameter declaration induces a local variable into a scope,
but formal parameter declarations are not variable declarations
and do not give rise to the above error.
The effect of having the modifier  on a formal parameter
is described elsewhere
(<ref>).



In a variable declaration of one of the forms
N  ùïÄ;
or
N  ùïÄ = e;
where N is derived from
<metadata> <finalConstVarOrType> and ùïÄ is an identifier,
we say that ùïÄ is a declaring occurrence of the identifier.
For every identifier which is not a declaring occurrence,
we say that it is a referencing occurrence.
We also abbreviate that to say that an identifier is
a declaring identifier respectively an referencing identifier.


In an expression of the form e.ùïÄ' it is possible that
e has static type  and ùïÄ' cannot be associated with
any specific declaration named ùïÄ' at compile-time,
but in this situation ùïÄ' is still a referencing identifier.



For brevity, we will refer to a variable using its name,
even though the name of a variable and the variable itself
are very different concepts.


So we will talk about ‚Äúthe variable ùïÄ‚Äù,
rather than introducing ‚Äúthe variable v named ùïÄ‚Äù,
in order to be able to say ‚Äúthe variable v‚Äù later on.
This should not create any ambiguities,
because the concept of a name and the concept of a variable
are so different.



An initializing variable declaration
is a variable declaration whose declaring identifier is
immediately followed by `=' and an initializing expression.


A variable declared at the top-level of a library is referred to as either a
library variablevariable!library or a
top-level variablevariable!top-level.
It is a compile-time error if a library variable declaration
has the modifier .


A static variablevariable!static
is a variable whose declaration is
immediately nested inside a , , , or  declaration
and includes the modifier .


A compile-time error occurs if a static or library variable has
no initializing expression and a type which is not nullable
(<ref>),
unless the variable declaration has
the modifier  or the modifier .


A non-local variablevariable!non-local
is a library variable, a static variable, or an instance variable.

That is, any kind of variable which is not a local variable.



A constant variablevariable!constant
is a variable whose declaration includes the modifier .
A constant variable must be initialized to a constant expression
(<ref>),
or a compile-time error occurs.


An initializing expression e of a constant variable declaration
occurs in a constant context
(<ref>).
This means that  modifiers in e need not be specified explicitly.



It is grammatically impossible for a constant variable declaration
to have the modifier .
However, even if it had been grammatically possible,
a  constant variable would still have to be a compile-time error,
because being a compile-time constant is inherently incompatible
with being computed late.

Similarly, an instance variable cannot be constant
(<ref>).





 ¬ß.¬ß Implicitly Induced Getters and Setters

implicitlyInducedGettersAndSetters












The following rules on implicitly induced getters and setters
apply to all non-local variable declarations.

Local variable declarations
(<ref>)
do not induce getters or setters.



Getter: Variable with declared type
Consider a variable declaration of one of the forms



  * ?  ?  ?  T  ùïÄ;

  * ?  ?  ?  T  ùïÄ = e;

  * ?    T  ùïÄ = e;


where T is a type, ùïÄ is an identifier,
and ? indicates that the given modifier may be present or absent.
Each of these declarations implicitly induces a getter
(<ref>)
with the header T    ùïÄ,
whose invocation evaluates as described below
(<ref>).
In these cases the declared type of ùïÄ is T.



Getter: Variable with no declared type
A variable declaration of one of the forms



  * ?  ?    ùïÄ;

  * ?  ?    ùïÄ = e;

  * ?  ?    ùïÄ;

  * ?  ?    ùïÄ = e;

  * ?    ùïÄ = e;


implicitly induces a getter with the header that
contains  iff the declaration contains  and is followed by
T    ùïÄ,
where T is obtained from type inference
in the case where e exists,
and T is  otherwise.
The invocation of this getter evaluates as described below
(<ref>).
In these cases, the declared type of ùïÄ is T.



Setter: Mutable variable with declared type
A variable declaration of one of the forms



  * ?  ?  T  ùïÄ;

  * ?  ?  T  ùïÄ = e;


implicitly induces a setter (<ref>) with the header
    ùïÄ(T  x),
whose execution sets the value of ùïÄ to the incoming argument x.


Setter: Mutable variable with no declared type, with initialization
A variable declaration of the form
?  ?    ùïÄ = e;
implicitly induces a setter with the header
    ùïÄ(  x),
whose execution sets the value of ùïÄ to the incoming argument x.


Type inference could have provided a type different from 
(<ref>).




Setter: Mutable variable with no declared type, no initialization
A variable declaration of the form
?  ?    ùïÄ;
implicitly induces a setter with the header
    ùïÄ(  x),
whose execution sets the value of ùïÄ to the incoming argument x.


Type inference has not yet been specified in this document
(<ref>).
Note that type inference could change, e.g.,
  x; to T  x;,
which would take us to an earlier case.




Setter: Late-final variable with declared type
A variable declaration of the form
?      T  ùïÄ;
implicitly induces a setter (<ref>) with the header
    ùïÄ(T  x).
If this setter is executed
in a situation where the variable ùïÄ has not been bound,
it will bind ùïÄ to the object that x is bound to.
If this setter is executed
in a situation where the variable ùïÄ has been bound to an object,
a dynamic error occurs.



Setter: Late-final variable with no declared type, no initialization
A variable declaration of the form
?      ùïÄ;
implicitly induces a setter with the header
    ùïÄ(  x).
An execution of said setter
in a situation where the variable ùïÄ has not been bound
will bind ùïÄ to the object that the argument x is bound to.
An execution of the setter
in a situation where the variable ùïÄ has been bound to an object
will incur a dynamic error.



The scope into which the implicit getters and setters are introduced
depends on the kind of variable declaration involved.


A library variable introduces a getter into
the library scope of the enclosing library.
A static variable introduces a static getter into
the body scope of the immediately enclosing
class, mixin, enum, or extension declaration.
An instance variable introduces an instance getter into
the body scope of the immediately enclosing
class, mixin, or enum declaration
(an extension cannot declare instance variables).


A non-local variable introduces a setter iff
it does not have the modifier  or the modifier ,
or it is  and , but does not have an initializing expression.


A library variable which introduces a setter will introduce
a library setter into the enclosing library scope.
A static variable which introduces a setter will introduce
a static setter into the body scope of the immediately enclosing
class, mixin, enum, or extension declaration.
An instance variable that introduces a setter will introduce
an instance setter into the body scope of the immediately enclosing
class, mixin, or enum declaration
(an extension cannot declare instance variables).


Let ùïÄ be a variable declared by a variable declaration
that has an initializing expression e.
It is a compile-time error if the static type of e
is not assignable to the declared type of ùïÄ.
It is a compile-time error if a final instance variable
whose declaration has an initializer expression
is also initialized by a constructor,
either by an initializing formal or an initializer list entry.


It is a compile-time error if a final instance variable
that has been initialized by means of
an initializing formal of a constructor k
is also initialized in the initializer list of k
(<ref>).

A non-late static variable declaration D named ùïÄ
that has the modifier  or the modifier 
does not induce a setter.
However, an assignment to ùïÄ at a location where D is in scope
is not necessarily a compile-time error.
For example, a setter named ùïÄ= could be found by lexical lookup
(<ref>).

Similarly, a non-late final instance variable ùïÄ does not induce a setter,
but an assignment could be an invocation of
a setter which is provided in some other way.
For example, it could be that lexical lookup yields nothing,
and the location of the assignment has access to ,
and the interface of an enclosing class has a setter named ùïÄ=
(in this case both the getter and setter are inherited).



Consider a variable ùïÄ
whose declaration does not have the modifier .
Assume that ùïÄ does not have an initializing expression,
and it is not initialized by an initializing formal
(<ref>),
nor by an element in a constructor initializer list
(<ref>).
The initial value of ùïÄ is then the null object
(<ref>).


Note that there are many situations where such a variable declaration
is a compile-time error,
in which case the initial value is of course irrelevant.



Otherwise, variable initialization proceeds as follows:


A declaration of a static or library variable
with an initializing expression is initialized lazily
(<ref>).


The lazy semantics are given because we do not want a language
where one tends to define expensive initialization computations,
causing long application startup times.
This is especially crucial for Dart,
which must support the coding of client applications.



Initialization of an instance variable with no initializing expression
takes place during constructor execution
(<ref>).



ùïÄ, o
Initialization of an instance variable ùïÄ
with an initializing expression e
proceeds as follows:
e is evaluated to an object o
and the variable ùïÄ is bound to o.


It is specified elsewhere when this initialization occurs,
and in which environment
(p. executionOfGenerativeConstructors,
<ref>,
<ref>).



If the initializing expression throws then
access to the uninitialized variable is prevented,
because the instance creation
that caused this initialization to take place
will throw.




It is a dynamic type error if the dynamic type of o is not
a subtype of the actual type of the variable ùïÄ
(<ref>).




 ¬ß.¬ß Evaluation of Implicit Variable Getters

evaluationOfImplicitVariableGetters


We introduce two specific kinds of getters in order to specify
the behavior of various kinds of variables
without duplicating the specification of their common behaviors.


A
late-initialized gettergetter!late-initialized
is a getter g which is implicitly induced by a non-local variable v
that has an initializing expression e.

It is described below which declarations induce a late-initialized getter.

An invocation of g proceeds as follows:


If the variable v has not been bound to an object then
e is evaluated to an object o.
If v has now been bound to an object, and v is final,
a dynamic error occurs. 
Otherwise, v is bound to o,
and the evaluation of g completes returning o.
If the evaluation of e throws then
the invocation of g completes throwing the same object and stack trace,
and does not change the binding of v.


An invocation of g in a situation where v has been bound to an object o'
completes immediately, returning o'.


Consider a non-local variable declaration of the form
    x = e;,
whose implicitly induced getter is late-initialized.
Perhaps surprisingly,
if the variable x has been bound to an object
when its getter is invoked for the first time,
e will never be executed.
In other words, the initializing expression can be pre-empted by an assignment.



Also note that an initializing expression can have side effects
that are significant during initialization.
For example:



bool b = ;
int i = (() => (b = !b) ? (i = 10) : i + 1)();


 main() {
  print(i); // '11'.
}



In this example, main invokes
the implicitly induced getter named i,
and the variable i has not been bound at this point.
Hence, evaluation of the initializing expression proceeds.
This causes b to be toggled to ,
which again causes i + 1 to be evaluated.
This causes the getter i to be invoked again,
and it is still true that the variable has not been bound,
so the initializing expression is evaluated again.
This toggles b to ,
which causes i = 10 to be evaluated,
which causes the implicitly induced setter named i= to be invoked,
and the most recent invocation of the getter i
returns 10.
This makes i + 1 evaluate to 11,
and the variable is then bound to 11.
Finally, the invocation of the getter i in main
completes returning 11.



This is a change from the semantics of older versions of Dart:
Throwing an exception during initializer evaluation no longer sets the
variable to null,
and reading the variable during initializer evaluation
no longer causes a dynamic error.



A
late-uninitialized gettergetter!late-uninitialized
is a getter g which is implicitly induced by a non-local variable v
that does not have an initializing expression.

Again, only some non-local variables without an initializing expression
induce a late-uninitialized getter, as specified below.

An invocation of g proceeds as follows:
If the variable v has not been bound to an object then a dynamic error occurs.
If v has been bound to an object o' then
the invocation of g completes immediately, returning o'.


d, ùïÄ
Let d be the declaration of a non-local variable named ùïÄ.
For brevity, we will refer to it below as
`the variable ùïÄ' or `the variable d', or just as `ùïÄ' or `d'.
Execution of the implicitly induced getter of ùïÄ proceeds as follows:


Non-late instance variable
If d declares an instance variable which does not have the modifier ,
then the invocation of the implicit getter of ùïÄ evaluates to
the object that ùïÄ is bound to.


It is not possible to invoke an instance getter on an object
before the object has been initialized.
Hence, a non-late instance variable is always bound
when the instance getter is invoked.




Late, initialized instance variable
If d declares an instance variable ùïÄ which has the modifier 
and an initializing expression,
the implicitly induced getter of ùïÄ is a
late-initialized getter.
This determines the semantics of an invocation.



Late, uninitialized instance variable
If d declares an instance variable ùïÄ which has the modifier 
and does not have an initializing expression,
the implicitly induced getter of ùïÄ is a
late-uninitialized getter.
This determines the semantics of an invocation.


In this case it is possible for ùïÄ to be unbound,
but there are also several ways to bind ùïÄ to an object:
A constructor can have an initializing formal
(<ref>)
or an initializer list entry
(<ref>)
that will initialize ùïÄ,
and the implicitly induced setter named ùïÄ= could
have been invoked and completed normally.




Static or library variable
If d declares a static or library variable,
the implicitly induced getter of ùïÄ executes as follows:



  * Non-constant variable with an initializer.
  In the case where d has an initializing expression and is not constant,
  the implicitly induced getter of ùïÄ is a late-initialized getter.
  This determines the semantics of an invocation.
  
    Note that these static or library variables can be implicitly
    late-initialized, in the sense that they do not have
    the modifier .
  

  * Constant variable.
  If d declares a constant variable with the initializing expression e,
  the result of executing the implicitly induced getter is
  the value of the constant expression e.
  
  Note that a constant expression cannot depend on itself,
  so no cyclic references can occur.
  

  * Variable without an initializer.
  If d declares a variable ùïÄ without an initializing expression
  and does not have the modifier ,
  an invocation of the implicitly induced getter of ùïÄ evaluates to
  the object that ùïÄ is bound to.

  
    The variable is always bound to an object in this case.
    This may be the null object,
    which is the initial value of some variable declarations
    covered by this case.
  

  If d declares a variable ùïÄ without an initializing expression
  and has the modifier ,
  the implicitly induced getter is a late-uninitialized getter.
  This determines the semantics of an invocation.









¬ß FUNCTIONS

functions


Functions abstract over executable actions.


<functionSignature> ::= 
  <type>? <identifier> <formalParameterPart>

<formalParameterPart> ::= <typeParameters>? <formalParameterList>

<functionBody> ::= ? `=>' <expression> `;'
  ( `*'? |  `*')? <block>

<block> ::= `' <statements> `'



Functions can be introduced by function declarations
(<ref>),
method declarations (<ref>, <ref>),
getter declarations (<ref>),
setter declarations (<ref>),
and constructor declarations (<ref>);
and they can be introduced by function literals (<ref>).


A function is asynchronousfunction!asynchronous
if its body is marked with the  or * modifier.
Otherwise the function is synchronousfunction!synchronous.
A function is a generatorfunction!generator
if its body is marked with the * or * modifier.
Further details about these concepts are given below.


Whether a function is synchronous or asynchronous is orthogonal to
whether it is a generator or not.
Generator functions are a sugar for functions
that produce collections in a systematic way,
by lazily applying a function that generates
individual elements of a collection.
Dart provides such a sugar in both the synchronous case,
where one returns an iterable,
and in the asynchronous case, where one returns a stream.
Dart also allows both synchronous and asynchronous functions
that produce a single value.



Each declaration that introduces a function has a signature that specifies
its return type, name, and formal parameter part,
except that the return type may be omitted,
and getters never have a formal parameter part.
Function literals have a formal parameter part, but no return type and no name.
The formal parameter part optionally specifies
the formal type parameter list of the function,
and it always specifies its formal parameter list.
A function body is either:


  * a block statement (<ref>) containing
  the statements (<ref>) executed by the function,
  optionally marked with one of the modifiers:
  , * or *.
  
  Unless it is statically known that the body of the function
  cannot complete normally
  (that is, it cannot reach the end and ‚Äúfall through‚Äù,
  cf.¬†<ref>),
  it is a compile-time error if
  the addition of ; at the end of the body
  would be a compile-time error.
  
  For instance, it is an error if
  the return type of a synchronous function is int,
  and the body may complete normally.
  The precise rules are given in section¬†<ref>.
  

  
  Because Dart supports dynamic function invocations,
  we cannot guarantee that a function that does not return an object
  will not be used in the context of an expression.
  Therefore, every function must either throw or return an object.
  A function body that ends without doing a throw or return
  will cause the function to return the null object (<ref>),
  as will a  without an expression.
  For generator functions, the situation is more subtle.
  See further discussion in section¬†<ref>.
  

OR

  * of the form => e or the form  => e,
  which both return the value of the expression e as if by a
  return e.
  
  The other modifiers do not apply here,
  because they apply only to generators, discussed below.
  Generators are not allowed to explicitly return anything,
  objects are added to the generated stream or iterable using
   or *.
  
  Let T be the declared return type of the function that has this body.
  It is a compile-time error if one of the following conditions hold:
  
  
  * The function is synchronous, T is not ,
    and it would have been a compile-time error
    to declare the function with the body
    {  e; }
    rather than => e.
    
    In particular, e can have any type when the return type is .
    
    
    This enables concise declarations of  functions.
    It is reasonably easy to understand such a function,
    because the return type is textually near to the returned expression e.
    In contrast,  e; in a block body is only allowed
    for an e with one of a few specific static types,
    because it is less likely that the developer understands
    that the returned object will not be used
    (<ref>).
    
  
  * The function is asynchronous, T is not ,
    and it would have been a compile-time error
    to declare the function with the body
     {  e; }
    rather than  => e.
    
    In particular, e can have any type
    when the flattened return type is ,
    
    
    and the rationale is similar to the synchronous case.
    
  



It is a compile-time error
if an , * or * modifier is attached to
the body of a setter or constructor.


An asynchronous setter would be of little use,
since setters can only be used in the context of an assignment
(<ref>),
and an assignment expression always evaluates to
the value of the assignment's right hand side.
If the setter actually did its work asynchronously,
one might imagine that one would return a future that resolved to
the assignment's right hand side after the setter did its work.

An asynchronous constructor would, by definition, never return
an instance of the class it purports to construct,
but instead return a future.
Calling such a beast via  would be very confusing.
If you need to produce an object asynchronously, use a method.

One could allow modifiers for factories.
A factory for Future could be modified by ,
a factory for Stream could be modified by *,
and a factory for Iterable could be modified by *.
No other scenario makes sense because
the object returned by the factory would be of the wrong type.
This situation is very unusual so it is not worth making an exception
to the general rule for constructors in order to allow it.



It is a compile-time error if the declared return type of
a function marked  is not
a supertype of Future<T> for some type T.
It is a compile-time error if the declared return type of
a function marked * is not
a supertype of Iterable<T> for some type T.
It is a compile-time error if the declared return type of
a function marked * is not
a supertype of Stream<T> for some type T.
It is a compile-time error if the declared return type of
a function marked * or * is .


We define the
union-free type derived from
a type T as follows:
If T is of the form S? or the form FutureOr<S>
then the union-free type derived from T is
the union-free type derived from S.
Otherwise, the union-free type derived from T is T.

For example, the union-free type derived from
FutureOr<int?>? is int.



We define the
element type of a generator function
    function!generator!element type
f as follows:

Let S be the union-free type derived from the declared return type of f.

If f is a synchronous generator and
S implements Iterable<U> for some U
(<ref>)
then the element type of f is U.

If f is an asynchronous generator and
S implements Stream<U> for some U
then the element type of f is U.

Otherwise, if f is a generator (synchronous or asynchronous)
and S is a supertype of Object
(which includes Object itself)
then the element type of f is .
No further cases are possible.




 ¬ß.¬ß Function Declarations

functionDeclarations


A function declaration is a function that
is neither a member of a class nor a function literal.
Function declarations include exactly the following:
library functionsfunction!library,
which are function declarations

at the top level of a library, and
local functionsfunction!local,
which are function declarations declared inside other functions.
Library functions are often referred to simply as top-level functions.


A function declaration consists of an identifier indicating the function's name,
possibly prefaced by a return type.
The function name is followed by a signature and body.
For getters, the signature is empty.
The body is empty for functions that are external.


The scope of a library function is the scope of the enclosing library.
The scope of a local function is described
in section¬†<ref>.
In both cases, the name of the function is in scope
in its formal parameter scope
(<ref>).


It is a compile-time error to preface a function declaration
with the built-in identifier .


When we say that a function f_1 forwards to another function f_2,
we mean that invoking f_1 causes f_2 to be executed
with the same arguments and/or receiver as f_1,
and returns the result of executing f_2 to the caller of f_1,
unless f_2 throws an exception,
in which case f_1 throws the same exception.
Furthermore, we only use the term for
synthetic functions introduced by the specification.




 ¬ß.¬ß Formal Parameters

formalParameters


Every non-getter function declaration includes a
formal parameter list,
which consists of a list of required positional parameters
(<ref>),
followed by any optional parameters (<ref>).
The optional parameters may be specified either as
a set of named parameters or as a list of positional parameters,
but not both.


Some function declarations include a
formal type parameter list (<ref>),
in which case we say that it is a
generic functionfunction!generic.
A non-generic functionfunction!non-generic
is a function which is not generic.


The formal parameter part of a function declaration consists of
the formal type parameter list, if any, and the formal parameter list.


The following kinds of functions cannot be generic:
Getters, setters, operators, and constructors.



The formal type parameter list of a function declaration introduces
a new scope known as the function's
type parameter scopescope!type parameter.
The type parameter scope of a generic function f is enclosed in
the scope where f is declared.
Every formal type parameter introduces a type into the type parameter scope.


If it exists, the type parameter scope of a function f is
the current scope for the signature of f,
and for the formal type parameter list itself;
otherwise the scope where f is declared is
the current scope for the signature of f.


This means that formal type parameters are in scope
in the bounds of parameter declarations,
allowing for so-called F-bounded type parameters like

class C<X  Comparable<X>> { ‚Ä¶ },

and the formal type parameters are in scope for each other,
allowing dependencies like
class D<X  Y, Y> { ‚Ä¶ }.



The formal parameter list of a function declaration introduces
a new scope known as the function's
formal parameter scopescope!formal parameter.
The formal parameter scope of a non-generic function f is enclosed in
the scope where f is declared.
The formal parameter scope of a generic function f is enclosed in
the type parameter scope of f.
Every formal parameter introduces a local variable into
the formal parameter scope.
The current scope for the function's signature is
the scope that encloses the formal parameter scope.


This means that in a generic function declaration,
the return type and parameter type annotations can use
the formal type parameters,
but the formal parameters are not in scope in the signature.



The body of a function declaration introduces
a new scope known as the function's
body scopescope!function body.
The body scope of a function f is enclosed in the scope introduced by
the formal parameter scope of f.


It is a compile-time error if a formal parameter
is declared as a constant variable (<ref>).


<formalParameterList> ::= `(' `)'
  `(' <normalFormalParameters> `,'? `)'
  `(' <normalFormalParameters> `,' <optionalOrNamedFormalParameters> `)'
  `(' <optionalOrNamedFormalParameters> `)'

<normalFormalParameters> ::= 
  <normalFormalParameter> (`,' <normalFormalParameter>)*

<optionalOrNamedFormalParameters> ::= <optionalPositionalFormalParameters>
  <namedFormalParameters>

<optionalPositionalFormalParameters> ::= 
  `[' <defaultFormalParameter> (`,' <defaultFormalParameter>)* `,'? `]'

<namedFormalParameters> ::= 
  `' <defaultNamedParameter> (`,' <defaultNamedParameter>)* `,'? `'



Formal parameter lists allow an optional trailing comma
after the last parameter (`,'?).
A parameter list with such a trailing comma is
equivalent in all ways to the same parameter list without the trailing comma.
All parameter lists in this specification are shown without a trailing comma,
but the rules and semantics apply equally to
the corresponding parameter list with a trailing comma.




  ¬ß.¬ß.¬ß Required Formals

requiredFormals


A required formal parameter may be specified in one of three ways:


  * By means of a function signature that names the parameter and
  describes its type as a function type (<ref>).
  It is a compile-time error if any default values are specified
  in the signature of such a function type.

  * As an initializing formal, which is only valid as a parameter to
  a generative constructor (<ref>).

  * Via an ordinary variable declaration (<ref>).



<normalFormalParameter> ::= 
  <metadata> <normalFormalParameterNoMetadata>

<normalFormalParameterNoMetadata> ::= <functionFormalParameter>
  <fieldFormalParameter>
  <simpleFormalParameter>

<functionFormalParameter> ::= 
  ? <type>? <identifier> <formalParameterPart> `?'?

<simpleFormalParameter> ::= <declaredIdentifier>
  ? <identifier>

<declaredIdentifier> ::= ? <finalConstVarOrType> <identifier>

<fieldFormalParameter> ::= 
  <finalConstVarOrType>?  `.' <identifier> (<formalParameterPart> `?'?)?



It is a compile-time error if a formal parameter has the modifier 
or the modifier .
It is a compile-time error if  occurs as
the first token of a fieldFormalParameter.


It is a compile-time error if a parameter derived from
fieldFormalParameter occurs as a parameter of a function
which is not a non-redirecting generative constructor.


A fieldFormalParameter declares an initializing formal,
which is described elsewhere
(<ref>).



It is possible to include the modifier 
in some forms of parameter declarations.
The effect of doing this is described in a separate section
(<ref>).


Note that the non-terminal normalFormalParameter is also used
in the grammar rules for optional parameters,
which means that such parameters can also be covariant.



It is a compile-time error if the modifier  occurs on
a parameter of a function which is not
an instance method, instance setter, or instance operator.




  ¬ß.¬ß.¬ß Optional Formals

optionalFormals


Optional parameters may be specified and provided with default values.


<defaultFormalParameter> ::= <normalFormalParameter> (`=' <expression>)?

<defaultNamedParameter> ::= 
  <metadata> ? <normalFormalParameterNoMetadata>
   ((`=' | `:') <expression>)?


The form <normalFormalParameter> `:' <expression>
is equivalent to the form
<normalFormalParameter> `=' <expression>.
The colon-syntax is included only for backwards compatibility.
It is deprecated and will be removed in
a later version of the language specification.


It is a compile-time error if the default value of an optional parameter is
not a constant expression (<ref>).
If no default is explicitly specified for an optional parameter
an implicit default of  is provided.


It is a compile-time error if the name of a named optional parameter
begins with an `_` character.


The need for this restriction is a direct consequence of
the fact that naming and privacy are not orthogonal.
If we allowed named parameters to begin with an underscore,
they would be considered private and inaccessible to
callers from outside the library where it was defined.
If a method outside the library overrode a method with a private optional name,
it would not be a subtype of the original method.
The static checker would of course flag such situations,
but the consequence would be that adding a private named formal would break
clients outside the library in a way they could not easily correct.





  ¬ß.¬ß.¬ß Covariant Parameters

covariantParameters


Dart allows formal parameters of instance methods,
including setters and operators,
to be declared .


The syntax for doing this is specified in an earlier section
(<ref>).



It is a compile-time error if the modifier  occurs
in the declaration of a formal parameter of a function
which is not an instance method, an instance setter, or an operator.


As specified below, a parameter can also be covariant for other reasons.
The overall effect of having a covariant parameter p
in the signature of a given method m
is to allow the type of p to be overridden covariantly,
which means that the type required at run time for a given actual argument
may be a proper subtype of the type which is known at compile time
at the call site.



This mechanism allows developers to explicitly request that
a compile-time guarantee which is otherwise supported
(namely: that an actual argument whose static type satisfies the requirement
will also do so at run time)
is replaced by dynamic type checks.
In return for accepting these dynamic type checks,
developers can use covariant parameters to express software designs
where the dynamic type checks are known (or at least trusted) to succeed,
based on reasoning that the static type analysis does not capture.



m, X_j, s
Let m be a method signature with formal type parameters
X1s,
positional formal parameters p1n,
p_j, n, q_j, k
and named formal parameters q1k.
m', X'_j
Let m' be a method signature with formal type parameters
X'1s,
positional formal parameters p'1n',
p'_j, n', q'_j, k'
and named formal parameters q'1k'.

Assume that j ‚àà 1 .. n', and j ‚â§ n;
we say that p'_j is the parameter in m' that
correspondsparameter corresponds to parameter
to the formal parameter p_j in m.
Assume that j ‚àà 1 .. k' and l ‚àà 1 .. k;
we say that q'_j is the parameter in m' that
corresponds to the formal parameter
q_l in m if q'_j = q_l.

Similarly, we say that the formal type parameter
X'_j from m'
corresponds to the formal type parameter
X_j from m, for all j ‚àà 1 .. s.


This includes the case where m respectively m' has
optional positional parameters,
in which case k = 0 respectively k' = 0 must hold,
but we can have n ‚â† n'.
The case where the numbers of formal type parameters differ is not relevant.













C, m, p
Let C be a class that declares
a method m which has
a parameter p whose declaration has the modifier ;
in this case we say that the parameter p is
covariant-by-declarationparameter!covariant-by-declaration.

In this case the interface of C has the method signature m,
and that signature has the parameter p;
we also say that the parameter p in this method signature is
covariant-by-declaration.

Finally, the parameter p of the method signature m
of the interface of a class C is
covariant-by-declaration
if a direct superinterface of C
has an accessible method signature m' with the same name as m,
which has a parameter p' that corresponds to p,
such that p' is covariant-by-declaration.


Assume that C, X_j, B_j, sC is a generic class
with formal type parameter declarations
X_1  B_1 ‚Ä¶, X_s  B_s,
m, p, T
let m be a declaration of an instance method in C
(which can be a method, a setter, or an operator),
let p be a parameter declared by m, and
let T be the declared type of p.

The parameter p is
covariant-by-classparameter!covariant-by-class
if, for any j ‚àà 1 .. s,
X_j occurs in a covariant or an invariant position in T.

In this case the interface of C also has the method signature m,
and that signature has the parameter p;
we also say that the parameter p in this method signature is
covariant-by-class.
Finally, the parameter p of the method signature m
of the interface of the class C is
covariant-by-class
if a direct superinterface of C
has an accessible method signature m' with the same name as m,
which has a parameter p' that corresponds to p,
such that p' is covariant-by-class.


A formal parameter p is
covariantparameter!covariant
if p is covariant-by-declaration or p is covariant-by-class.


It is possible for a parameter to be simultaneously
covariant-by-declaration and covariant-by-class.
Note that a parameter may be
covariant-by-declaration or covariant-by-class
based on a declaration in any direct or indirect superinterface,
including any superclass:
The definitions above propagate these properties
to an interface from each of its direct superinterfaces,
but they will in turn receive the property from their direct superinterfaces,
and so on.





 ¬ß.¬ß Type of a Function

typeOfAFunction


This section specifies the static type which is ascribed to
the function denoted by a function declaration,
and the dynamic type of the corresponding function object.


In this specification,
the notation used to denote the type of a function,
that is, a function type,
follows the syntax of the language,
except that  is abbreviated to
.
This means that every function type is of one of the forms
T_0
T_0

where T_0 is the return type,
X_j are the formal type parameters with bounds B_j, j ‚àà 1 .. s,
T_j are the formal parameter types for j ‚àà 1 .. n + k,
and x_n+j are the names of named parameters for j ‚àà 1 .. k.
Non-generic function types are covered by the case s = 0,
where the type parameter declaration list
<‚Ä¶>
as a whole is omitted.

Similarly, the optional brackets [] and {} are omitted
when there are no optional parameters.



Both forms with optionals cover function types with no optionals when k = 0,
and every rule in this specification is such that
any of the two forms may be used without ambiguity
to determine the treatment of function types with no optionals.



If a function declaration does not declare a return type explicitly,
its return type is  (<ref>),
unless it is a constructor,
in which case it is not considered to have a return type,
or it is a setter or operator []=,
in which case its return type is .


A function declaration may declare formal type parameters.
The type of the function includes the names of the type parameters
and for each type parameter the upper bound,
which is considered to be the built-in class Object
if no bound is specified.
When consistent renaming of type parameters
can make two function types identical,
they are considered to be the same type.


It is convenient to include the formal type parameter names in function types
because they are needed in order to express such things as relations among
different type parameters, F-bounds, and the types of formal parameters.
However, we do not wish to distinguish between two function types if they have
the same structure and only differ in the choice of names.
This treatment of names is also known as alpha-equivalence.



In the following three paragraphs,
if the number s of formal type parameters is zero then
the type parameter list in the function type is omitted.


Let F be a function with
type parameters ,
required formal parameter types T1n,
return type T_0,
and no optional parameters.
Then the static type of F is
T_0.


Let F be a function with
type parameters ,
required formal parameter types T1n,
return type T_0
and positional optional parameter types Tn+1n+k.
Then the static type of F is
T_0.


Let F be a function with
type parameters ,
required formal parameter types T1n,
return type T_0,
and named parameters Txn+1n+k,
where x_n+j, j ‚àà 1 .. k may or may not have a default value.
Then the static type of F is
T_0.


Let T be the static type of a function declaration F.
Let u be the run-time type of a function object o obtained by
function closurization
(<ref>)
or instance method closurization
(<ref>)
applied to F,
and let t be the actual type corresponding to T
at the occasion where o was created
(<ref>).

T may contain free type variables, but t contains their actual values.

The following must then hold:
u is a class that implements the built-in class ;
u is a subtype of t;
and u is not a subtype of any function type which is a proper subtype of t.

If we had omitted the last requirement then
f  int ([int])
could evaluate to  with the declaration
 f() {},
which is obviously not the intention.



It is up to the implementation to choose
an appropriate representation for function objects.
For example, consider that
a function object produced via property extraction
treats equality differently from other function objects,
and is therefore likely a different class.
Implementations may also use different classes for function objects
based on arity and or type.
Arity may be implicitly affected by whether a function is
an instance method (with an implicit receiver parameter) or not.
The variations are manifold and, e.g.,
one cannot assume that any two distinct function objects
will necessarily have the same run-time type.





 ¬ß.¬ß External Functions

externalFunctions


An external functionfunction!external
is a function whose body is provided separately from its declaration.
An external function may be
a top-level function (<ref>),
a method (<ref>, <ref>),
a getter (<ref>),
a setter (<ref>),
or a non-redirecting constructor
(<ref>, <ref>).
External functions are introduced via the built-in identifier 
(<ref>)
followed by the function signature.


External functions allow us to introduce type information for code
that is not statically known to the Dart compiler.



Examples of external functions might be foreign functions
(defined in C, or Javascript etc.),
primitives of the implementation (as defined by the Dart run-time system),
or code that was dynamically generated but whose interface is statically known.
However, an abstract method is different from an external function,
as it has no body.



An external function is connected to its body by
an implementation specific mechanism.
Attempting to invoke an external function
that has not been connected to its body
will throw a NoSuchMethodError or some subclass thereof.


An implementation specific compile-time error can be raised
at an  function declaration.


Such errors are intended to indicate that
every invocation of that function would throw, e.g.,
because it is known that it will not be connected to a body.



The actual syntax is given in
sections <ref> and <ref> below.




¬ß CLASSES

classes


A class defines the form and behavior of a set of objects which are its
instancesinstance.
Classes may be defined by class declarations as described below,
or via mixin applications (<ref>).


<classDeclaration> ::=
  ?  <typeIdentifier> <typeParameters>?
   <superclass>? <interfaces>?
   `' (<metadata> <classMemberDeclaration>)* `'
  ?  <mixinApplicationClass>

<typeNotVoidList> ::= <typeNotVoid> (`,' <typeNotVoid>)*

<classMemberDeclaration> ::= <declaration> `;'
  <methodSignature> <functionBody>

<methodSignature> ::= <constructorSignature> <initializers>?
  <factoryConstructorSignature>
  ? <functionSignature>
  ? <getterSignature>
  ? <setterSignature>
  <operatorSignature>

<declaration> ::=  <factoryConstructorSignature>
   <constantConstructorSignature>
   <constructorSignature>
  ( ?)? <getterSignature>
  ( ?)? <setterSignature>
  ( ?)? <functionSignature>
  ? <operatorSignature>
    <type>? <staticFinalDeclarationList>
    <type>? <staticFinalDeclarationList>
     <type>? <initializedIdentifierList>
   ? <varOrType> <initializedIdentifierList>
     <type>? <identifierList>
   ? <varOrType> <initializedIdentifierList>
  ?  <type>? <initializedIdentifierList>
  ? <varOrType> <initializedIdentifierList>
  <redirectingFactoryConstructorSignature>
  <constantConstructorSignature> (<redirection> | <initializers>)?
  <constructorSignature> (<redirection> | <initializers>)?

<staticFinalDeclarationList> ::= 
  <staticFinalDeclaration> (`,' <staticFinalDeclaration>)*

<staticFinalDeclaration> ::= <identifier> `=' <expression>



It is possible to include the modifier 
in some forms of declarations.
The effect of doing this is described elsewhere
(<ref>).


A class has constructors, instance members and static members.
The instance membersmembers!instance of a class
are its instance methods, getters, setters and instance variables.
The static membersmembers!static of a class
are its static methods, getters, setters, and variables.
The membersmembers of a class
are its static and instance members.


A class declaration introduces two scopes:


  * A type-parameter scopescope!type parameter,
  which is empty if the class is not generic (<ref>).
  The enclosing scope of the type-parameter scope of a class declaration is
  the library scope of the current library.

  * A body scopescope!class body.
  The enclosing scope of the body scope of a class declaration is
  the type parameter scope of the class declaration.



The current scope of an instance member declaration,
a static member declaration,
or a constructor declaration is
the body scope of the class in which it is declared.


The current instance
(and hence its members)
can only be accessed at specific locations in a class:
We say that a location ‚Ñì
has access to has access to this@has access to 
iff ‚Ñì is inside the body of a declaration of
an instance member or a generative constructor,
or in the initializing expression of a  instance variable declaration.


Note that an initializing expression for a non- instance variable
does not have access to ,
and neither does any part of a declaration marked .



Every class has a single superclass
except class Object which has no superclass.
A class may implement a number of interfaces
by declaring them in its implements clause (<ref>).


An abstract class declarationclass declaration!abstract
is a class declaration that is explicitly declared
with the  modifier.
A concrete class declarationclass declaration!concrete
is a class declaration that is not abstract.
An abstract classclass!abstract is a class
whose declaration is abstract, and
a concrete classclass!concrete is a class
whose declaration is concrete.


We want different behavior for concrete classes and abstract classes.
If A is intended to be abstract,
we want the static checker to warn about any attempt to instantiate A,
and we do not want the checker to complain about unimplemented methods in A.
In contrast, if A is intended to be concrete,
the checker should warn about all unimplemented methods,
but allow clients to instantiate it freely.



The interface of a class C is
an implicit interface that declares instance member signatures
that correspond to the instance members declared by C,
and whose direct superinterfaces are
the direct superinterfaces of C
(<ref>, <ref>).



When a class name appears as a type,
that name denotes the interface of the class.


It is a compile-time error if a class named C declares
a member with basename (<ref>) C.
If a generic class named G declares a type variable named X,
it is a compile-time error
if X is equal to G,
or if G has a member whose basename is X,
or if G has a constructor named G.X.


Here are simple examples, that illustrate the difference between
‚Äúhas a member‚Äù and ‚Äúdeclares a member‚Äù.
For example, B declaresdeclares member
one member named f,
but it hashas member two such members.
The rules of inheritance determine what members a class has.



 A {
   i = 0;
   j;
  f(x) => 3;
}


 B  A {
  int i = 1; // getter i and setter i= override versions from A
   j; // compile-time error: static getter & setter conflict
  // with instance getter & setter


  // compile-time error: static method conflicts with instance method
   f(x) => 3;
}





 ¬ß.¬ß Fully Implementing an Interface

fullyImplementingAnInterface











A concrete class must fully implement its interface.
C, I, m
Let C be a concrete class declared in library L, with interface I.
Assume that I has a member signature m which is accessible to L.
It is a compile-time error if C does not have
a concrete member with the same name as m and accessible to L,
unless C has a non-trivial noSuchMethod
(<ref>).


Each concrete member must have a suitable signature:
Assume that C has a concrete member with
the same name as m and accessible to L,
and let m‚Äù be its member signature.

The concrete member may be declared in C or inherited from a superclass.

Let m' be the member signature which is obtained from m‚Äù
by adding, if not present already, the modifier 
(<ref>)
to each parameter p in m‚Äù where
the corresponding parameter in m has the modifier .
It is a compile-time error if m' is not a correct override of m
(<ref>),
unless that concrete member is a noSuchMethod forwarder
(<ref>).


Consider a concrete class C,
and assume that C declares or inherits
a member implementation with the same name
for every member signature in its interface.
It is still an error if one or more of those member implementations
has parameters or types such that they do not satisfy
the corresponding member signature in the interface.
For this check, any missing  modifiers are implicitly added
to the signature of an inherited member (this is how we get m' from m‚Äù).
When the modifier  is added to one or more parameters
(which will only happen when the concrete member is inherited),
an implementation may choose to implicitly induce a forwarding method
with the same signature as m',
in order to perform the required dynamic type check,
and then invoke the inherited method.



It is an implementation specific choice whether or not
an implicitly induced forwarding method is used
when the modifier  is added to
one or more parameters in m'.


This is true in spite of the fact that such forwarding methods can be observed.
E.g., we can compare
the run-time type of a tearoff of the method from
a receiver of type C
to the run-time type of a tearoff of the super-method from
a location in the body of C.



With or without a forwarding method,
the member signature in the interface of C is m.


The forwarding method does not change the interface of C,
it is an implementation detail.
In particular, this holds even in the case where
an explicit declaration of the forwarding method would have
changed the interface of C, because m' is a subtype of m.

When a class has a non-trivial noSuchMethod,
the class may leave some members unimplemented,
and the class is allowed to have a noSuchMethod forwarder
which does not satisfy the class interface
(in which case it will be overridden by another noSuchMethod forwarder).

Here is an example:



 B {
   m(int i) {} // Signature m‚Äù:  m(int).
}


  I {
   m( num n); // Signature:  m( num).
}


 C  B  I {
  // Signature m:  m( num).
  //
  // To check that this class fully implements its interface,
  // check that m', that is,  m( int),
  // correctly overrides m: OK!
}



Parameters that are covariant-by-declaration
must also satisfy the following constraint:
Assume that the parameter p of m' has the modifier .
Assume that a direct or indirect superinterface of C has
a method signature m_s with the same name as m' and accessible to L,
such that m_s has a parameter p_s that corresponds to p.
In this situation, a compile-time error occurs
if the type of p is not a subtype and not a supertype of the type of p_s.


This ensures that an inherited method satisfies the same constraint
for each formal parameter which is covariant-by-declaration
as the constraint which is specified for a declaration in C
(<ref>).





 ¬ß.¬ß Instance Methods

instanceMethods


Instance methodsmethod!instance
are functions (<ref>)
whose declarations are immediately contained within a class declaration
and that are not declared .
The instance methods of a class C are
the instance methods declared by C
and the instance methods inherited by C from its superclass
(<ref>).


C, D, m
Consider a class C
and an instance member declaration D in C, with member signature m
(<ref>).
It is a compile-time error if D overrides a declaration

with member signature m'
from a direct superinterface of C
(<ref>),
unless m is a correct member override of m'
(<ref>).


This is not the only kind of conflict that may exist:
An instance member declaration D may conflict with another declaration D',
even in the case where they do not have the same name
or they are not the same kind of declaration.
E.g., D could be an instance getter and D' a static setter
(<ref>).



For each parameter p of m where  is present,
it is a compile-time error if there exists
a direct or indirect superinterface of C which has
an accessible method signature m‚Äù with the same name as m,
such that m‚Äù has a parameter p‚Äù that corresponds to p
(<ref>),
unless the type of p is a subtype or a supertype of the type of p‚Äù.


This means that
a parameter which is covariant-by-declaration can have a type
which is a supertype or a subtype of the type of
a corresponding parameter in a superinterface,
but the two types cannot be unrelated.
Note that this requirement must be satisfied
for each direct or indirect superinterface separately,
because that relationship is not transitive.



The superinterface may be the statically known type of the receiver,
so this means that we relax the potential typing relationship
between the statically known type of a parameter and the
type which is actually required at run time
to the subtype-or-supertype relationship,
rather than the strict supertype relationship
which applies to a parameter which is not covariant.
It should be noted that it is not statically known
at the call site whether any given parameter is covariant,
because the covariance could be introduced in
a proper subtype of the statically known type of the receiver.
We chose to give priority to flexibility rather than safety here,
because the whole point of covariant parameters is that developers
can make the choice to increase the flexibility
in a trade-off where some static type safety is lost.





  ¬ß.¬ß.¬ß Operators

operators


Operatorsoperators are instance methods with special names,
except for operator [] which is an instance getter
and operator []= which is an instance setter.


<operatorSignature> ::= 
  <type>?  <operator> <formalParameterList>

<operator> ::= `¬†'
  <binaryOperator>
  `[]'
  `[]='

<binaryOperator> ::= <multiplicativeOperator>
  <additiveOperator>
  <shiftOperator>
  <relationalOperator>
  `=='
  <bitwiseOperator>



An operator declaration is identified using the built-in identifier
(<ref>)
.


The following names are allowed for user-defined operators:
<,
>,
<=,
>=,
==,
-,
+,
/,
/,
*,
%,
|,
,
&,
,
,
,
[]=,
[],
.


It is a compile-time error if the arity of the user-declared operator
[]= is not 2.
It is a compile-time error if the arity of a user-declared operator
with one of the names:
<,
>,
<=,
>=,
==,
-,
+,
/,
/,
*,
%,
|,
,
&,
,
,
,
[]
is not 1.
It is a compile-time error if the arity of the user-declared operator
-
is not 0 or 1.


The - operator is unique
in that two overloaded versions are permitted.
If the operator has no arguments, it denotes unary minus.
If it has an argument, it denotes binary subtraction.



The name of the unary operator - is unary-.


This device allows the two methods to be distinguished
for purposes of method lookup, override and reflection.



It is a compile-time error if the arity of the user-declared operator

is not 0.


It is a compile-time error to declare an optional parameter in an operator.


It is a compile-time error if a user-declared operator []=
declares a return type other than .


If no return type is specified for a user-declared operator
[]=,
its return type is  (<ref>).



The return type is  because
a return statement in an implementation of operator
[]=
does not return an object.
Consider a non-throwing evaluation of an expression e of the form
e_1[e_2] = e_3,
and assume that the evaluation of e_3 yields an object o.
e will then evaluate to o,
and even if the executed body of operator
[]=
completes with an object o',
that is, if o' is returned it is simply ignored.
The rationale for this behavior is that
assignments should be guaranteed to evaluate to the assigned object.





  ¬ß.¬ß.¬ß The Method noSuchMethod

theMethodNoSuchMethod


The method noSuchMethod is invoked implicitly during execution
in situations where one or more member lookups fail
(<ref>,
<ref>,
<ref>).


We may think of noSuchMethod as a backup
which kicks in when an invocation of a member m is attempted,
but there is no member named m,
or it exists,
but the given invocation has an argument list shape
that does not fit the declaration of m
(passing fewer positional arguments than required or more than supported,
or passing named arguments with names not declared by m).




This can only occur for an ordinary method invocation
when the receiver has static type ,
or for a function invocation when
the invoked function has static type  or .

The method noSuchMethod can also be invoked in other ways, e.g.,
it can be called explicitly like any other method,
and it can be invoked from a noSuchMethod forwarder,
as explained below.



We say that a class C has a non-trivial noSuchMethod
if C has a concrete member named noSuchMethod
which is distinct from the one declared in the built-in class Object.


Note that it must be a method that accepts one positional argument,
in order to correctly override noSuchMethod in Object.
For instance, it can have signature
noSuchMethod(Invocation i) or
noSuchMethod(Object i, [String s = ‚Äù]),
but not
noSuchMethod(Invocation i, String s).
This implies that the situation where noSuchMethod is invoked
(explicitly or implicitly)
with one actual argument cannot fail for the reason that
‚Äúthere is no such method‚Äù,
such that we would enter an infinite loop trying to invoke noSuchMethod.
It is possible, however, to encounter a dynamic error
during an invocation of noSuchMethod
because the actual argument fails to satisfy a type check,
but that situation will give rise to a dynamic type error
rather than a repeated attempt to invoke noSuchMethod
(<ref>).
Here is an example where a dynamic type error occurs because
an attempt is made to pass an Invocation
where only the null object is accepted:



 A {
  noSuchMethod( Null n) => n;
}


 main() {
   d = A();
  d.foo(42); // Dynamic type error when invoking noSuchMethod.
}



C, L, m
Let C be a concrete class,
let L be the library that contains the declaration of C,
and let m be a name.
Then m is noSuchMethod forwarded in C iff
one of the following is true:



  * Requested in program:
  C has a non-trivial noSuchMethod,
  the interface of C contains a member signature S named m,
  and C has no concrete member named m and accessible to L
  that correctly overrides S
  (
    that is, no member named m is declared or inherited by C,
    or one is inherited, but it does not have the required signature
  ).
  In this case we also say that S is noSuchMethod forwarded.

  * Forced by privacy:
  There exists a direct or indirect superinterface
  D of C which is declared in a library L_2 different from L,
  the interface of D contains a member signature S named m,
  m is a private name,
  and no superclass of C has
  a concrete member named m accessible to L_2
  that correctly overrides S.
  In this case we also say that S is noSuchMethod forwarded.



For a concrete class C, a
noSuchMethod forwarder
is implicitly induced for each member signature
which is noSuchMethod forwarded.


It is a compile-time error if the name m is noSuchMethod forwarded
in a concrete class C,
and a superclass of C has an accessible concrete declaration of m
which is not a noSuchMethod forwarder.





A noSuchMethod forwarder is a concrete member of C
with the signature taken from the interface of C,
and with the same default value for each optional parameter.
It can be invoked in an ordinary invocation and in a superinvocation,
and when m is a method it can be closurized
(<ref>)
using a property extraction
(<ref>).


The error concerned with an implictly induced forwarder
that would override a human-written declaration
can only occur if that concrete declaration does not
correctly override S. Consider the following example:



 A {
  foo(int i) => ;
}

  B {
  foo([int i]);
}

 C  A  B {
  noSuchMethod(Invocation i) => ...;
  // Error: noSuchMethod forwarder cannot override `A.foo`.
}



In this example,
an implementation with signature foo(int i) is inherited by C,
and the superinterface B declares
the signature foo([int i]).
This is a compile-time error because C does not have
a method implementation with signature foo([int]).
We do not wish to implicitly induce
a noSuchMethod forwarder with signature foo([int])
because it would override A.foo,
and that is likely to be highly confusing for developers.

In particular, it would cause an invocation like C().foo(42)
to invoke noSuchMethod,
even though that is an invocation which is correct for
the declaration of foo in A.

Hence, we require developers to explicitly resolve the conflict
whenever an implicitly induced noSuchMethod forwarder
would override an explicitly declared inherited implementation.

It is no problem, however,
to let a noSuchMethod forwarder override
another noSuchMethod forwarder,
and hence there is no error in that situation.



This implies that a noSuchMethod forwarder has the same
properties as an explicitly declared concrete member,
except of course that a noSuchMethod forwarder
does not prevent itself or another noSuchMethod forwarder from being induced.
We do not specify the body of a noSuchMethod forwarder,
but it will invoke noSuchMethod,
and we specify the dynamic semantics of executing it below.



At the beginning of this section we mentioned that implicit invocations
of noSuchMethod can only occur
with a receiver of static type 
or a function of static type  or .
With a noSuchMethod forwarder,
noSuchMethod can also be invoked
on a receiver whose static type is not .
No similar situation exists for functions,
because it is impossible to induce a noSuchMethod forwarder
into the class of a function object.



For a concrete class C,
we may think of a non-trivial noSuchMethod
(declared in or inherited by C)
as a request for ‚Äúautomatic implementation‚Äù of all unimplemented members
in the interface of C as noSuchMethod forwarders.
Similarly, there is an implicit request for
automatic implementation of all unimplemented
inaccessible members of any concrete class,
whether or not there is a non-trivial noSuchMethod.
Note that the latter cannot be written explicitly in Dart,
because their names are inaccessible;
but the language can still specify that they are induced implicitly,
because compilers control the treatment of private names.



C, m, X_j, r
For the dynamic semantics,
assume that a class C has an implicitly induced
noSuchMethod forwarder named m,
with formal type parameters
X_1, ‚Ä¶, X_r,
positional formal parameters
a_j, k, x_j, n
a_1, ‚Ä¶, a_k
(some of which may be optional when n = 0),
and named formal parameters with names
x_1, ‚Ä¶, x_n
(with default values as mentioned above).


For this purpose we need not distinguish between
a signature that has optional positional parameters and
a signature that has named parameters,
because the former is covered by n = 0.



The execution of the body of m creates
an instance im of the predefined class Invocation
such that:



  * im.isMethod evaluates to  iff m is a method.

  * im.isGetter evaluates to  iff m is a getter.

  * im.isSetter evaluates to  iff m is a setter.

  * im.memberName evaluates to the symbol m.

  * im.positionalArguments evaluates to an unmodifiable list
  whose dynamic type implements List<Object>,
  containing the same objects as the list resulting from evaluation of
  <Object>[a_1, ‚Ä¶, a_k].

  * im.namedArguments evaluates to an unmodifiable map
  whose dynamic type implements Map<Symbol, Object>,
  with the same keys and values as the map resulting from evaluation of

  <Symbol, Object>{#x_1: x_1, ‚Ä¶, #x_m: x_m}.

  * im.typeArguments evaluates to an unmodifiable list
  whose dynamic type implements List<Type>,
  containing the same objects as the list resulting from evaluation of
  <Type>[X_1, ‚Ä¶, X_r].



Next, noSuchMethod is invoked with im as the actual argument,
and the result obtained from there is returned by the execution of m.


This is an ordinary method invocation of noSuchMethod
(<ref>).
That is, a noSuchMethod forwarder in a class C can invoke
an implementation of noSuchMethod that is declared in
a subclass of C.

Dynamic type checks on the actual arguments passed to m
are performed in the same way as for an invocation of an
explicitly declared method.
In particular, an actual argument passed to a covariant parameter
will be checked dynamically.

Also, like other ordinary method invocations,
it is a dynamic type error if the result returned by
a noSuchMethod forwarder has a type which is not a subtype
of the return type of the forwarder.

One special case to be aware of is where a forwarder is torn off
and then invoked with an actual argument list which does not match
the formal parameter list.
In that situation we will get an invocation of
Object.noSuchMethod
rather than the noSuchMethod in the original receiver,
because this is an invocation of a function object
(and they do not override noSuchMethod):



 A {
  noSuchMethod(Invocation i) => ;
   foo();
}


 main() {
  A a = A();
   f = a.foo;
  // Invokes `Object.noSuchMethod`, which throws.
  f(42);
}





  ¬ß.¬ß.¬ß The Operator `==' and Primitive Equality

theOperatorEqualsEquals


The operator == is used implicitly in certain situations,
and in particular constant expressions
(<ref>)
give rise to constraints on that operator.
The situation is similar with the getter hashCode.
In order to specify these constraints just once we introduce the notion of
primitive equality.


Certain constant expressions are known to have a value
whose equality is primitive.
This is useful to know because it allows
the value of equality expressions
and the value of invocations of hashCode
to be computed at compile-time.
In particular, this can be used to build
constant collections at compile-time,
and it can be used to check that
all elements in a constant set are distinct,
and all keys in a constant map are distinct.




  * The null object has primitive equality
  (<ref>).

  * Every instance of type bool, int, and String
  has primitive equality.

  * Every instance of type Symbol
  which was originally obtained by evaluation of a literal symbol or
  a constant invocation of a constructor of the Symbol class
  has primitive equality.

  * 
  
  Every instance of type Type
  which was originally obtained by evaluating a constant type literal
  (<ref>)
  has primitive equality.

  * Let o be an object obtained by evaluation of a constant list literal
  (<ref>),
  a constant map literal
  (<ref>), or
  a constant set literal
  (<ref>),
  then o has primitive equality.

  * 
  A function object obtained by function closurization of
  a static method or a top-level function
  (<ref>)
  as the value of a constant expression
  has primitive equality.

  * An instance o has primitive equality
  if the dynamic type of o is a class C,
  and C has primitive equality.

  * The class Object has primitive equality.

  * A class C has primitive equality
  if it does not have an implementation of the operator ==
  that overrides the one inherited from Object,
  and it does not have an implementation of the getter hashCode
  that overrides the one inherited from Object.



When we say that a given instance or class
does not have primitive equality
  primitive equality!does not have,
it means that it is not true that said instance or class
has primitive equality.




 ¬ß.¬ß Getters

getters


Getters are functions (<ref>) that are used
to retrieve the values of object properties.


<getterSignature> ::= <type>?  <identifier>



If no return type is specified, the return type of the getter is .


A getter definition that is prefixed with the  modifier defines
a static getter.
Otherwise, it defines an instance getter.
The name of the getter is given by the identifier in the definition.


The instance getters of a class C are
those instance getters declared by C,
either implicitly or explicitly,
and the instance getters inherited by C from its superclass.
The static getters of a class C are
those static getters declared by C.


A getter declaration may conflict with other declarations
(<ref>).
In particular, a getter can never override a method,
and a method can never override a getter or an instance variable.
The rules for when a getter correctly overrides another member
are given elsewhere
(<ref>).





 ¬ß.¬ß Setters

setters


Setters are functions (<ref>) that are used to set
the values of object properties.


<setterSignature> ::= <type>?  <identifier> <formalParameterList>



If no return type is specified, the return type of the setter is 
(<ref>).



A setter definition that is prefixed with the  modifier defines
a static setter.
Otherwise, it defines an instance setter.
The name of a setter is obtained by appending the string `=' to
the identifier given in its signature.


Hence, a setter name can never conflict with, override or be overridden by
a getter or method.



The instance setters of a class C are
those instance setters declared by C
either implicitly or explicitly,
and the instance setters inherited by C from its superclass.
The static setters of a class C are
those static setters declared by C,
either implicitly or explicitly.


It is a compile-time error if a setter's formal parameter list
does not consist of exactly one required formal parameter p.

We could enforce this via the grammar,
but we'd have to specify the evaluation rules in that case.



It is a compile-time error if a setter declares a return type other than .
It is a compile-time error if a class has
a setter named v= with argument type T and
a getter named v with return type S,
and S may not be assigned to T.


The rules for when a setter correctly overrides another member
are given elsewhere
(<ref>).
A setter declaration may conflict with other declarations as well
(<ref>).





 ¬ß.¬ß Abstract Instance Members

abstractInstanceMembers


An abstract methodmethod!abstract
(respectively,
abstract gettergetter!abstract or
abstract settersetter!abstract)
is an instance method, getter or setter that is not declared 
and does not provide an implementation.
A concrete methodmethod!concrete
(respectively,
concrete gettergetter!concrete or
concrete settersetter!concrete)
is an instance method, getter or setter that is not abstract.


Abstract instance members are useful because of their interplay with classes.
Every Dart class induces an implicit interface,
and Dart does not support specifying interfaces explicitly.
Using an abstract class instead of a traditional interface
has important advantages.
An abstract class can provide default implementations.
It can also provide static methods,
obviating the need for service classes
such as Collections or Lists,
whose entire purpose is to group utilities related to a given type.



Invocation of an abstract method, getter, or setter cannot occur,
because lookup (<ref>) will never yield an abstract member as its result.
One way to think about this is that
an abstract member declaration in a subclass
does not override or shadow an inherited member implementation.
It only serves to specify the signature of the given member that
every concrete subtype must have an implementation of;
that is, it contributes to the interface of the class,
not to the class itself.



The purpose of an abstract method is to provide a declaration
for purposes such as type checking and reflection.
In mixins, it is often useful to introduce such declarations for methods that
the mixin expects will be provided by the superclass the mixin is applied to.



We wish to detect if one declares a concrete class with abstract members.
However, code like the following should work:



class Base {
  int get one => 1;
}


  Mix {
  int get one;
  int get two => one + one;
}


 C extends Base with Mix { }



At run time, the concrete method one declared in Base
will be executed,
and no problem should arise.
Therefore no error should be raised
if a corresponding concrete member exists in the hierarchy.





 ¬ß.¬ß Instance Variables

instanceVariables


Instance variablesvariables!instance
are variables whose declarations
are immediately contained within a class declaration
and that are not declared .
The instance variables of a class C are
the instance variables declared by C
and the instance variables inherited by C from its superclass.


It is a compile-time error if an instance variable is declared to be constant.


The notion of a constant instance variable
is subtle and confusing to programmers.
An instance variable is intended to vary per instance.
A constant instance variable would have the same value for all instances,
and as such is already a dubious idea.

The language could interpret const instance variable declarations as
instance getters that return a constant.
However, a constant instance variable could not be treated as
a true compile-time constant,
as its getter would be subject to overriding.

Given that the value does not depend on the instance,
it is better to use a static variable.
An instance getter for it can always be defined manually if desired.



It is possible for the declaration of an instance variable
to include the modifier 
(<ref>).
The effect of this is that the formal parameter of
the corresponding implicitly induced setter
is considered to be covariant-by-declaration
(<ref>).


The modifier  on an instance variable has no other effects.
In particular, the return type of the implicitly induced getter
can already be overridden covariantly without ,
and it can never be overridden to a supertype or an unrelated type,
regardless of whether the modifier  is present.





 ¬ß.¬ß Constructors

constructors


A constructor is a special function that is used
in instance creation expressions (<ref>) to obtain objects,
typically by creating or initializing them.
Constructors may be generative (<ref>)
or they may be factories (<ref>).


A constructor name always begins with
the name of its immediately enclosing class,
and may optionally be followed by a dot and an identifier ùïÄ.
It is a compile-time error if the name of a constructor
is not a constructor name.


The
function type of a constructorfunction type!of a constructor
k is the function type
whose return type is the class that contains the declaration of k,
and whose formal parameter types, optionality, and names of named parameters
correspond to the declaration of k.


Note that the function type F of a constructor k may contain
type variables declared by the enclosing class C.
In that case we can apply a substitution to F, as in
[T_1/X_1, ‚Ä¶, T_m/X_m]F,
where X_j, j ‚àà 1 .. m are the formal type parameters of C
and T_j, j ‚àà 1 .. m are specified in the given context.
We may also omit such a substitution when the given context is
the body scope of C, where X_1, ‚Ä¶, X_m are in scope.



A constructor declaration may conflict with static member declarations
(<ref>).



A constructor declaration does not introduce a name into a scope.
If a function expression invocation
(<ref>)
or an instance creation
(<ref>)
denotes a constructor as
C, prefix.C, C.ùïÄ, or prefix.C.ùïÄ,
resolution relies on the library scope to determine the class
(possibly via an import prefix).
The class declaration is then directly checked for
whether it has a constructor named C respectively C.ùïÄ.
It is not possible for an identifier to directly refer to a constructor,
since the constructor is not in any scope used for resolving identifiers.



Iff no constructor is specified for a class C,
it implicitly has a default constructor C(): () {},
unless C is the built-in class Object.





  ¬ß.¬ß.¬ß Generative Constructors

generativeConstructors


A generative constructorconstructor!generative
declaration consists of a constructor name, a formal parameter list
(<ref>),
and either a redirect clause or an initializer list and an optional body.


<constructorSignature> ::= <constructorName> <formalParameterList>

<constructorName> ::= <typeIdentifier> (`.' <identifier>)?



See declaration and methodSignature for grammar rules
introducing a redirection or an initializer list and a body.




A compile-time error occurs if a generative constructor declaration
has a body of the form `=>  e;'.


In other function declarations,
this kind of body is taken to imply that the value of e is returned,
but generative constructors do not return anything.



If a formal parameter declaration p is derived from
fieldFormalParameter,
it declares an initializing formal parameter.
A term of the form .ùïÄ is contained in p,
and ùïÄ is the name of p.
It is a compile-time error if ùïÄ is not also the name of
an instance variable of the immediately enclosing class or enum.


It is a compile-time error for an initializing formal parameter
to occur in any function which is not a generative constructor.
Also, it is a compile-time error for an initializing formal parameter
to occur in a redirecting or external constructor.
In particuar, there is always an enclosing class or enum.


Assume that p is a declaration of an initializing formal parameter named ùïÄ.
Let T_id be the type of the instance variable named ùïÄ in
the immediately enclosing class or enum.
If p has a type annotation T then the declared type of p is T.
Otherwise, the declared type of p is T_id.
It is a compile-time error if the declared type of p
is not a subtype of T_id.


Initializing formals constitute an exception to the rule that
every formal parameter introduces a local variable into
the formal parameter scope (<ref>).
When the formal parameter list of a non-redirecting generative constructor
contains any initializing formals, a new scope is introduced, the
formal parameter initializer scope
  scope!formal parameter initializer,
which is the current scope of the initializer list of the constructor,
and which is enclosed in the scope where the constructor is declared.
Each initializing formal in the formal parameter list
introduces a final local variable into the formal parameter initializer scope,
but not into the formal parameter scope;
every other formal parameter introduces a local variable into
both the formal parameter scope and the formal parameter initializer scope.


This means that formal parameters, including initializing formals,
must have distinct names, and that initializing formals
are in scope for the initializer list,
but they are not in scope for the body of the constructor.
When a formal parameter introduces a local variable into two scopes,
it is still one variable and hence one storage location.
The type of the constructor is defined in terms of its formal parameters,
including the initializing formals.



Initializing formals are executed during
the execution of generative constructors detailed below.
Executing an initializing formal .ùïÄ
causes the instance variable ùïÄ of the immediately surrounding class
to be assigned the value of the corresponding actual parameter,

unless the assigned object has a dynamic type
which is not a subtype of the declared type of the instance variable ùïÄ,
in which case a dynamic error occurs.


The above rule allows initializing formals to be used as optional parameters:



class A {
  int x;
  A([this.x]);
}



is legal, and has the same effect as



class A {
  int x;
  A([int x]): this.x = x;
}



A fresh instance is an instance whose identity is distinct from
any previously allocated instance of its class.
A generative constructor always operates on a fresh instance of
its immediately enclosing class.


The above holds if the constructor is actually run, as it is by .
If a constructor c is referenced by , c may not be run;
instead, a canonical object may be looked up.
See the section on instance creation (<ref>).



If a generative constructor c is not a redirecting constructor
and no body is provided, then c implicitly has an empty body {}.




  
Redirecting Generative Constructors
redirectingGenerativeConstructors


A generative constructor may be
redirectingconstructor!redirecting,
in which case its only action is to invoke another generative constructor.
A redirecting constructor has no body;
instead, it has a redirect clause that specifies
which constructor the invocation is redirected to,
and with which arguments.


<redirection> ::= `:'  (`.' <identifier>)? <arguments>





C, X_j, B_j, m
Assume that
C<X_1  B_1 ‚Ä¶, X_m  B_m>
is the name and formal type parameters of the enclosing class,

 stands for either  or nothing,
N is C or C.ùïÄ_0 for some identifier ùïÄ_0,
N, ùïÄ
and ùïÄ is an identifier.
Consider a declaration of a redirecting generative constructor
of one of the forms

 N(T_1 x_1 ‚Ä¶, T_n x_n,[T_n+1 x_n+1 = d_1 ‚Ä¶, T_n+k x_n+k = d_k]): R;

 N(T_1 x_1 ‚Ä¶, T_n x_n,{T_n+1 x_n+1 = d_1 ‚Ä¶, T_n+k x_n+k = d_k}): R;

where R is of one of the forms

(e_1 ‚Ä¶, e_p, x_1: e_p+1, ‚Ä¶, x_q: e_p+q)

.ùïÄ(e_1 ‚Ä¶, e_p, x_1: e_p+1, ‚Ä¶, x_q: e_p+q).


The
redirectee constructorconstructor!redirectee
for this declaration is then the constructor denoted by
C<X_1 ‚Ä¶, X_m> respectively C<X_1 ‚Ä¶, X_m>.ùïÄ.
It is a compile-time error if the static argument list type
(<ref>)
of (e_1 ‚Ä¶, e_p, x_1: e_p+1, ‚Ä¶, x_q: e_p+q)
is not an assignable match for the formal parameter list of the redirectee.


Note that the case where no named parameters are passed
is covered by letting q be zero,
and the case where C is a non-generic class
is covered by letting m be zero,
in which case the formal type parameter list and actual type argument lists
are omitted
(<ref>).



We require an assignable match rather than the stricter subtype match
because a generative redirecting constructor k invokes its redirectee k'
in a manner which resembles function invocation in general.
For instance, k could accept an argument x
and pass on an expression e_j using x such as x.f(42) to k',
and it would be surprising
if e_j were subject to more strict constraints than the ones applied to
actual arguments to function invocations in general.



A redirecting generative constructor q' is redirection-reachable
from a redirecting generative constructor q iff
q' is the redirectee constructor of q,
or q‚Äù is the redirectee constructor of q
and q' is redirection-reachable from q‚Äù.
It is a compile-time error if a redirecting generative constructor
is redirection-reachable from itself.


When  is ,
it is a compile-time error if the redirectee is not a constant constructor.
Moreover, when  is , each
e_i, i ‚àà 1 .. p+q,
must be a potentially constant expression (<ref>).



It is a dynamic type error if an actual argument passed
in an invocation of a redirecting generative constructor k
is not a subtype of the actual type (<ref>)
of the corresponding formal parameter in the declaration of k.

It is a dynamic type error if an actual argument passed
to the redirectee k' of a redirecting generative constructor
is not a subtype of the actual type
(<ref>)
of the corresponding formal parameter in the declaration of the redirectee.




  
Initializer Lists
initializerLists


An initializer list begins with a colon,
and consists of a comma-separated list of individual initializers.


There are three kinds of initializers.


  ‚àô A superinitializer identifies a
  superconstructor ‚Äî that is,
  a specific constructor of the superclass.
  Execution of the superinitializer causes
  the initializer list of the superconstructor to be executed.

  ‚àô An instance variable initializer
  assigns an object to an individual instance variable.

  ‚àô An assertion.




<initializers> ::= `:' <initializerListEntry> (`,' <initializerListEntry>)*

<initializerListEntry> ::=  <arguments>
   `.' <identifier> <arguments>
  <fieldInitializer>
  <assertion>

<fieldInitializer> ::= 
  ( `.')? <identifier> `=' <initializerExpression>

<initializerExpression> ::= 
  <assignableExpression> <assignmentOperator> <expression>
  <conditionalExpression>
  <cascade>
  <throwExpression>







As a special disambiguation rule,
an initializerExpression can not derive a functionExpression.


This resolves a near-ambiguity:
In A() :  x  =  ()  { ‚Ä¶ },
x could be initialized to the empty record,
and the block could be the body of the constructor.
Alternatively, x could be initialized to a function object,
and the constructor would then not have a body.
It would only be known which case we have when we encounter
(or do not encounter)
a semicolon at the very end.
That was considered unreadable.
Hence, parsers can commit to not parsing a function expression
in this situation.
Note that it is still possible for initializerExpression to derive
a term that contains a function expression as a subterm, e.g.,
A() :  x  =  (()  { ‚Ä¶ });.



An initializer of the form v = e is equivalent to
an initializer of the form .v = e,
and both forms are called instance variable initializers.
It is a compile-time error if the enclosing class
does not declare an instance variable named v.
It is a compile-time error unless the static type of e
is assignable to the declared type of v.


Consider a superinitializer s of the form

(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
respectively

.ùïÄ(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k).


Let S be the superclass of the enclosing class of s.
It is a compile-time error if class S does not declare
a generative constructor named S (respectively S.ùïÄ).
Otherwise, the static analysis of s is performed
as specified in Section¬†<ref>,
as if  respectively .ùïÄ
had had the function type of the denoted constructor,




and substituting the formal type variables of the superclass
for the corresponding actual type arguments passed to the superclass
in the header of the current class.


Let k be a generative constructor.
Then k may include at most one superinitializer in its initializer list
or a compile-time error occurs.
If no superinitializer is provided,
an implicit superinitializer of the form () is added
at the end of k's initializer list,
unless the enclosing class is class Object.
It is a compile-time error if a superinitializer appears
in k's initializer list at any other position than at the end.
It is a compile-time error if more than one initializer corresponding
to a given instance variable appears in k's initializer list.
It is a compile-time error if k's initializer list contains
an initializer for a variable that is initialized by means of
an initializing formal of k.
It is a compile-time error if k's initializer list contains
an initializer for a final variable f whose declaration includes
an initialization expression.
It is a compile-time error if k includes an initializing formal
for a final variable f whose declaration includes
an initialization expression.


Let f be a final instance variable declared in
the immediately enclosing class or enum.
A compile-time error occurs unless f is initialized
by one of the following means:


  * f is declared by an initializing variable declaration.

  * f is initialized by means of an initializing formal of k.

  * f has an initializer in k's initializer list.



It is a compile-time error if k's initializer list contains
an initializer for a variable that is not
an instance variable declared in the immediately surrounding class.


The initializer list may of course contain an initializer for
any instance variable declared by the immediately surrounding class,
even if it is not final.



It is a compile-time error if a generative constructor of class Object
includes a superinitializer.




  
Execution of Generative Constructors
executionOfGenerativeConstructors


k, T, i
Execution of a generative constructor k of type T
to initialize a fresh instance i
is always done with respect to a set of bindings for its formal parameters
and the type parameters of the immediately enclosing class or enum bound to
a set of actual type arguments of T, t1m.


These bindings are usually determined by the instance creation expression
that invoked the constructor (directly or indirectly).
However, they may also be determined by a reflective call.



If k is redirecting then its redirect clause has the form

.g(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)

where g identifies another generative constructor
of the immediately surrounding class.
Then execution of k to initialize i proceeds by
evaluating the argument list
(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
to an actual argument list a of the form
(o_1, ‚Ä¶, o_n, x_n+1: o_n+1, ‚Ä¶, x_n+k: o_n+k)
in an environment where the
type parameters of the enclosing class are bound to
t_1, ‚Ä¶, t_m.


Next, the body of g is executed to initialize i
with respect to the bindings that map
the formal parameters of g to the corresponding objects
in the actual argument list a,
with  bound to i,
and the type parameters of the immediately enclosing class or enum bound to
t1m.


Otherwise, k is not redirecting.
Execution then proceeds as follows:


The instance variable declarations of the immediately enclosing class or enum
are visited in the order they appear in the program text.
For each such declaration d, if d has the form
finalConstVarOrType v = e; 
then e is evaluated to an object o
and the instance variable v of i is bound to o.


Any initializing formals declared in k's parameter list
are executed in the order they appear in the program text.


Then, the initializers of k's initializer list are executed to initialize i
in the order they appear in the program, as described below
(p. executionOfInitializerLists).


We could observe the order by side effecting external routines called.
So we need to specify the order.



Then if any instance variable of i declared
by the immediately enclosing class or enum
is not yet bound to an object,
all such variables are initialized with the null object (<ref>).


Then, unless the enclosing class is Object, the explicitly specified or
implicitly added superinitializer (<ref>) is executed to
further initialize i.


After the superinitializer has completed, the body of k is executed
in a scope where  is bound to i.


This process ensures that no uninitialized final instance variable
is ever seen by code.
Note that  is not in scope on the right hand side of an initializer
(see <ref>)
so no instance method can execute during initialization:
an instance method cannot be directly invoked,
nor can  be passed into any other code being invoked in the initializer.





  
Execution of Initializer Lists
executionOfInitializerLists


During the execution of a generative constructor to initialize an instance
i,
execution of an initializer of the form .v = e
proceeds as follows:


First, the expression e is evaluated to an object o.
Then, the instance variable v of i is bound to o.

It is a dynamic type error if the dynamic type of o is not
a subtype of the actual type
(<ref>)
of the instance variable v.


Execution of an initializer that is an assertion proceeds by
executing the assertion (<ref>).


Consider a superinitializer s of the form

(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
respectively

.ùïÄ(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k).


C, S, u_j, p
Let C be the class in which s appears and let S be the superclass of C.
If S is generic (<ref>),
let u_1, ‚Ä¶, u_p be the actual type arguments passed to S,
obtained by substituting the actual bindings t1m
of the formal type parameters of C
in the superclass as specified in the header of C.
Let k be the constructor declared in S and named
S respectively S.ùïÄ.


Execution of s proceeds as follows:
The argument list
(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
is evaluated to an actual argument list a of the form
(o_1, ‚Ä¶, o_n, x_n+1: o_n+1, ‚Ä¶, x_n+k: o_n+k).
Then the body of the superconstructor k is executed
in an environment where the formal parameters of k are bound to
the corresponding actual arguments from a,
and the formal type parameters of S are bound to u_1, ‚Ä¶, u_p.




  ¬ß.¬ß.¬ß Factories

factories


A factoryconstructor!factory
is a constructor prefaced by the built-in identifier
(<ref>)
.


<factoryConstructorSignature> ::= 
  ?  <constructorName> <formalParameterList>



The return type of a factory whose signature is of
the form  M or
the form  M.ùïÄ
is M if M is not a generic type;
otherwise the return type is
M<T_1, ‚Ä¶, T_n>
where T_1, ‚Ä¶, T_n are the type parameters of the enclosing class.


It is a compile-time error if M is not the name of

the immediately enclosing class or enum.



It is a dynamic type error if a factory returns a non-null object
whose type is not a subtype of its actual
(<ref>)
return type.


It seems useless to allow a factory to return the null object (<ref>).
But it is more uniform to allow it, as the rules currently do.



Factories address classic weaknesses associated with constructors
in other languages.
Factories can produce instances that are not freshly allocated:
they can come from a cache.
Likewise, factories can return instances of different classes.





  
Redirecting Factory Constructors
redirectingFactoryConstructors


A redirecting factory constructorconstructor!redirecting factory
specifies a call to a constructor of another class that is to be used
whenever the redirecting constructor is called.


<redirectingFactoryConstructorSignature> ::= 
  ?  <constructorName> <formalParameterList> `=' 
  <constructorDesignation>

<constructorDesignation> ::= <typeIdentifier>
  <qualifiedName>
  <typeName> <typeArguments> (`.' <identifier>)?


Assume that
C, X_j, B_j, m
C<X_1  B_1 ‚Ä¶, X_m  B_m>
is the name and formal type parameters of the enclosing class,
, N
 is  or empty,
N is C or C.ùïÄ_0 for some identifier ùïÄ_0,
and ùïÄ is an identifier,
then consider a declaration of a redirecting factory constructor
k of one of the forms


 
    N(T_1 x_1 ‚Ä¶, T_n x_n,[T_n+1 x_n+1=d_1, ‚Ä¶, T_n+k x_n+k=d_k]) = R;


 
    N(T_1 x_1 ‚Ä¶, T_n x_n,{T_n+1 x_n+1=d_1, ‚Ä¶, T_n+k x_n+k=d_k}) = R;


R, T
where R is of one of the forms
T<S_1 ‚Ä¶, S_p> or
T<S_1 ‚Ä¶, S_p>.ùïÄ.


It is a compile-time error if T does not denote
a class accessible in the current scope.
If T does denote such a class D,
it is a compile-time error if R does not denote a constructor.



Otherwise, it is a compile-time error
if R denotes a generative constructor and D is abstract.
Otherwise, the
redirectee constructorconstructor!redirectee
for this declaration is the constructor k' denoted by R.


A redirecting factory constructor q' is redirection-reachable
from a redirecting factory constructor q iff
q' is the redirectee constructor of q,
or q‚Äù is the redirectee constructor of q
and q' is redirection-reachable from q‚Äù.
It is a compile-time error if a redirecting factory constructor
is redirection-reachable from itself.


Let T be the static argument list type
(<ref>)
(T_1 ‚Ä¶, T_n+k)
when k takes no named arguments, and
(T_1 ‚Ä¶, T_n, T_n+1 x_n+1, ‚Ä¶, T_n+k x_n+k)
when k takes some named arguments.
It is a compile-time error if T
is not a subtype match for the formal parameter list of the redirectee.


We require a subtype match
(rather than the more forgiving assignable match
which is used with a generative redirecting constructor),
because a factory redirecting constructor k always invokes
its redirectee k' with
exactly the same actual arguments that k received.
This means that a downcast on an actual argument
‚Äúbetween‚Äù k and k'
would either be unused because the actual argument has
the type required by k',
or it would amount to a dynamic error which is simply delayed a single step.



Note that the non-generic case is covered by
letting m or p or both be zero,
in which case the formal type parameter list of the class C
and/or the actual type argument list of
the redirectee constructor is omitted
(<ref>).



It is a compile-time error if k explicitly specifies
a default value for an optional parameter.


Default values specified in k would be ignored,
since it is the actual parameters that are passed to k'.
Hence, default values are disallowed.



It is a compile-time error if a formal parameter of k' has a default value
whose type is not a subtype of the type annotation
on the corresponding formal parameter in k.


Note that it is not possible to modify the arguments being passed to k'.



At first glance, one might think that
ordinary factory constructors could simply create
instances of other classes and return them,
and that redirecting factories are unnecessary.
However, redirecting factories have several advantages:


  * An abstract class may provide a constant constructor
  that utilizes the constant constructor of another class.

  * A redirecting factory constructor avoids the need for forwarders
  to repeat the formal parameters and their default values.




It is a compile-time error if k is prefixed with the  modifier
but k' is not a constant constructor (<ref>).


Let T1m be the actual type arguments passed to k'
in the declaration of k.
Let X1m be the formal type parameters declared by
the class that contains the declaration of k'.
Let F' be the function type of k' (<ref>).
It is a compile-time error if [T_1/X_1, ‚Ä¶, T_m/X_m]F'
is not a subtype of the function type of k.


In the case where the two classes are non-generic
this is just a subtype check on the function types of the two constructors.
In general, this implies that the resulting object conforms to

the interface of the class or enum that immediately encloses k.



For the dynamic semantics,
assume that k is a redirecting factory constructor
and k' is the redirectee of k.



It is a dynamic type error if an actual argument passed in an invocation of k
is not a subtype of the actual type (<ref>)
of the corresponding formal parameter in the declaration of k.


When the redirectee k' is a factory constructor,
execution of k amounts to execution of k'
with the actual arguments passed to k.
The result of the execution of k' is the result of k.


When the redirectee k' is a generative constructor,
let o be a fresh instance (<ref>)
of the class that contains k'.
Execution of k then amounts to execution of k' to initialize o,
governed by the same rules as an instance creation expression
(<ref>).
If k' completed normally then the execution of k
completes normally returning o,
otherwise k completes by throwing the exception and stack trace
thrown by k'.




  ¬ß.¬ß.¬ß Constant Constructors

constantConstructors


A constant constructorconstructor!constant
may be used to create compile-time constant (<ref>) objects.
A constant constructor is prefixed by the reserved word .


<constantConstructorSignature> ::= 
   <constructorName> <formalParameterList>



Constant constructors have stronger constraints than other constructors.
For instance, all the work of a non-redirecting generative constant constructor
must be done in its initializers
and in the initializing expressions of
the instance variables of the enclosing class
(and the latter may already have happened earlier,
because those initializing expressions must be constant).



Constant redirecting generative and factory constructors are specified elsewhere
(p. redirectingGenerativeConstructors,
p. redirectingFactoryConstructors).
This section is henceforth concerned with
non-redirecting generative constant constructors.


It is a compile-time error if a non-redirecting generative constant constructor
is declared by a class that has a instance variable which is not final.


The above refers to both locally declared and inherited instance variables.



If a non-redirecting generative constant constructor k
is declared by a class C,
it is a compile-time error
for an instance variable declared in C
to have an initializing expression that is not a constant expression.


A superclass of C cannot have such an initializing expression e either.
If it has a non-redirecting generative constant constructor
then e is an error,
and if it does not have such a constructor
then the (implicit or explicit) superinitializer in k is an error.



The superinitializer that appears, explicitly or implicitly,
in the initializer list of a constant constructor
must specify a generative constant constructor of
the superclass of the immediately enclosing class,
or a compile-time error occurs.


Any expression that appears within
the initializer list of a constant constructor
must be a potentially constant expression
(<ref>),
or a compile-time error occurs.


When a constant constructor k is invoked from
a constant object expression,
it is a compile-time error if
the invocation of k at run time would throw an exception,
and it is a compile-time error if
substitution of the actual arguments for the formal parameters
yields an initializing expression e in the initializer list of k
which is not a constant expression.


For instance, if e is a.length
where a is a formal argument of k with type ,
e is potentially constant and can be used in the initializer list of k.
It is an error to invoke k with an argument of type C
if C is a class different from String,
even if C has a length getter,
and that same expression would evaluate without errors at run time.





 ¬ß.¬ß Static Methods

staticMethods


Static methodsmethod!static
are functions, other than getters or setters,
whose declarations are immediately contained within a class declaration
and that are declared .
The static methods of a class C are those static methods declared by C.


Inheritance of static methods has little utility in Dart.
Static methods cannot be overridden.
Any required static method can be obtained from its declaring library,
and there is no need to bring it into scope via inheritance.
Experience shows that developers are confused by
the idea of inherited methods that are not instance methods.

Of course, the entire notion of static methods is debatable,
but it is retained here because so many programmers are familiar with it.
Dart static methods may be seen as functions of the enclosing library.



Static method declarations may conflict with other declarations
(<ref>).





 ¬ß.¬ß Superclasses

superclasses











The superclass S' of a class C whose declaration has a with clause
 M_1, ‚Ä¶, M_k
and an extends clause
 S
is the abstract class obtained by application of
mixin composition (<ref>) M_k* ‚ãØ * M_1 to S.
The name S' is a fresh identifier.
If no  clause is specified then the  clause of
a class C specifies its superclass.
If no  clause is specified, then either:


  * C is Object, which has no superclass. OR

  * Class C is deemed to have an  clause of the form
   Object, and the rules above apply.



It is a compile-time error to specify an  clause
for class Object.


<superclass> ::=  <typeNotVoid> <mixins>?
    <mixins>

<mixins> ::=  <typeNotVoidList>



The scope of the  and  clauses of a class C is
the type-parameter scope of C.


It is a compile-time error if the type
in the  clause of a class C is
a type variable (<ref>),
a type alias that does not denote a class (<ref>),
an enumerated type (<ref>),
a deferred type (<ref>), type  (<ref>),
or type FutureOr<T> for any T (<ref>).


Note that  is a reserved word,
which implies that the same restrictions apply for the type ,
and similar restrictions are specified for other types like
Null (<ref>) and
String (<ref>).



The type parameters of a generic class are available in
the lexical scope of the superclass clause,
potentially shadowing classes in the surrounding scope.
The following code is therefore illegal
and should cause a compile-time error:



class T {}


/* Compilation error: Attempt to subclass a type parameter */
class G<T> extends T {}





A class S is a superclass of a class C iff either:


  * S is the superclass of C, or

  * S is a superclass of a class S',
  and S' is the superclass of C.



It is a compile-time error if a class C is a superclass of itself.




  ¬ß.¬ß.¬ß Inheritance and Overriding

inheritanceAndOverriding


Let C be a class, let A be a superclass of C, and
let S_1, ‚Ä¶, S_k be superclasses of C that are also subclasses of A.
C inherits all concrete, accessible instance members of A
that have not been overridden by a concrete declaration in C
or in at least one of S_1, ‚Ä¶, S_k.


It would be more attractive to give a purely local definition of inheritance,
that depended only on the members of the direct superclass S.
However, a class C can inherit a member m that
is not a member of its superclass S.
This can occur when the member m is private to the library L_1 of C,
whereas S comes from a different library L_2,
but the superclass chain of S includes a class declared in L_1.



A class may override instance members
that would otherwise have been inherited from its superclass.


Let C = S_0 be a class declared in library L, and
let {S_1, ‚Ä¶, S_k} be the set of all superclasses of C,
where S_i is the superclass of S_i-1 for i ‚àà 1 .. k.
S_k is the built-in class Object.
Let C declare a concrete member m, and
let m' be a concrete member of S_j, j ‚àà 1 .. k, that has
the same name as m,
such that m' is accessible to L.
Then m overrides m'
if m' is not already overridden by a concrete member of
at least one of S_1, ‚Ä¶, S_j-1
and neither m nor m' are instance variables.


Instance variables never override each other.
The getters and setters induced by instance variables do.



Again, a local definition of overriding would be preferable,
but fails to account for library privacy.



Whether an override is legal or not is specified relative to
all direct superinterfaces, not just the interface of the superclass,
and that is described elsewhere
(<ref>).
Static members never override anything,
but they may participate in some conflicts
involving declarations in superinterfaces
(<ref>).



For convenience, here is a summary of the relevant rules,
using `error' to denote compile-time errors.
Remember that this is not normative.
The controlling language is in the relevant sections of the specification.




  * There is only one namespace
  for getters, setters, methods and constructors (<ref>).
  A non-local variable f introduces a getter f,
  and a non-local variable f
  also introduces a setter
  if it is not final and not constant,
  or it is late and final and has no initializing expression
  f= (<ref>, <ref>).
  When we speak of members here, we mean
  accessible instance, static, or library variables,
  getters, setters, and methods
  (<ref>).

  * You cannot have two members with the same name in the same class‚Äîbe
  they declared or inherited (<ref>, <ref>).

  * Static members are never inherited.

  * It is an error if you have a static member named m in your class
  and an instance member of the same basename
  (<ref>).

  * It is an error if you have a static setter v=,
  and an instance member v (<ref>).

  * It is an error if you have a static getter v
  and an instance setter v= (<ref>).

  * If you define an instance member named m,
  and your superclass has an instance member of the same name,
  they override each other.
  This may or may not be legal.

  * 
  If two members override each other,
  it is an error unless it is a correct override
  (<ref>).

  * Setters, getters and operators never have
  optional parameters of any kind;
  it's an error (<ref>, <ref>, <ref>).

  * It is an error if a member has the same name as its enclosing class
  (<ref>).

  * A class has an implicit interface (<ref>).

  * Superinterface members are not inherited by a class,
  but are inherited by its implicit interface.
  Interfaces have their own inheritance rules
  (<ref>).

  * A member is abstract if
  it has no body and is not labeled 
  (<ref>, <ref>).

  * A class is abstract iff it is explicitly labeled .

  * It is an error if a concrete class does not implement some member
  of its interface, and there is no non-trivial noSuchMethod
  (<ref>).

  * It is an error to call a non-factory constructor of an abstract class
  using an instance creation expression (<ref>),
  such a constructor may only be invoked from another constructor
  using a superinvocation (<ref>).

  * If a class defines an instance member named m,
  and any of its superinterfaces have a member signature named m,
  the interface of the class contains the m from the class itself.

  * An interface inherits all members of its superinterfaces
  that are not overridden and not members of multiple superinterfaces.

  * If multiple superinterfaces of an interface
  define a member with the same name as m,
  then at most one member is inherited.
  That member (if it exists) is the one whose type is a subtype
  of all the others.
  If there is no such member, an error occurs
  (<ref>).

  * Rule <ref> applies to interfaces as well as classes
  (<ref>).

  * It is an error if a concrete class does not have an implementation
  for a method in its interface
  unless it has a non-trivial noSuchMethod
  (<ref>).

  * The identifier of a named constructor cannot be the same as
  the basename of a static member declared in the same class
  (<ref>).






 ¬ß.¬ß Superinterfaces

superinterfaces


A class has a set of direct superinterfaces.
This set contains the interface of its superclass
and the interfaces of the classes specified in
the  clause of the class.


<interfaces> ::=  <typeNotVoidList>



The scope of the  clause of a class C is
the type-parameter scope of C.


It is a compile-time error if an element
in the type list of the  clause of a class C is
a type variable (<ref>),
a type alias that does not denote a class (<ref>),
an enumerated type (<ref>),
a deferred type (<ref>), type  (<ref>),
or type FutureOr<T> for any T (<ref>).
It is a compile-time error if two elements in the type list of

the  clause of a class C specifies the same type T.
It is a compile-time error if the superclass of a class C is
one of the elements of the type list of the  clause of C.


One might argue that it is harmless to repeat a type in the superinterface list,
so why make it an error?
The issue is not so much that the situation is erroneous,
but that it is pointless.
As such, it is an indication that the programmer may very well have meant
to say something else‚Äîand that is a mistake that should be
called to her or his attention.



It is a compile-time error if a class C has two superinterfaces
that are different instantiations of the same generic class.

For example, a class can not have
both List<> and List<> as superinterfaces,
directly or indirectly.



When a generic class C declares a type parameter X,
it is a compile-time error if X occurs in a non-covariant position



in a type which specifies a superinterface of C.

For example, the class can not have
List< (X)>
in its  or  clause.



It is a compile-time error if the interface of a class C is
a superinterface of itself.


A class does not inherit members from its superinterfaces.
However, its implicit interface does.





 ¬ß.¬ß Class Member Conflicts

classMemberConflicts


Some pairs of class, mixin, enum, and extension member declarations
cannot coexist,
even though they do not both introduce the same name into the same scope.
This section specifies these errors.


The basename of a getter or method named n is n;
the basename of a setter named n= is n.
The basename of an operator named n is n,
except for operator []= whose basename is [].


Let C be a class.
It is a compile-time error if C
declares a constructor named C.n and
a static member with basename n.
It is a compile-time error if C
declares a static member with basename n and
the interface of C has an instance member with basename n.
It is a compile-time error if the interface of C
has an instance method named n and an instance setter with basename n.
It is a compile-time error if C declares a static method named n
and a static setter with basename n.


When C is a mixin or an extension,
the compile-time errors occur according to the same rules.

This is redundant in some cases.
For instance, it is already an error for a mixin to declare a constructor.
But useful cases exist as well, e.g., a conflict between a static member
and an instance member.



These errors occur when the getters or setters are defined explicitly
as well as when they are induced by variable declarations.


Note that other errors which are similar in nature are covered elsewhere.
For instance, if C is a class that has two superinterfaces I_1 and I_2,
where I_1 has a method named m
and I_2 has a getter named m,
then it is an error because the computation of the interface of C
includes a computation of the combined member signature
(<ref>)
of that getter and that method,
and it is an error for a combined member signature
to include a getter and a non-getter.





¬ß INTERFACES

interfaces


This section introduces the notion of interfaces.
We define the notion of member signatures first,
because that concept is needed in the definition of interfaces.

















A member signature s
can be derived from a class instance member declaration D.
It contains the same information as D,
except that s omits the body, if any;
it contains the return type and parameter types
even if they are implicit in D;
it omits the names of positional parameters;
it omits the modifier  from each parameter, if any;
it omits metadata
(<ref>);
and it omits information about whether the member is
, , *, or *.
It makes no difference whether D is given as explicit syntax
or it is induced implicitly, e.g., by a variable declaration.
Finally, if s has formal parameters,
each of them has the modifier 
(<ref>)
if and only if that parameter is covariant-by-declaration
(<ref>).


We use a syntax similar to that of an abstract member declaration
to specify member signatures.
The difference is that the names of positional parameters are omitted.
This syntax is only used for the purposes of specification.


Member signatures are synthetic entities, that is,
they are not supported as concrete syntax in a Dart program,
they are computed entities used during static analysis.
However, it is useful to be able to indicate the
properties of a member signature in this specification
via a syntactic representation.
A member signature makes it explicit
whether a parameter is covariant-by-declaration,
but it remains implicit whether it is covariant-by-class
(<ref>).
The reason for this is that the rule for determining whether
a given override relation is correct
(<ref>)
depends on the former and not on the latter.



Let m be a method signature of the form

T_0 ùïÄ<>(

        ? T1n,

        [? T= dn+1n+k]).

The function type ofmethod signature!function type
m is then

T_0.


Let m be a method signature of the form

T_0 ùïÄ<>(

        ? T1n,

        {? Tx= dn+1n+k}).

The function type of m is then

T_0.


Let m be a setter signature of the form
  ùïÄ(? T p).
The function type of m is then
T.


The function type of a member signature remains unchanged if
some or all default values are omitted.


We do not specify the function type of a getter signature.
For such signatures we will instead directly refer to the return type.



An interface is a synthetic entity that defines
how one may interact with an object.
An interface has method, getter and setter signatures,
and a set of superinterfaces,
which are again interfaces.
Each interface is the implicit interface of a class,
in which case we call it a
class interfaceinterface!class,
or a combination of several other interfaces,
in which case we call it a
combined interfaceinterface!combined.


Let C be a class.
The class interface I of C is the interface that declares
a member signature derived from
each instance member declared by C.
The direct superinterfaces of I are the direct superinterfaces of C
(<ref>).


We say that the class interface `declares' these member signatures,
such that we can say that an interface `declares' or `has' a member,
just like we do for classes.
Note that a member signature s of the interface of class C
may have a parameter p with modifier ,
even though s was derived from a declaration D in C
and the parameter corresponding to p in D does not
have that modifier.
This is because p may have ‚Äúinherited‚Äù
the property of being covariant-by-declaration
from one of its superinterfaces
(<ref>).



For the purpose of performing static checks on ordinary method invocations
(<ref>)
and property extractions
(<ref>),
any type T which is T_0 bounded
(<ref>),
where T_0 is a class with interface I,
is also considered to have interface I.
Similarly, when T is T_0 bounded where T_0 is a function type,
T is considered to have a method named  with signature m,
such that the function type of m is T_0.


I, I1k
The combined interface I of a list of interfaces I1k
is the interface that declares the set of member signatures M,
where M is determined as specified below.
The direct superinterfaces of I is the set I1k.


Let M_0 be the set of all member signatures declared by I1k.
M is then the smallest set satisfying the following:



  * For each name ùïÄ and library L such that M_0 contains
  a member signature named ùïÄ which is accessible to L,
  let m be the combined member signature named ùïÄ
  from I1k with respect to L.
  It is a compile-time error
  if the computation of this combined member signature failed.
  Otherwise, M contains m.



Interfaces must be able to contain inaccessible member signatures,
because they may be accessible from the interfaces associated with
declarations of subtypes.



For instance, class C in library L may declare a private member named
_foo,
a class D in a different library L_2 may extend C,
and a class E in library L may extend D;
E may then declare a member that overrides _foo from C,
and that override relation must be checked based on the interface of D.
So we cannot allow the interface of D
to ‚Äúforget‚Äù inaccessible members like _foo.

For conflicts the situation is even more demanding:
Classes C_1 and C_2 in library L may declare private members
String _foo(int i) and int get _foo,
and a subtype D_12 in a different library L_2 may have
an  clause listing both C_1 and C_2.
In that case we must report a conflict even though the conflicting
declarations are not accessible to L_2,
because those member signatures are then noSuchMethod forwarded
(<ref>),
and an invocation of _foo on an instance of D in L
must return an `int` according to the first member signature,
and it must return a function object according to the second one,
and an invocation of _foo(42)
must return a String with the first member signature, and it must fail
(at compile time or, for a dynamic invocation, run time) with the second.



It may not be possible to satisfy such constraints simultaneously,
and it will inevitably be a complex semantics,
so we have chosen to make it an error.
It is unfortunate that the addition of a private declaration
in one library may break existing code in a different library.
But it should be noted that the conflicts can be detected locally
in the library where the private declarations exist,
because they only arise for private members with
the same name and incompatible signatures.
Renaming that private member to anything not used in that library
will eliminate the conflict and will not break any clients.





 ¬ß.¬ß Combined Member Signatures

combinedMemberSignatures


This section specifies how to compute a member signature which will
appropriately stand for a prioritized set of several member signatures,
taken from a given list of interfaces.


In general, a combined member signature has a type which is
a subtype of all the types given for that member.
This is needed in order to ensure that the type of
a member ùïÄ of a class C is well-defined,
even in the case where C inherits
several different declarations of ùïÄ
and does not override ùïÄ.
In case of failure, it serves to specify the situations
where a developer must add a declaration in order to resolve an ambiguity.
The member signatures are prioritized in the sense that we will select
a member signature from the interface with the lowest possible index
in the case where several member signatures are equally suitable
to be chosen as the combined member signature.
That is, ‚Äúthe first interface wins‚Äù.



For the purposes of computing a combined member signature,
we need a special notion of
equalitymember signature equality
of member signatures.
Two member signatures m_1 and m_2 are equal
iff they have the same name,
are accessible to the same set of libraries,
have the same same return type (for getters),
or the same function type and the same occurrences of 
(for methods and setters).


In particular, private methods from different libraries are never equal.
Top types differ as well.
For instance,
 and Object
are not equal, even though they are subtypes of each other.
We need this distinction because management of top type discrepancies is
one of the purposes of computing a combined interface.



ùïÄ, L, I_j, k
Now we define combined member signatures.
Let ùïÄ be an identifier, L a library,
I1k a list of interfaces,
and M_0 the set of
all member signatures from I1k named ùïÄ
and accessible to L.
The
combined member signature
  named ùïÄ from I1k with respect to L
  combined member signature
is the member signature which is obtained as follows:


If M_0 is empty, computation of the combined member signature failed.


If M_0 contains exactly one member signature m',
the combined member signature is m'.


Otherwise, M_0 contains more than one member signature
m1q.


Failing mixtures
If M_0 contains at least one getter signature
and at least one non-getter signature,
the computation of the combined member signature failed.



Getters
If M_0 contains getter signatures only,
the computation of the combined member signature proceeds as described below
for methods and setters,
except that it uses the return type of the getter signature
where methods and setters use the function type of the member signature.



Methods and setters
In this case M_0 consists of setter signatures only,
or method signatures only,
because the name ùïÄ in the former case always ends in =,
which is never true in the latter case.


N
Determine whether there exists a non-empty set N ‚äÜ 1 .. q such that
for each i ‚àà N,
the function type of m_i is a subtype of
the function type of m_j for each j ‚àà 1 .. q.

If no such set exists, the computation of the combined member signature failed.

A useful intuition about this situation is that
the given member signatures do not agree on
which type is suitable for the member named ùïÄ.
Otherwise we have a set of member signatures which are ‚Äúmost specific‚Äù
in the sense that their function types are subtypes of them all.


 






Otherwise, when a set N as specified above exists,
let  be the greatest set satisfying the requirement on N,

and let = { m_i | i ‚àà}.

That is,  contains all member signatures named ùïÄ
with the most specific type.
Dart subtyping is a partial pre-order,
which ensures that such a greatest set of least elements exists,
if any non-empty set of least elements exist.
We can have several such signatures because member signatures
can be such that they are not equal,
and yet their function types are subtypes of each other.
We need to compute one member signature from ,
and we do that by using the ordering of the given interfaces.




Let j ‚àà 1 .. k be the smallest number such that
= ‚à© I_j is non-empty.
Let m_i be the single element that  contains.

This set contains exactly one element because it is non-empty
and no interface contains more than one member signature named ùïÄ.
In other words, we choose m_i as the member signature from
the first possible interface
among the most specific member signatures .




The combined member signature is then m',
which is obtained from m_i by adding the modifier 
to each parameter p (if it is not already present)
when there exists a j ‚àà 1 .. q
such that the parameter corresponding to p
(<ref>)
has the modifier .

In other words,
each parameter in the combined member signature is marked covariant
if any of the corresponding parameters are marked covariant,
not just among the most specific signatures,
but among all signatures named ùïÄ (which are accessible to L)
in the given list of interfaces.






 ¬ß.¬ß Superinterfaces

interfaceSuperinterfaces


An interface has a set of direct superinterfaces
(<ref>).
An interface J is a superinterface of an interface I
iff either J is a direct superinterface of I
or J is a superinterface of a direct superinterface of I.


When we say that a type S
implementstype!implements a type
another type T,
this means that T is a superinterface of S,
or S is S_0 bounded for some type S_0
(<ref>),
and T is a superinterface of S_0.
Assume that G is a raw type
(<ref>)
whose declaration declares s type parameters.
When we say that a type S
implementstype!implements a raw type
G,
this means that there exist types U1s
such that S implements G<U1s>.


Note that this is not the same as being a subtype.
For instance, List<int> implements Iterable<int>,
but it does not implement Iterable<num>.
Similarly, List<int> implements Iterable.
Also, note that when S implements T
where T is not a subtype of Null,
S cannot be a subtype of Null.



Assume that S is a type and G is a raw type such that S implements G.
Then there exist unique types U1s such that
S implements G<U1s>.
We then say that U1s are the
actual type arguments of S at G
  type arguments!of a type at a raw type,
and we say that U_j is the
jth actual type argument of S at G
  type arguments!of a type at a raw type, jth,
for any j ‚àà 1 .. s.


For instance, the type argument of List<int> at Iterable
is int.
This concept is particularly useful when
the chain of direct superinterfaces from S to G
does not just pass all type arguments on unchanged, e.g.,
with a declaration like
  C<X, Y>    B<List<Y>, Y, X> {}.





  ¬ß.¬ß.¬ß Inheritance and Overriding

interfaceInheritanceAndOverriding


J, K
Let J be an interface and K be a library.
We define J, K to be the set of member signatures
m
such that all of the following hold:


  * m is accessible to K and

  * A is a direct superinterface of J and either
  
  
  * A declares a member signature m or
  
  * m is a member of A, K.
  

  * m is not overridden by J.



Furthermore, we define J, K to be
the set of member signatures m'
such that all of the following hold:


  * J is the interface of a class C.

  * C declares a member signature m.

  * m' has the same name as m.

  * m' is accessible to K.

  * A is a direct superinterface of J and either
  
  
  * A declares a member signature m' or
  
  * m' is a member of inherited(A, K).
  



Let I be the interface of a class C declared in library L.
I inherits all members of I, L
and I overrides m' if m' ‚ààI, L.


All the compile-time errors pertaining to the overriding of instance members
given in section¬†<ref> hold for overriding between interfaces as well.


If the above rule would cause multiple member signatures
with the same name ùïÄ to be inherited then
exactly one member is inherited, namely
the combined member signature named ùïÄ,
from the direct superinterfaces

in the textual order that they are declared,
with respect to L
(<ref>).
It is a compile-time error
if the computation of said combined member signature fails.




  ¬ß.¬ß.¬ß Correct Member Overrides

correctMemberOverrides


m, m', ùïÄ
Let m and m' be member signatures with the same name ùïÄ.
Then m is a correct override of m'
iff the following criteria are all satisfied:



  * m and m' are both methods, both getters, or both setters.

  * If m and m' are both getters:
  The return type of m must be a subtype of the return type of m'.

  * If m and m' are both methods or both setters:
  Let F be the function type of m
  except that the parameter type is the built-in class Object
  for each parameter of m which is covariant-by-declaration
  (<ref>).
  Let F' be the function type of m'.
  F must then be a subtype of F'.

  
    The subtype requirement ensures that argument list shapes
    that are admissible for an invocation of a method with signature m'
    are also admissible for an invocation of a method with signature m.
    For instance, m' may accept 2 or 3 positional arguments,
    and m may accept 1, 2, 3, or 4 positional arguments, but not vice versa.
    This is a built-in property of the function type subtype rules.
  

  * 
  If m and m' are both methods,
  p is an optional parameter of m,
  p' is the parameter of m' corresponding to p,
  p has default value d and p' has default value d',
  then d and d' must be identical,
  or a static warning occurs.



Note that a parameter which is covariant-by-declaration
must have a type which satisfies one more requirement,
relative to the corresponding parameters in all superinterfaces,
both direct and indirect
(<ref>).
We cannot make that requirement a part of the notion of correct overrides,
because correct overrides are only concerned with
the relation to a single superinterface.





¬ß MIXINS

mixins


A mixin describes the difference between a class and its superclass.
A mixin is either derived from an existing class declaration
or introduced by a mixin declaration.
It is a compile-time error to derive a mixin from
a class that declares a generative constructor,
or from a class that has a superclass other than Object.


Mixin application occurs when one or more mixins are mixed into
a class declaration via its  clause (<ref>).
Mixin application may be used to extend a class per section <ref>;
alternatively, a class may be defined as a mixin application
as described in the following section.




 ¬ß.¬ß Mixin Classes

mixinClasses


<mixinApplicationClass> ::= 
  <identifier> <typeParameters>? `=' <mixinApplication> `;'

<mixinApplication> ::= <typeNotVoid> <mixins> <interfaces>?



It is a compile-time error if an element in
the type list of the  clause of a mixin application is
a type variable (<ref>),
a function type (<ref>),
a type alias that does not denote a class (<ref>),
an enumerated type (<ref>),
a deferred type (<ref>),
type  (<ref>),
type  (<ref>),
or type FutureOr<T> for any T (<ref>).
If T is a type in a  clause, the mixin oftype!mixin of
T is either the mixin derived from T if T denotes a class,
or the mixin introduced by T if T denotes a mixin declaration.


Let D be a mixin application class declaration of the form


?  N = S  M_1, ‚Ä¶, M_n  I_1, ‚Ä¶, I_k;



It is a compile-time error if S is an enumerated type (<ref>).
It is a compile-time error if any of M_1, ‚Ä¶, M_k is an enumerated type
(<ref>).


The effect of D in library L is to introduce the name N into
the scope of L, bound to the class (<ref>) defined by the clause
S  M_1, ‚Ä¶, M_n
with name N, as described below.
If k > 0 then the class also implements I_1, ‚Ä¶, I_k.
Iff the class declaration is prefixed by the built-in identifier ,
the class being defined is made an abstract class.


A clause of the form S  M_1, ‚Ä¶, M_n
with name N defines a class as follows:


If there is only one mixin (n = 1), then S  M_1
defines the class yielded by the mixin application (<ref>)
of the mixin of M_1 (<ref>) to the class denoted by
S with name N.


If there is more than one mixin (n > 1), then
let X be the class defined by S  M_1, ‚Ä¶, M_n-1
with name F, where F is a fresh name, and make X abstract.
Then S  M_1, ‚Ä¶, M_n defines the class yielded
by the mixin application of the mixin of M_n to the class X with name N.


In either case, let K be a class declaration with
the same constructors, superclass, interfaces and instance members as
the defined class.
It is a compile-time error if the declaration of K would cause
a compile-time error.





It is an error, for example, if M contains a member declaration d
which overrides a member signature m in the interface of S,
but which is not a correct override of m
(<ref>).




 ¬ß.¬ß Mixin Declaration

mixinDeclaration


A mixin defines zero or more
mixin member declarationsmixin!member declaration,
zero or more
required superinterfacesmixin!required superinterface,
one
combined superinterfacemixin!combined superinterface,
and zero or more
implemented interfacesmixin!implemented interface.


The mixin derived from a class declaration:


?  X  I_1, ‚Ä¶, I_k {
  members
}


has Object as required superinterface
and combined superinterface,
I_1, ‚Ä¶, I_k as implemented interfaces,
and the instance members of members as mixin member declarations.
If X is generic, so is the mixin.


A mixin declaration introduces a mixin and provides a scope
for static member declarations.


<mixinDeclaration> ::=  <typeIdentifier> <typeParameters>?
   ( <typeNotVoidList>)? <interfaces>?
   `{' (<metadata> <classMemberDeclaration>)* `}'



It is a compile-time error to declare a constructor in a mixin-declaration.


A mixin declaration with no  clause is equivalent
to one with the clause  Object.


Let M be a  declaration of the form


 N<>  T1n
     I1k {
  members
}



It is a compile-time error if any of the types T_1 through T_n
or I_1 through I_k is
a type variable (<ref>),
a function type (<ref>),
a type alias not denoting a class (<ref>),
an enumerated type (<ref>),
a deferred type (<ref>),
type  (<ref>),
type  (<ref>),
or type FutureOr<T> for any T (<ref>).


Let M_S be the interface declared by the class declaration


  M_super<P_1, ‚Ä¶, P_m>  T_1, ‚Ä¶, T_n {}


where M_super is a fresh name.
It is a compile-time error for the mixin declaration if the M_S
class declaration would cause a compile-time error,

that is, if any member is declared by more than one declared superinterface,
and there is not a most specific signature for that member among the super
interfaces
.
The interface M_S is called the
superinvocation interface of the mixin declaration M.

If the mixin declaration M has only one declared superinterface, T_1,
then the superinvocation interface M_super has exactly the same members
as the interface T_1.



Let M_I be the interface that would be defined by the class declaration


  N<>
     T1n, I1k {
  members'
}


where members' are the member declarations of
the mixin declaration M except that all superinvocations are treated
as if  was a valid expression with static type M_S.
It is a compile-time error for the mixin M if this N class
declaration would cause a compile-time error, that is, if the
required superinterfaces, the implemented interfaces and the declarations do not
define a consistent interface, if any member declaration contains a
compile-time error other than a super-invocation, or if a super-invocation
is not valid against the interface M_S.
The interface introduced by the mixin declaration M has the same member
signatures and superinterfaces as M_I.


The mixin declaration M introduces a mixin
with the required superinterfaces T_1, ‚Ä¶, T_n,
the combined superinterface M_S,
implemented interfaces I_1, ‚Ä¶, I_k
and the instance members declared in M as mixin member declarations.




 ¬ß.¬ß Mixin Application

mixinApplication


A mixin may be applied to a superclass, yielding a new class.


Let S be a class,
M be a mixin with required superinterfaces T_1, ‚Ä¶, T_n,
combined superinterface M_S,
implemented interfaces I_1, ‚Ä¶, I_k and
members as mixin member declarations,
and let N be a name.


It is a compile-time error to apply M to S if S does not implement,
directly or indirectly, all of T_1, ‚Ä¶, T_n.
It is a compile-time error if any of members contains a
super-invocation of a member m (for example super.foo,
super + 2, or super[1] = 2), and S does not have a concrete
implementation of m which is a valid override of the member m in
the interface M_S. We treat super-invocations in mixins as
interface invocations on the combined superinterface, so we require the
superclass of a mixin application to have valid implementations of those
interface members that are actually super-invoked.


The mixin application of M to S with name N introduces a new
class, C, with name N, superclass S,
implemented interface M
and members as instance members.
The class C has no static members.
If S declares any generative constructors, then the application
introduces generative constructors on C as follows:


Let L_C be the library containing the mixin application.
That is, the library containing the clause S  M
or the clause S_0  M_1, ‚Ä¶, M_k, M giving rise
to the mixin application.

Let S_N be the name of S.

For each generative constructor of the form
S_q(T_1 a_1, ‚Ä¶, T_k a_k)
of S that is accessible to L_C, C has
an implicitly declared constructor of the form


C_q(T_1 a_1, ‚Ä¶, T_k a_k): _q(a_1, ‚Ä¶, a_k);


where C_q is obtained from S_q by replacing occurrences of S_N,
which denote the superclass, by N, and _q is obtained from S_q by
replacing occurrences of S_N which denote the superclass by .
If S_q is a generative const constructor, and C does not declare any
instance variables, C_q is also a const constructor.


For each generative constructor of the form
S_q(T_1 a_1, ‚Ä¶, T_k a_k, [T_k+1 a_k+1 = d_1, ‚Ä¶, T_k+p a_k+p = d_p])
of S that is accessible to L_C, C has
an implicitly declared constructor of the form


C_q(T_1 a_1, ‚Ä¶, T_k a_k, [T_k+1 a_k+1 = d'_1, ‚Ä¶, T_k+p a_k+p = d'_p])
    : _q(a_1, ‚Ä¶, a_k, a_k+1, ‚Ä¶, a_p);


where C_q is obtained from S_q by replacing occurrences of S_N,
which denote the superclass, by N,
_q is obtained from S_q by replacing occurrences of S_N
which denote the superclass by ,
and d'_i, i ‚àà 1..p, is a constant expression evaluating
to the same value as d_i.
If S_q is a generative const constructor, and MC does not declare any
instance variables, C_q is also a const constructor.


For each generative constructor of the form
S_q(T_1 a_1, ‚Ä¶, T_k a_k, {T_k+1 a_k+1 = d_1, ‚Ä¶, T_k+n a_k+n = d_n})
of S that is accessible to L_C, C has
an implicitly declared constructor of the form


C_q(T_1 a_1, ‚Ä¶, T_k a_k, {T_k+1 a_k+1 = d'_1, ‚Ä¶, T_k+n a_k+n = d'_n})
    : _q(a_1, ‚Ä¶, a_k, a_k+1: a_k+1, ‚Ä¶, a_p: a_p);


where C_q is obtained from S_q by replacing occurrences of S_N
which denote the superclass by N,
_q is obtained from S_q by replacing occurrences of S_N
which denote the superclass by ,
and d'_i, i ‚àà 1..n, is a constant expression evaluating to
the same value as d_i.
If S_q is a generative const constructor, and M does not declare any
fields, C_q is also a const constructor.




¬ß EXTENSIONS

extensions


This section specifies extensions.
This mechanism supports the declaration of functions
that are similar to instance methods in use,
but similar to non-method functions in that
they are declared outside the target class,
and they are resolved statically.
The resolution is based on whether the relevant extension is in scope,
and whether the invocation satisfies several other requirements.


<extensionDeclaration> ::= 
   <typeIdentifierNotType>? <typeParameters>?  <type>
   `{' (<metadata> <classMemberDeclaration>)* `}'



A declaration derived from extensionDeclaration is known as an
extension declarationextension!declaration.
It introduces an
extension
with the given identifier, if present,
into the namespace of the enclosing library
(and hence into the library scope),
and provides a scope for the declaration of
extension members.
Additionally, the extension is introduced into the library namespace
with a fresh, private name.
The former is known as the
declared nameextension!declared name
of the extension,
and the latter is known as the
fresh nameextension!fresh name
of the extension.


A fresh name is also introduced into
the library namespace of the current library
for each imported extension,
even when it is imported with a prefix
(<ref>).

The declared name of an extension E is
introduced into the library scope of the current library
following the same rules as the names of
other locally declared or imported declarations like classes.

A fresh name of E is introduced in these cases,
but also in one additional case:
when there is a name clash on the declared name of E.



The fresh name makes it possible for an extension to be used
in an implicit invocation
(<ref>),
even in the case where the declared name
or an import prefix that provides access to the declared name
is shadowed by a declaration in an intermediate scope,
or conflicted by a name clash.



The fact that an extension can be used implicitly even in the case where
it does not have a declared name or the declared name is shadowed or conflicted
reflects the fact that the primary intended usage is implicit invocation.
Even though a developer cannot know (and hence cannot use) the fresh name
of a given extension, an implicit invocation can use it.



It is a compile-time error if the current library has
a deferred import of a library L'
such that the imported namespace from L' contains
a name denoting an extension.


This implies that the import must use  or  to eliminate
the names of extensions from the deferred import.



This restriction ensures that no extensions are introduced
using deferred imports,
which allows us to introduce a semantics for such extensions in the future
without affecting existing code.



The type in an extension declaration
is known as the extension's
 typeextension! type.
The  type can be any valid type, including a type variable.


The basic intuition is that an extension E may have
an  type T (specifying the type of receiver) and a set of members.
If e is an expression whose static type is T
and foo() is a member declared by E,
e.foo() may invoke said member with the value of e bound to .
An explicitly resolved form E(e).foo() is available,
such that E.foo can be invoked even in the case
where e.foo() would invoke some other function
because some other extension is more specific.
Details of these concepts, rules, and mechanisms are given
in this section and its subsections.



The declared name of an extension does not denote a type,
but it can be used to denote the extension itself
(
e.g., in order to access static members of the extension,
or in order to resolve an invocation explicitly
).


An extension declaration introduces two scopes:


  * A type-parameter scopescope!type parameter,
  which is empty if the extension is not generic (<ref>).
  The enclosing scope of the type-parameter scope of an extension declaration is
  the library scope of the current library.
  The type parameter scope is the current scope for
  the type parameters and for the extension's  type.

  * A body scopescope!extension body.
  The enclosing scope of the body scope of an extension declaration is
  the type parameter scope of the extension declaration.
  The current scope for an extension member declaration is
  the body scope of the enclosing extension declaration.



D, E
Let D be an extension declaration with declared name E.
A member declaration in D with the modifier  is designated as a
static memberextension!static member
declaration.

A member declaration in D without the modifier  is designated as an
instance memberextension!instance member
declaration.

Member naming conflict errors may occur in D
in situations that also occur in classes and mixins
(<ref>).
Moreover, a compile-time error occurs in the following situations:



  * D declares a member whose basename is E.

  * D declares a type parameter named E.

  * D declares a member whose basename is the name of a type parameter
  of D.

  * D declares an instance member or a static member whose basename is
  hashCode, noSuchMethod, runtimeType, toString,
  or ==.
  
    That is, a member whose basename is also the name of
    an instance member that every object has.
  

  * D declares a constructor.

  * D declares an instance variable.

  * D declares an abstract member.

  * D declares a method with a formal parameter
  with the modifier .



Abstract members are not allowed because there is
no support for providing an implementation.

Constructors are not allowed since the extension
does not introduce any type that can be constructed.

Instance variables are not allowed because no memory is allocated
for each object accessed as  in the members.
Developers can emulate per- state if needed,
e.g., using an Expando.

Members with the same basename as members of Object
are not allowed because they could only be invoked using explicit resolution,
as in E(e).toString(14),
which would be confusing and error-prone.





 ¬ß.¬ß Explicit Invocation of an Instance Member of an Extension

explicitExtensionInvocations


Let E be a simple or qualified identifier
that denotes an extension.
An extension applicationextension!application
is then an expression of the form
E <typeArguments>? `(' <expression> `)'.
An extension member with a name accessible to the current library
can be invoked explicitly on a particular object
by performing a member invocation
(<ref>)
where the receiver is an extension application.


Type inference is not yet specified in this document,
and is assumed to have taken place already
(<ref>),
but the following describes the intended treatment.
This section and its subsections have similar commentary about type inference
below, marked 'With type inference: ‚Ä¶'.

Let E be a simple or qualified identifier denoting
an extension named E and declared as follows:



 E<> on T { ‚Ä¶ }



Type inference for an extension application
of the form E(e)
is done exactly the same as it would be for
the same syntax considered as a constructor invocation
where E is assumed to denote the following class,
and the context type is empty (implying no requirements):



 E<> {
  final T target;
  E(this.target);
}



This will infer type arguments for E(e), and it will
introduce a context type for the expression e.
For example, if E is declared as
 E<T> on Set<T> { ‚Ä¶ }
then E({}) will provide the expression {} with
a context type that makes it a set literal.



a, E, T_j, e
Let a be an extension application of the form
E<T1s>(e),
where E denotes an extension declared as

X_j, B_j, s, T
 E<>  T { ‚Ä¶ }.


We define the
instantiated  typeextension!instantiated  type
of a as [T_1/X_1, ‚Ä¶, T_s/X_s]T.
We define the
instantiation-to-bound  type
  extension!instantiation-to-bound  type
of a as [U_1/X_1, ‚Ä¶, U_s/X_s]T,
where U1s is the result of instantiation to bound
on the type parameters of E
(<ref>).

A compile-time error occurs unless
T_j[T_1/X_1, ‚Ä¶, T_s/X_s]B_j,
j ‚àà 1 .. s
(that is, the bounds cannot be violated).

A compile-time error occurs unless the static type of e is assignable to
the instantiated  type of a.

Note that a compile-time error occurs as well
if the static type of e is 
(<ref>).



It is a compile-time error if an extension application occurs
in a location where it is not the syntactic receiver of
a simple or composite member invocation
(<ref>).


That is, the only valid use of an extension application is
to invoke or tear off members on it.
This is similar to how prefix names can also only be used as
member invocation targets,
except that extensions can also declare operators.
For instance, E(e) + 1 can be a valid invocation of
an operator + declared in an extension E.



An extension application does not have a type.


This is consistent with the fact that any use of an extension application
where a type is needed is a compile-time error.



i, r
Let i be a simple member invocation
(<ref>)
whose receiver r is an extension application of the form
E, T_j, k, e
E<T1k>(e)
(which is E(e) when k is zero)
whose corresponding member name is n,
and assume that r has no compile-time errors.
A compile-time error occurs unless the extension denoted by E
declares a member named n.
Otherwise let X1k be
the type parameters of said extension.
Let s be the member signature of the member n declared by E.
Exactly the same compile-time errors occur for i as
the ones that would occur for a member invocation i_1
which is obtained from i by replacing r by
a variable whose type is
a class C declared in the same scope as E
that declares a member n with member signature
s_1 = [T_1/X_1, ‚Ä¶, T_k/X_k]s:


  C {
  D // Member declaration with signature s_1.
}



The member signature s_1 is called the
invocation member signature
  extension!invocation member signature
of i.
The static type of i is the return type of
the invocation member signature of i.
For example:


 E<X>  List<X> {
  List<List<X>> split(int at) =>
      [this.sublist(0, at), this.sublist(at)];
}


 main() {
  List<num> xs = [1, 2, 3];
   ys = E<num>(xs).split(1); // (*)
}


  C {
  // Declaration with invocation member signature for (*).
  List<List<num>> split(int at);
}



With type inference:
In the case where the invocation member signature s_1 is generic,
type inference occurs on i in the same way as it
would occur for an invocation of a function whose type is the
function type of s_1.



i, r
For the dynamic semantics,
let i be a simple, unconditional member invocation
whose receiver r is an extension application of the form
E, T_j, k, e
E<T1k>(e)
where the type parameters of E are X1k
and the actual values of T1k are t1k
(<ref>),
n, m
and whose corresponding member name is n.
Let m be the member of E that has the name n.
Evaluation of i proceeds by evaluating
e to an object o,
evaluating and binding the actual arguments to the formal parameters
(<ref>),
and finally executing m
in a binding environment where X1k are bound to t1k,
 is bound to o,
and each formal parameter is bound to the corresponding actual argument.
The value of i is the value returned by the invocation of m.


When i is a conditional or composite member invocation,
the static analysis and dynamic semantics is determined by
member invocation desugaring
(<ref>).


Note that a cascade (<ref>)
whose receiver is an extension application a is a compile-time error.
This is so because it implies that a denotes an object, which is not true,
and also because it would force each cascadeSection
to invoke a member of the same extension,
which is unlikely to be desirable.





 ¬ß.¬ß Implicit Invocation of an Instance Member of an Extension

implicitExtensionInvocations


Instance members of an extension can be invoked or closurized implicitly
(without mentioning the name of the extension),
as if they were instance members of the receiver of
the given member invocation.


For instance, if E<T_1, T_2>(e_1).m<T_3>(e_2) is
a correct explicit invocation of the instance member m of
an extension E,
then e_1.m<T_3>(e_2) may be
a correct implicit invocation with the same meaning.
In other words,
the receiver r of a member invocation can be implicitly replaced by
an extension application with receiver r,
if a number of requirements that are detailed below are satisfied.



Implicit invocation is intended as the primary way to use extensions,
with explicit invocation as a fallback
in case the implicit invocation is an error, or
the implicit invocation resolves to an instance member of
a different extension than the intended one.



i, r, m
An implicit extension member invocation occurs
for a member invocation i
(<ref>)
with receiver r and corresponding member name m iff
(1) r is not a type literal,
(2) the interface of the static type of r does not have a member
whose basename is the basename of m,
and (3) there exists a unique most specific
(<ref>)
extension denoted by E which is accessible
(<ref>)
and applicable
(<ref>)
to i.


In the case where no compile-time error occurs,
i is treated as i', which is obtained from i by
replacing the leading r by E(r).


With type inference:
When E is generic,
type inference applied to E(r) may provide actual type arguments,
yielding an i' of the form E<T1k>(r).
If this type inference step fails then E is not applicable
(<ref>).



Implicit invocation of an instance member of an extension
in a cascade is also possible,
because a cascade is desugared to an expression that contains
one or more member invocations.





  ¬ß.¬ß.¬ß Accessibility of an Extension

extensionAccessibility


An extension E is
accessibleextension!accessibility
in a given scope S
if there exists a name n such that a lexical lookup for n from S
(<ref>)
yields E.


The name n can be the declared name of E or the fresh name of E,
but since the fresh name is always in scope
whenever the declared name is in scope,
it is sufficient to consider the fresh name.

When the fresh name of E is in the library scope,
it is available in any scope,
because the name is fresh and hence it cannot be shadowed
by any declaration in any intermediate scope.

This implies that if E is accessible anywhere in a given library L
then it is accessible everywhere in L.





  ¬ß.¬ß.¬ß Applicability of an Extension

extensionApplicability


E, e, r, S, m
Let E be an extension.
Let e be a member invocation
(<ref>)
with a receiver r with static type S
and with a corresponding member name whose basename is m.
We say that E is
applicableextension!is applicable
to e if the following conditions are all satisfied:



  * r is not a type literal.

  
    This means that the invocation is an instance member invocation,
    in the sense that r denotes an object,
    so it may invoke an instance member or be an error,
    but it cannot be a static member access.
    Note that r also does not denote a prefix or an extension,
    and it is not an extension application,
    because they do not have a type.
  

  * The type S does not have an instance member with the basename m,
  and S is neither  nor Never.

  
     and Never are considered to have all members.
    Also, it is an error to access a member on a receiver of type 
    (<ref>),
    so extensions are never applicable to receivers of
    any of the types , Never, or .
   

  For the purpose of determining extension applicability,
  function types and the type Function
  are considered to have a member named .

  
    Hence, extensions are never applicable to functions
    when the basename of the member is .
    
    Instance members declared by the built-in class Object
    exist on all types,
    so no extension is ever applicable for members with such names.
  

  * Consider an extension application a of the form E(v),
  where v is a fresh variable with static type S.
  It is required that an occurrence of a
  in the scope which is the current scope for e
  is not a compile-time error.

  
    In other words, S must match the  type of E.
    With type inference, inferred actual type arguments may be added,
    yielding E<S1k>(v),
    which is then required to not be an error.
    If this inference step fails it is not an error,
    it just means that E is not applicable to e.
  

  * The extension E declares an instance member with basename m.



With type inference:
The context type of the invocation does not affect
whether the extension is applicable,
and neither the context type nor the method invocation affects
the type inference of r,
but if the extension method itself is generic,
the context type may affect the member invocation.





  ¬ß.¬ß.¬ß Specificity of an Extension

extensionSpecificity


E_j, k
When E1k, k > 1, are extensions
which are accessible and applicable to a member invocation e
(<ref>),
we define the notion of
specificityextension!specificity,
which is a partial order on E1k.


Specificity is used to determine which extension method to execute
in the situation where more than one choice is possible.



e, r, m
Let e be a member invocation with receiver r
and correspsonding member name m,
E_1, E_2
and let E_1 and E_2 denote two distinct
accessible and applicable extensions for e.
T_j, S_j
Let T_j be the instantiated  type of e with respect to E_j,
and S_j be the instantiation-to-bound  type of e with respect to E_j,
for j ‚àà 1 .. 2
(<ref>).
Then E_1 is more specific than E_2 with respect to e
if at least one of the following conditions is satisfied:



  * E_1 is not declared in a system library,
  but E_2 is declared in a system library.

  * E_1 and E_2 are both declared in a system library,
  or neither of them is declared in a system library, and
  
  
  * T_1T_2, but not T_2T_1, or
  
  * T_1T_2, T_2T_1, and
    S_1S_2, but not S_2S_1.
  

  
    In other words, the instantiated  type determines the specificity,
    and the instantiation-to-bound  type is used as a tie breaker
    in the case where subtyping does not distinguish between the former.
  



The following examples illustrate implicit extension resolution
when multiple applicable extensions are available.



 ExtendIterable<T>  Iterable<T> {
   myForEach(void (T) f) {
     ( x  ) f(x);
  }
}
 ExtendList<T>  List<T> {
   myForEach( (T) f) {
     (int i = 0; i < length; i++) f([i]);
  }
}


 main() {
  List<int> x = [1];
  x.myForEach(print);
}



Here both of the extensions apply,
but ExtendList is more specific than ExtendIterable because
List<int>Iterable<int>.



 BestCom<T  num>  Iterable<T> { T best() {...}}
 BestList<T>  List<T> { T best() {...}}
 BestSpec  List<num> { num best() {...}}


 main() {
  List<int> x = ...;
   v = x.best();
  List<num> y = ...;
   w = y.best();
}



Here all three extensions apply to both invocations.
For x.best(), BestList is most specific,
because List<int> is a proper subtype of both
Iterable<int> and List<num>.
Hence, the type of x.best() is int.

For y.best(), BestSpec is most specific.
The instantiated  types that are compared are
Iterable<num> for BestCom and
List<num> for the two other extensions.
Using the instantiation-to-bound  types as a tie breaker,
we find that List<Object> is less precise than List<num>,
so BestSpec is selected.
Hence, the type of y.best() is num.



In general, the definition of specificity aims to select
the extension which has more precise type information available.
This does not necessarily yield the most precise type of the result
(for instance, BestSpec.best could have returned Object),
but it is also important that the rule is simple.

In practice, we expect unintended extension member name conflicts to be rare.
If the same author is providing more specialized versions of
an extension for subtypes,
the choice of an extension which has the most precise types available
is likely to be a rather unsurprising and useful behavior.





 ¬ß.¬ß Static analysis of Members of an Extension

staticAnalysisOfMembersOfAnExtension


Static analysis of the member declarations in an extension E
relies on the scopes of the extension
(<ref>)
and follows the normal rules except for the following:


When static analysis is performed on the body of an instance member
of an extension E with  type T_on,
the static type of  is T_on.


A compile-time error occurs if the body of an extension member
contains .


A lexical lookup in an extension E may yield
a declaration of an instance method declared in E.
As specified elsewhere
(<ref>),
this implies that extension instance members
will shadow class instance members
when called from another instance member inside the same extension
using an unqualified function invocation
(that is, invoking it as m() and not .m(),
<ref>).

This is the only situation where implicit invocation of
an extension member with basename ùïÄ
can succeed even if the interface of the receiver has
a member with basename ùïÄ.

On the other hand, it is consistent with the general property of Dart that
lexically enclosing declarations shadow other declarations, e.g.,
an inherited declaration can be shadowed by a global declaration.
Here is an example:



 MyUnaryNumber  List<Object> {
  bool get isEven => length.isEven;
  bool get isOdd => !isEven;
  static bool isListEven(List<Object> list) => list.isEven;
  List<Object> get first => [];
  List<Object> get smallest => first;
}



With list.isEven,
isEven resolves to the declaration in MyUnaryNumber,
given that List does not have a member with basename isEven,
and unless there are any other extensions creating a conflict.

The use of length in the declaration of isEven
is not defined in the current lexical scope,
so it is treated as .length,
because the interface of the  type List<Object> has
a length getter.

The use of isEven in isOdd resolves lexically to
the isEven getter above it,
so it is treated as MyUnaryNumber(this).isEven,
even if there are other extensions in scope
which define an isEven on List<Object>.

The use of first in smallest resolves lexically to
the first getter above it,
even though there is a member with the same basename in
the interface of .
The getter first cannot be called
in an implicit invocation from anywhere outside of MyUnaryNumber.
This is the exceptional case mentioned above,
where a member of an extension shadows
a regular instance member on .
In practice, extensions will very rarely introduce members
with the same basename as a member of its  type's interface.

An unqualified identifier id which is not in scope
is treated as .id inside instance members as usual
(<ref>).
If id is not declared by the static type of 
(the  type)
then it may be an error,
or it may be resolved using a different extension.





 ¬ß.¬ß Extension Method Closurization

extensionMethodClosurization


An extension instance method is subject to closurization
in a similar manner as class instance methods
(<ref>).


a, E, S_j, e_1
Let a be an extension application
(<ref>)
of the form E<S1m>(e_1).
Y_j, m
Let Y1m be the formal type parameters
of the extension E.

e, ùïÄ
An expression e of the form a.ùïÄ
where ùïÄ is an identifier is then known as an
extension property extraction
  extension!property extraction.
It is a compile-time error unless E declares an instance member named ùïÄ.
If said instance member is a method then
e has the static type [S_1/Y_1, ‚Ä¶, S_m/Y_m]F,
where F is the function type of said method declaration.


If ùïÄ is a getter then e is a getter invocation,
which is specified elsewhere
(<ref>).



If ùïÄ is a method then e is known as an
instance method closurization
  extension!instance method closurization
of ùïÄ on a,
and evaluation of e
(which is E<S1m>(e_1).ùïÄ)
proceeds as follows:


Evaluate e_1 to an object o.
Let u be a fresh final variable bound to o.
Then e evaluates to a function object which is equivalent to:


  * 
<XB's>
(Tp1n,{T_n+1 p_n+1 = d_1, ‚Ä¶, T_n+k p_n+k = d_k}) =>
  E<S1m>(u)
  .ùïÄ<X1s>(p1n, p_n+1: p_n+1, ‚Ä¶, p_n+k: p_n+k);

where ùïÄ declares type parameters
,
required parameters p1n,
and named parameters pn+1n+k with defaults d1k,
using null for parameters whose default value is not specified.

  * 
<XB's>
(Tp1n,[T_n+1 p_n+1 = d_1, ‚Ä¶, T_n+k p_n+k = d_k]) =>
  E<S1m>(u).ùïÄ<X1s>(p1n+k);

where ùïÄ declares type parameters
,
required parameters p1n,
and optional positional parameters
pn+1n+k with defaults d1k,
using null for parameters whose default value is not specified.



In the function literals above,
B'_j = [S_1/Y_1, ‚Ä¶, S_m/Y_m]B_j, j ‚àà 1 .. s,
and T_j = [S_1/Y_1, ‚Ä¶, S_m/Y_m]T'_j, j ‚àà 1 .. n+k,
where T'_j is the type of the corresponding parameter in
the declaration of ùïÄ.
Capture of type variables in S1m must be avoided,
so X_j must be renamed if S1m contains any occurrences of X_j,
for all j ‚àà 1 .. s.


In other words, the closurization is the value of
a function literal whose signature is the same as that of ùïÄ,
except that the actual type arguments are substituted for
the formal type parameters of E,
and then it simply forwards the invocation
to ùïÄ with the captured object u as the receiver.



Two extension instance method closurizations are never equal
unless they are identical.
Note that this differs from closurizations of class instance methods,
which are equal when they tear off the same method of the same receiver.



The reason for this difference is that even if o_1 and o_2
are instance method closurizations of the same extension E
applied to the same receiver o,
they may have different actual type arguments passed to E,
because those type arguments are determined by the call site
(and with inference: by the static type of the expression yielding o),
and not just by the properties of o and the torn-off method.



Note that an instance method closurization on an extension is not
a constant expression,
even in the case where the receiver is a constant expression.
This is because it creates a new function object each time it is evaluated.



Extension method closurization can occur for an implicit invocation
of an extension instance member.


This is a consequence of the fact that the implicit invocation is
treated as the corresponding explicit invocation
(<ref>).
For instance,
e.ùïÄ may be implicitly transformed into
E<T_1, T_2>(e).ùïÄ,
which is then handled as specified above.



Extension method closurizations are subject to generic function instantiation
(<ref>).
For example:


  int {
  Set<T> asSet<T  num>() => {if ( T)   T};
}


 main() {
  Set<double> Function() f = 1.asSet;
  print(f()); // Prints '{}'.
}



In this example {} is printed,
because the function object obtained by extension method closurization
was subject to a generic function instantiation
which gave T the value double,
which makes `    T' evaluate to false.





 ¬ß.¬ß The  Member of an Extension

theCallMemberOfAnExtension


An extension can provide a  method which is invoked implicitly,
similarly to a function expression invocation
(<ref>).


E.g., e() is treated as e.call()
when the static type of e is a non-function that has a method named .
Here is an example where the  method comes from an extension:



 E  int {
  Iterable<int> call(int to) =>
      Iterable<int>.generate(to - this + 1, (i) => this + i);
}


 main() {
   ( i  1(3)) print(i); // Prints 1, 2, 3.
   ( i  E(4)(5)) print(i); // Prints 4, 5.
}



This may look somewhat surprising,
though similar to an approach using []:
 ( i  1[3])  { ... }.
We expect developers to use this power responsibly.



a, i
Let a be an extension application
(<ref>),
and i an expression of the form

a<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)

(where the type argument list is omitted when r is zero).
i is then treated as
(<ref>)

a.<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k).


In other words, an invocation of an extension application
is immediately treated as an invocation of an extension method named .



e, S, i
Let e be an expression with static type S
which is not a property extraction expression
(<ref>),
and let i be an expression of the form

e<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)

(where the type argument list is again omitted when r is zero).
If S is , , or a function type,
or the interface of S has a method named ,
i is specified elsewhere
(<ref>).
Otherwise, if S has a non-method instance member with basename 
then i is a compile-time error.
Otherwise, i is treated as the expression i' which is

e.<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k).


Note that i' can be an implicit invocation of
an extension method named ,
and it can be an error.
In the latter case, error messages should be worded in terms of i,
not i'.



It is a compile-time error unless i' is an implicit invocation of
an extension instance method named .


In particular, i' cannot be an invocation of an extension getter
whose return type is a function type, , or .



Note that there is no support for an implicit property extraction
which tears off an extension method named .
For instance, assuming the extension E declared in the previous example:



Iterable<int> (int) from2 = 2; // Error.



The implicit property extraction could be allowed,
but it would come at a readability cost.
A type like int is well known as being non-callable,
and an implicit .call tear-off would have no visible syntax.
In an implicit  invocation, the arguments are visible to a reader,
but for an implicit tear-off of a  function,
there is no visible syntax at all.



If desired, the property extraction can be expressed explicitly
using 2..





¬ß ENUMS

enums


An enumerated type, or enum, is used to represent
a fixed number of constant values.


<enumType> ::=  <identifier>
   `' <enumEntry> (`,' <enumEntry>)* (`,')? `'

<enumEntry> ::= <metadata> <identifier>



The declaration of an enum of the form
m  E {m_0  ùïÄ_0, ‚Ä¶, m_n-1  ùïÄ_n-1}
has the same effect as a class declaration


m  E {
   int index;
   E(.index);
  m_0   E ùïÄ_0 =  E(0);
  ‚Ä¶
  m_n-1   E ùïÄ_n-1 = const E(n - 1);
    List<E> values = const <E>[ùïÄ_0, ‚Ä¶, ùïÄ_n-1];
  String toString() => { 0: `E.ùïÄ_0', ‚Ä¶, n-1: `E.ùïÄ_n-1'}[index]
}



It is also a compile-time error to subclass, mix-in or implement an enum
or to explicitly instantiate an enum.
These restrictions are given in normative form
in sections <ref>, <ref>, <ref>
and <ref> as appropriate.





¬ß GENERICS

generics


A declaration of a class (<ref>),
mixin (<ref>),
extension (<ref>),
type alias (<ref>),
or function (<ref>) G may be generic,
that is, G may have formal type parameters declared.


When an entity in this specification is described as generic,
and the special case is considered where the number of type arguments is zero,
the type argument list should be omitted.


This allows non-generic cases to be included implicitly as special cases.
For example,
an invocation of a non-generic function arises as the special case
where the function takes zero type arguments,
and zero type arguments are passed.
In this situation some operations are also omitted (have no effect), e.g.,
operations where formal type parameters are replaced by actual type arguments.



A generic class declarationclass declaration!generic
introduces a generic class into the library scope of the current library.
A generic classclass!generic
is a mapping that accepts a list of actual type arguments
and maps them to a class.
Consider a generic class declaration G named C
with formal type parameter declarations
X_1  B_1, ‚Ä¶, X_m  B_m,
and a parameterized type T of the form C<T_1, ‚Ä¶, T_l>.


It is a compile-time error if m ‚â† l.
It is a compile-time error if T is not well-bounded
(<ref>).


Otherwise, said parameterized type C<T_1, ‚Ä¶, T_m> denotes
an application of the generic class declared by G to the type arguments
T_1, ‚Ä¶, T_m.
This yields a class C' whose members are equivalent to those of
a class declaration which is obtained from the declaration G by replacing
each occurrence of X_j by T_j.


Other properties of C' such as the subtype relationships
are specified elsewhere
(<ref>).



Generic type aliases are specified elsewhere
(<ref>).



A generic typetype!generic is a type which is introduced by
a generic class declaration or a generic type alias,
or it is the type FutureOr.


A generic function declarationfunction declaration!generic
introduces a generic function (<ref>) into the current scope.


Consider a function invocation expression of the form
f<T_1, ‚Ä¶, T_l>(‚Ä¶),
where the static type of f is a generic function type
with formal type parameters
X_1  B_1, ‚Ä¶, X_m  B_m.
It is a compile-time error if m ‚â† l.
It is a compile-time error if there exists a j
such that T_j is not a subtype of [T_1/X_1, ‚Ä¶, T_m/X_m]B_j.


That is, if the number of type arguments is wrong,
or if the jth actual type argument is not a subtype of
the corresponding bound,
where each formal type parameter has been replaced by
the corresponding actual type argument.



<typeParameter> ::= <metadata> <identifier> ( <typeNotVoid>)?

<typeParameters> ::= `<' <typeParameter> (`,' <typeParameter>)* `>'



A type parameter T may be suffixed with an  clause
that specifies the upper bound for T.
If no  clause is present, the upper bound is Object.
It is a compile-time error if a type parameter is a supertype of its upper bound
when that upper bound is itself a type variable.


This prevents circular declarations like
X  X
and
X  Y, Y  X.



Type parameters are declared in the type parameter scope of a class or function.
The type parameters of a generic G are in scope in
the bounds of all of the type parameters of G.
The type parameters of a generic class declaration G are also in scope in
the  and  clauses of G (if these exist)
and in the body of G.


However, a type parameter of a generic class
is considered to be a malformed type
when referenced by a static member
(<ref>).
The scopes associated with the type parameters of a generic function
are described in (<ref>).



The restriction on static members is necessary since
a type variable has no meaning in the context of a static member,
because statics are shared among all generic instantiations of a generic class.
However, a type variable may be referenced from an instance initializer,
even though  is not available.



Because type parameters are in scope in their bounds,
we support F-bounded quantification.
This enables typechecking code such as:



 Ordered<T> {
  operator >(T x);
}

 Sorter<T  Ordered<T {
   sort(List<T> l) {... l[n] < l[n+1] ...}
}




Even where type parameters are in scope
there are numerous restrictions at this time:


  ‚àô
  A type parameter cannot be used to name a constructor in
  an instance creation expression (<ref>).

  ‚àô
  A type parameter cannot be used as a superclass or superinterface
  (<ref>, <ref>, <ref>).

  ‚àô
  A type parameter cannot be used as a generic type.


The normative versions of these are given
in the appropriate sections of this specification.
Some of these restrictions may be lifted in the future.





 ¬ß.¬ß Variance

variance


We say that a type S occurs covariantly in a type T iff
S occurs in a covariant position in T,
but not in a contravariant position,
and not in an invariant position.


We say that a type S occurs contravariantly in a type T iff
S occurs in a contravariant position in T,
but not in a covariant position,
and not in an invariant position.


We say that a type S occurs invariantly in a type T iff
S occurs in an invariant position in T,
or S occurs in a covariant position as well as a contravariant position.


We say that a type S occurs in a covariant position in a type T
iff one of the following conditions is true:



  * T is S


  * T is of the form G<S_1, ‚Ä¶, S_n>
  where G denotes a generic class
  and S occurs in a covariant position in S_j for some j ‚àà 1 .. n.


  * T is of the form
  S_0 <X_1  B_1, ‚Ä¶>(S_1 x_1, ‚Ä¶)
  where the type parameter list may be omitted,
  and S occurs in a covariant position in S_0.


  * T is of the form

  S_0 <X_1  B_1, ‚Ä¶>

    (S_1 x_1, ‚Ä¶, S_k x_k, [S_k+1 x_k+1 = d_k+1, ‚Ä¶, S_n x_n = d_n])

  or of the form

  S_0 <X_1  B_1, ‚Ä¶>

    (S_1 x_1, ‚Ä¶, S_k x_k, {S_k+1 x_k+1 = d_k+1, ‚Ä¶, S_n x_n = d_n})

  where the type parameter list and each default value may be omitted,
  and S occurs in a contravariant position in S_j
  for some j ‚àà 1 .. n.


  * T is of the form G<S_1, ‚Ä¶, S_n>
  where G denotes a generic type alias such that
  j ‚àà 1 .. n,
  the formal type parameter corresponding to S_j is covariant,
  and S occurs in a covariant position in S_j.


  * T is of the form G<S_1, ‚Ä¶, S_n>
  where G denotes a generic type alias such that
  j ‚àà 1 .. n,
  the formal type parameter corresponding to S_j is contravariant,
  and S occurs in a contravariant position in S_j.



We say that a type S occurs in a contravariant position in a type T
iff one of the following conditions is true:



  * T is of the form G<S_1, ‚Ä¶, S_n>
  where G denotes a generic class
  and S occurs in a contravariant position in S_j
  for some j ‚àà 1 .. n.


  * T is of the form
  S_0 <X_1  B_1, ‚Ä¶>(S_1 x_1, ‚Ä¶)
  where the type parameter list may be omitted,
  and S occurs in a contravariant position in S_0.


  * T is of the form

  S_0 <X_1  B_1, ‚Ä¶>

    (S_1 x_1, ‚Ä¶, S_k x_k, [S_k+1 x_k+1 = d_k+1, ‚Ä¶, S_n x_n = d_n])

  or of the form

  S_0 <X_1  B_1, ‚Ä¶>

    (S_1 x_1, ‚Ä¶, S_k x_k, {S_k+1 x_k+1 = d_k+1, ‚Ä¶, S_n x_n = d_n})

  where the type parameter list and each default value may be omitted,
  and S occurs in a covariant position in S_j
  for some j ‚àà 1 .. n.


  * T is of the form G<S_1, ‚Ä¶, S_n>
  where G denotes a generic type alias such that
  j ‚àà 1 .. n,
  the formal type parameter corresponding to S_j is covariant,
  and S occurs in a contravariant position in S_j.


  * T is of the form G<S_1, ‚Ä¶, S_n>
  where G denotes a generic type alias such that
  j ‚àà 1 .. n,
  the formal type parameter corresponding to S_j is contravariant,
  and S occurs in a covariant position in S_j.



We say that a type S occurs in an invariant position in a type T
iff one of the following conditions is true:



  * T is of the form G<S_1, ‚Ä¶, S_n>
  where G denotes a generic class or a generic type alias,
  and S occurs in an invariant position in S_j for some j ‚àà 1 .. n.


  * T is of the form

  S_0 <X_1  B_1, ‚Ä¶, X_m  B_m>

    (S_1 x_1, ‚Ä¶, S_k x_k, [S_k+1 x_k+1 = d_k+1, ‚Ä¶, S_n x_n = d_n])

  or of the form

  S_0 <X_1  B_1, ‚Ä¶, X_m  B_m>

    (S_1 x_1, ‚Ä¶, S_k x_k, {S_k+1 x_k+1 = d_k+1, ‚Ä¶, S_n x_n = d_n})

  where the type parameter list and each default value may be omitted,
  and S occurs in an invariant position in S_j
  for some j ‚àà 0 .. n,
  or S occurs in B_i
  for some i ‚àà 1 .. m.


  * T is of the form G<S_1, ‚Ä¶, S_n>
  where G denotes a generic type alias,
  j ‚àà 1 .. n,
  the formal type parameter corresponding to S_j is invariant,
  and S occurs in S_j.



Consider a generic type alias declaration G
with formal type parameter declarations
X_1  B_1, ‚Ä¶, X_m  B_m,
and right hand side T.
Let j ‚àà 1 .. m.

We say that
the formal type parameter X_j is invariant
  type parameter!invariant
iff X_j occurs invariantly in T, X_j
is covarianttype parameter!covariant
iff X_j occurs covariantly in T, and X_j
is contravarianttype parameter!contravariant
iff X_j occurs contravariantly in T.


Variance gives a characterization of the way a type varies
as the value of a subterm varies, e.g., a type variable:
Assume that T is a type where a type variable X occurs,
and L and U are types such that L is a subtype of U.
If X occurs covariantly in T
then [L/X]T is a subtype of [U/X]T.
Similarly, if X occurs contravariantly in T
then [U/X]T is a subtype of [L/X]T.
If X occurs invariantly
then [L/X]T and [U/X]T are not guaranteed
to be subtypes of each other in any direction.
In short: with covariance, the type covaries;
with contravariance, the type contravaries;
with invariance, all bets are off.





 ¬ß.¬ß Super-Bounded Types

superBoundedTypes


This section describes how
the declared upper bounds of formal type parameters are enforced,
including some cases where a limited form of violation is allowed.


A top type is a type T such that Object is a subtype of T.

For instance, Object, , and  are top types,
and so are FutureOr<> and FutureOr<FutureOr<>>.










Every type which is not a parameterized type is regular-bounded.


In particular, every non-generic class and every function type
is a regular-bounded type.



Let T be a parameterized type of the form
G<S_1, ‚Ä¶, S_n>
where G denotes a generic class or a generic type alias.
Let
X_1  B_1, ‚Ä¶, X_n  B_n
be the formal type parameter declarations of G.
T is regular-bounded iff
S_j is a subtype of
[S_1/X_1, ‚Ä¶, S_n/X_n]B_j,
for all j ‚àà 1 .. n.


This means that regular-bounded types are those types
that do not violate their type parameter bounds.



Let T be a parameterized type of the form
G<S_1, ‚Ä¶, S_n>
where G denotes a generic class or a generic type alias.
T is super-bounded iff the following conditions are both true:



  * T is not regular-bounded.

  * Let T' be the result of replacing every occurrence in T
  of a top type in a covariant position by Null,
  and every occurrence in T
  of Null in a contravariant position by Object.
  It is then required that T' is regular-bounded.
  
  Moreover, if G denotes a generic type alias with body U,
  it is required that every type that occurs as a subterm of
  [S_1/X_1, ‚Ä¶, S_n/X_n]U
  is well-bounded (defined below).



In short, at least one type argument violates its bound, but the type is
regular-bounded after replacing all occurrences of an extreme type by an
opposite extreme type, depending on their variance.



A type T is well-bounded iff
it is either regular-bounded or super-bounded.


Any use of a type T which is not well-bounded is a compile-time error.


It is a compile-time error if a parameterized type T is super-bounded
when it is used in any of the following ways:


  * T is an immediate subterm of a new expression
  (<ref>)
  or a constant object expression
  (<ref>).

  * T is an immediate subterm of a redirecting factory constructor
  signature
 (<ref>).

  * T is an immediate subterm of an  clause of a class
  (<ref>),
  or it occurs as an element in the type list of an  clause
  
  (<ref>, <ref>, <ref>),
  or a  clause
  (<ref>, <ref>),
  or it occurs as an element in the type list of an  clause of a mixin
  (<ref>).



It is not an error if a super-bounded type occurs
as an immediate subterm of an  clause
that specifies the bound of a type variable
(<ref>).



Types of members from super-bounded class types are computed using the same
rules as types of members from other types. Types of function applications
involving super-bounded types are computed using the same rules as types of
function applications involving other types. Here is an example:



 A<X  num> {
  X x;
}


A<Object> a;



With this, a.x has static type Object,
even though the upper bound on the type variable X is num.



Super-bounded types enable the expression of informative common supertypes
of some sets of types whose common supertypes
would otherwise be much less informative.



For example, consider the following class:



 C<X  C<X>> {
  X next;
}



Without super-bounded types,
there is no type T which makes C<T> a common supertype of
all types of the form C<S>
(noting that all types must be regular-bounded
when we do not have the notion of super-bounded types).
So if we wish to allow a variable to hold any instance ‚Äúof type C‚Äù
then that variable must use Object or another top type
as its type annotation,
which means that a member like next is not known to exist
(which is what we mean by saying that the type is `less informative').



We could introduce a notion of recursive (infinite) types, and express
the least upper bound of all types of the form C<S> as
some syntax whose meaning could be approximated by
C<C<C<C<‚Ä¶>>>>.

However, we expect that any such concept in Dart would incur a significant cost
on developers and implementations in terms of added complexity and subtlety,
so we have chosen not to do that.
Super-bounded types are finite,
but they offer a useful developer-controlled approximation
to such infinite types.



For example,
C<Object> and
C<C<C<>>>
are types that a developer may choose to use as a type annotation.
This choice serves as a commitment to
a finite level of unfolding of the infinite type,
and it allows for a certain amount of control
at the point where the unfolding ends:

If c has type C<C<>>
then c.next.next has type 
and c.next.next.whatever has no compile-time error,
but if c has type C<C<>> then already
Object x = c.next.next; is a compile-time error.
It is thus possible for developers to get a more or less strict treatment
of expressions whose type proceeds beyond the given finite unfolding.





 ¬ß.¬ß Instantiation to Bound

instantiationToBound


This section describes how to compute type arguments
that are omitted from a type,
or from an invocation of a generic function.










Note that type inference is assumed to have taken place already
(<ref>),
so type arguments are not considered to be omitted if they are inferred.
This means that instantiation to bound is a backup mechanism,
which will be used when no information is available for inference.



Consider the situation where a term t of the form typeName
denotes a generic type declaration,
and it is used as a type or as an expression in the enclosing program.

This implies that type arguments are accepted, but not provided.

We use the phrase
raw type respectively raw type expression
to identify such terms.
In the following we only mention raw types,
but everything said about raw types
applies to raw type expressions in the obvious manner.


For instance, with the declaration Type listType() => List;,
evaluation of the raw type expression List in the body yields
an instance of class Type reifying List<dynamic>,
because List is subject to instantiation to bound.
Note that List<dynamic> is not syntactically an expression,
but it is still possible to get access to
a Type instance reifying List<dynamic>
without instantiation to bound,
because it can be the value of a type variable.



We can unambiguously define raw types to denote
the result of applying the generic type
to a list of implicitly provided actual type arguments,
and instantiation to bound is a mechanism which does just that.
This is because Dart does not, and will not, support higher-kinded types;
for example, the value of a type variable X will be a type,
it cannot be the generic class List as such,
and it cannot be applied to type arguments, e.g., X<int>.



In the typical case where only covariance is encountered,
instantiation to bound will yield a supertype of
all the regular-bounded types that can be expressed.
This allows developers to consider a raw type as a type
which is used to specify that
‚Äúthe actual type arguments do not matter‚Äù.


For example, assuming the declaration
 C<X extends num> {‚Ä¶},
instantiation to bound on C yields C<num>,
and this means that C x; can be used to declare a variable x
whose value can be a C<T> for all possible values of T.



Conversely, consider the situation where
a generic type alias denotes a function type,
and it has one type parameter which is contravariant.
Instantiation to bound on that type alias will then yield a subtype of
all the regular-bounded types that can be expressed
by varying that type argument.
This allows developers to consider such a type alias used as a raw type
as a function type which allows the function to be passed to clients
‚Äúwhere it does not matter which values
for the type argument the client expects‚Äù.


E.g., with
 F<X> = (X);
instantiation to bound on F yields F<dynamic>,
and this means that F f; can be used to declare a variable f
whose value will be a function that can be passed to clients expecting
an F<T> for all possible values of T.





  ¬ß.¬ß.¬ß Auxiliary Concepts for Instantiation to Bound

auxiliaryConceptsForInstantiationToBound


Before we specify instantiation to bound
we need to define two auxiliary concepts.
Let T be a raw type.
A type S then
raw-depends onraw-depends on!type
T if one or more of the following conditions hold:



  * S is of the form typeName, and S is T.
  
  Note that this case is not applicable
  if S is a subterm of a term of the form
  S <typeArguments>,
  that is,
  if S receives any type arguments.
  Also note that S cannot be a type variable,
  because then `S is T' cannot hold.
  See the discussion below and the reference to¬†<ref>
  for more details about why this is so.
  

  * S is of the form <typeName> <typeArguments>,
  and one of the type arguments raw-depends on T.

  * S is of the form <typeName> <typeArguments>? where
  typeName denotes a type alias F,
  and the body of F raw-depends on T.

  * S is of the form
  <type>?  <typeParameters>? <parameterTypeList> and
  <type>? raw-depends on T,
  or a bound in <typeParameters>? raw-depends on T,
  or a type in parameterTypeList raw-depends on T.



Meta-variables
(<ref>)
like S and T are understood to denote types,
and they are considered to be equal (as in `S is T')
in the same sense as in the section about subtype rules
(<ref>).

In particular,
even though two identical pieces of syntax may denote two distinct types,
and two different pieces of syntax may denote the same type,
the property of interest here is whether they denote the same type
and not whether they are spelled identically.

The intuition behind the situation where a type raw-depends on another type is
that we need to compute any missing type arguments for the latter
in order to be able to tell what the former means.

In the rule about type aliases, F may or may not be generic,
and type arguments may or may not be present.
However, there is no need to consider the result of substituting
actual type arguments for formal type parameters in the body of F
(or even the correctness of passing those type arguments to F),
because we only need to inspect
all types of the form typeName in its body,
and they are not affected by such a substitution.
In other words, raw-dependency is a relation
which is simple and cheap to compute.



Let G be a generic class or a generic type alias
with k formal type parameter declarations
containing formal type parameters X1k and bounds B1k.
For any j ‚àà 1 .. k,
we say that the formal type parameter X_j has a simple bound
when one of the following requirements is satisfied:



  * B_j is omitted.


  * B_j is included, but does not contain any of X1k.
  If B_j raw-depends on a raw type T
  then every type parameter of T must have a simple bound.



The notion of a simple bound must be interpreted inductively rather than
coinductively, i.e., if a bound B_j of a generic class or
generic type alias G is reached during an investigation of whether
B_j is a simple bound, the answer is no.


For example, with
 C<X  C> {},
the type parameter X does not have a simple bound:
A raw C is used as a bound for X,
so C must have simple bounds,
but one of the bounds of C is the bound of X,
and that bound is C, so C must have simple bounds:
That was a cycle, so the answer is ‚Äúno‚Äù,
C does not have simple bounds.



Let G be a generic class or a generic type alias.
We say that G
has simple boundstype!generic, has simple bounds
iff every type parameter of G has simple bounds.


We can now specify in which sense instantiation to bound requires
the involved types to be "simple enough".
We impose the following constraint on all type parameter bounds,
because all type parameters may be subject to instantiation to bound.



It is a compile-time error
if a formal type parameter bound B contains a raw type T,
unless T has simple bounds.


So type arguments on bounds can only be omitted
if they themselves have simple bounds.
In particular,
 C<X  C> {}
is a compile-time error,
because the bound C is raw,
and the formal type parameter X
that corresponds to the omitted type argument
does not have a simple bound.



Let T be a type of the form typeName
which denotes a generic class or a generic type alias
(so T is raw).
Then T is equivalent to the parameterized type which is
the result obtained by applying instantiation to bound to T.
It is a compile-time error if the instantiation to bound fails.


This rule is applicable for all occurrences of raw types,
e.g., when it occurs as a type annotation of a variable or a parameter,
as a return type of a function,
as a type which is tested in a type test,
as the type in an onPart,
etc.





  ¬ß.¬ß.¬ß The Instantiation to Bound Algorithm

theInstantiationToBoundAlgorithm


We now specify how the
instantiation to bound
algorithm proceeds.
Let T be a raw type.
Let X1k be the formal type parameters in the declaration of G,
and let B1k be their bounds.
For each i ‚àà 1 .. k,
let S_i denote the result of instantiation to bound on B_i;
in the case where the ith bound is omitted, let S_i be .


If B_i for some i is raw (in general: if it raw-depends on some type U)
then all its (respectively U's) omitted type arguments have simple bounds.
This limits the complexity of instantiation to bound for B_i,
and in particular it cannot involve a dependency cycle
where we need the result from instantiation to bound for G
in order to compute the instantiation to bound for G.



Let U_i,0 be S_i, for all i ‚àà 1 .. k.

This is the "current value" of the bound for type variable i, at step 0;
in general we will consider the current step, m, and use data for that step,
e.g., the bound U_i,m, to compute the data for step m + 1.


 





Let  be a relation among the type variables
X1k such that
X_p  X_q iff X_q occurs in U_p,m.

So each type variable is related to, that is, depends on,
every type variable in its bound, which might include itself.

Let  be the transitive
(but not reflexive)
closure of .
For each m, let U_i,m+1, for i ‚àà 1 .. k,
be determined by the following iterative process, where V_m denotes
G<U_1,m, ‚Ä¶, U_k,m>:



  1.
  If there exists a j ‚àà 1 .. k such that
  X_j  X_j
  (that is, if the dependency graph has a cycle)
  let M1p be the strongly connected components (SCCs)
  with respect to .
  
  That is, the maximal subsets of X1k
  where every pair of variables in each subset
  are related in both directions by ;
  note that the SCCs are pairwise disjoint;
  also, they are uniquely defined up to reordering,
  and the order does not matter for this algorithm.
  
  Let M be the union of M1p
  (that is, all variables that participate in a dependency cycle).
  Let i ‚àà 1 .. k.
  If X_i does not belong to M then U_i,m+1 is U_i,m.
  Otherwise there exists a q such that X_i ‚àà M_q;
  U_i,m+1 is then obtained from U_i,m
  by substituting  for every occurrence of a variable in M_q
  that is in a position in V_m which is not contravariant,
  and substituting Null for every occurrence of a variable in M_q
  which is in a contravariant position in V_m.


  2.
  Otherwise (when there are no dependency cycles),
  let j be the lowest number such that X_j occurs in U_p,m for some p
  and X_j ‚Üõ_m X_q for all q in 1 .. k
  (
  that is, the bound of X_j does not contain any type variables,
  but X_j occurs in the bound of some other type variable
  ).
  Then, for all i ‚àà 1 .. k,
  U_i,m+1 is obtained from U_i,m
  by substituting U_j,m for every occurrence of X_j
  that is in a position in V_m which  is not contravariant,
  and substituting Null for every occurrence of X_j
  which is in a contravariant position in V_m.


  3.
  Otherwise (when there are no dependencies at all),
  terminate with the result <U_1,m, ‚Ä¶, U_k,m>.



This process will always terminate, because the total number of
occurrences of type variables from { X1k } in
the current bounds is strictly decreasing with each step, and we terminate
when that number reaches zero.



It may seem somewhat arbitrary to treat unused and invariant parameters
in the same way as covariant parameters,
in particular because invariant parameters fail to satisfy the expectation that
a raw type denotes a supertype of all the expressible regular-bounded types.

We could easily have made every instantiation to bound an error
when applied to a type where invariance occurs anywhere
during the run of the algorithm.
However, there are a number of cases where this choice produces a usable type,
and we decided that it is not helpful to outlaw such cases.



 Inv<X> = X (X);
 B<Y  num, Z  Inv<Y>> {}


B b; // The raw B means B<num, Inv<num>>.



For example, the value of b can have dynamic type
B<int, int (num)>.
However, the type arguments have to be chosen carefully,
or the result will not be a subtype of B.
For instance, b cannot have dynamic type
B<int, Inv<int>>,
because Inv<int> is not a subtype of Inv<num>.



A raw type T is a compile-time error if instantiation to bound on T
yields a type which is not well-bounded
(<ref>).


This kind of error can occur, as demonstrated by the following example:



 C<X  C<X>> {}
 F<X  C<X>> = X (X);


F f; // Compile-time error.



With these declarations,
the raw F which is used as a type annotation is a compile-time error:
The algorithm yields F<C<>>,
and that is neither a regular-bounded nor a super-bounded type.

The resulting type can be specified explicitly as
C<> (C<>).
That type exists,
we just cannot express it by passing a type argument to F,
so we make it an error rather than allowing it implicitly.



The core reason why it makes sense to make such a raw type an error
is that there is no subtype relationship
between the relevant parameterized types.


For instance, F<T1> and F<T2> are unrelated,
even when T1T2 or vice versa.
In fact, there is no type T whatsoever
such that a variable with declared type F<T>
could be assigned to a variable of type
C<> (C<>).

So the raw F, if permitted,
would not be ‚Äúa supertype of F<T> for all possible T‚Äù,
it would be a type which is unrelated to F<T>
for every single T that satisfies the bound of F.
This is so useless that we made it an error.



When instantiation to bound is applied to a type, it proceeds recursively:
For a parameterized type G<T1k>
it is applied to T1k.
For a function type
T_0

and a function type
T_0
it is applied to T0n+k.


This means that instantiation to bound has no effect on
a type that does not contain any raw types.
Conversely, instantiation to bound acts on types which are syntactic subterms,
also when they are deeply nested.



Instantiation to bound on a generic function f
  generic function!instantiation to bound
also uses the algorithm described above,
taking the formal parameters X1k from the declaration of f,
with bounds B1k, and,
for each i ‚àà 1 .. k,
letting S_i denote the result of instantiation to bound on B_i,
and letting S_i be  when the ith bound is omitted.


Let f be a generic function declaration.
If instantiation to bound on f yields
a list of type arguments T1k such that,
for some j ‚àà 1..k,
T_j is or contains a type which is not well-bounded,
or if T1k does not satisfy the bounds
on the formal type parameters of f,
then we say that
f does not have default type arguments
  generic function!does not have default type arguments.




¬ß METADATA

metadata


Dart supports metadata which is used to attach
user defined annotations to program structures.


<metadata> ::= (`@' <metadatum>)*

<metadatum> ::= 
  <identifier> | <qualifiedName> | <constructorDesignation> <arguments>



Metadata consists of a series of annotations,
each of which begin with the character @,
followed by a constant expression e derivable from
metadatum.
It is a compile-time error if e is not one of the following:


  * A reference to a constant variable.

  * A call to a constant constructor.



The expression e occurs in a constant context
(<ref>),
which means that  modifiers need not be specified explicitly.



Metadata that occurs as the first element of
the right hand side of a grammar rule
is associated with the abstract syntax tree for the non-terminal
on the left hand side of said grammar rule
(that is, it is associated with its parent).
Otherwise, metadata is associated with the abstract syntax tree
of the program construct p that immediately follows the metadata
in the grammar rule.


These rules are intended to ensure a minimal level of consistency
in the association that binds each metadatum to a program construct.
The structure of the abstract syntax tree is implementation specific,
and it is not even guaranteed that a tool will use anything
which is known as an abstract syntax tree.
In that case the phrase `abstract syntax tree' should be interpreted as
the program representation entities which are actually used.

This implies that the fine details of the association between metadata
and an abstract syntax tree node is also implementation specific.
In particular, an implementation can choose to associate a given metadatum
with more than one abstract syntax tree node.



Metadata can be retrieved at run time via a reflective call,
provided the annotated program construct p is accessible via reflection.


Obviously, metadata can also be retrieved statically by
parsing the program and evaluating the constants via a suitable interpreter.
In fact, many if not most uses of metadata are entirely static.
In this case the binding of each metadatum to an abstract syntax tree node
is determined by the given static analysis tool,
which is of course not subject to any constraints in this document.
Surely it will still be useful to strive for consistency among all tools
with respect to the binding from metadata to abstract syntax tree nodes.



It is important that no run-time overhead be incurred by
the introduction of metadata that is not actually used.
Because metadata only involves constants,
the time at which it is computed is irrelevant.
So implementations may skip the metadata during ordinary parsing and execution,
and evaluate it lazily.



It is possible to associate metadata with constructs
that may not be accessible via reflection,
such as local variables
(though it is conceivable that in the future,
richer reflective libraries might provide access to these as well).
This is not as useless as it might seem.
As noted above, the data can be retrieved statically
if source code is available.



Metadata can appear before a library, part header, class,
typedef, type parameter, constructor, factory, function,
parameter, or variable declaration,
and before an import, export, or part directive.


The constant expression given in an annotation is type checked and evaluated
in the scope surrounding the declaration being annotated.




¬ß EXPRESSIONS

expressions


An expression is a fragment of Dart code
that can be evaluated at run time.


Every expression has an associated static type (<ref>) and
may have an associated static context type


which may affect the static type and evaluation of the expression.
Every object has an associated dynamic type (<ref>).







<expression> ::= <assignableExpression> <assignmentOperator> <expression>
  <conditionalExpression>
  <cascade>
  <throwExpression>

<expressionWithoutCascade> ::= 
  <assignableExpression> <assignmentOperator> <expressionWithoutCascade>
  <conditionalExpression>
  <throwExpressionWithoutCascade>

<expressionList> ::= <expression> (`,' <expression>)*

<primary> ::= <thisExpression>
   <unconditionalAssignableSelector>
   <argumentPart>
  <functionExpression>
  <literal>
  <identifier>
  <newExpression>
  <constObjectExpression>
  <constructorInvocation>
  `(' <expression> `)'

<literal> ::= <nullLiteral>
  <booleanLiteral>
  <numericLiteral>
  <stringLiteral>
  <symbolLiteral>
  <listLiteral>
  <setOrMapLiteral>



An expression e may always be enclosed in parentheses,
but this never has any semantic effect on e.


However, it may have an effect on the surrounding expression.
For instance, given a class C with a static method
m() => 42, C.m() returns 42,
but (C).m() is a compile-time error.

The point is that the meaning of C.m()
is specified in terms of several parts,
rather than being specified in a strictly compositional manner.
Concretely, the meaning of C and (C) as expressions is the same,
but the meaning of C.m() is not defined in terms of
the meaning of C as an expression,
and it differs from the meaning of (C).m().













 ¬ß.¬ß Expression Evaluation

expressionEvaluation


Evaluation of an expression either
produces an objectexpression!produces an object
or it
throwsexpression!throws
an exception object and an associated stack trace.
In the former case, we also say that the expression
evaluates to an object.


If evaluation of one expression, e,
is defined in terms of evaluation of another expression e_1,
typically a subexpression of e,
and the evaluation of e_1 throws an exception and a stack trace,
the evaluation of e stops at that point
and throws the same exception object and stack trace.




 ¬ß.¬ß Object Identity

objectIdentity


The predefined Dart function identical()
is defined such that identical(c_1, c_2) iff:


  * c_1 evaluates to either the null object (<ref>)
  or an instance of bool and c_1 == c_2, OR

  * c_1 and c_2 are instances of int and c_1 == c_2, OR

  * c_1 and c_2 are constant strings and c_1 == c_2, OR

  * c_1 and c_2 are instances of double
  and one of the following holds:
  
  
  * c_1 and c_2 are non-zero and c_1 == c_2.
  
  * Both c_1 and c_2 are +0.0.
  
  * Both c_1 and c_2 are -0.0.
  
  * Both c_1 and c_2 represent a NaN value
    with the same underlying bit pattern.
  
 OR

  * c_1 and c_2 are constant lists that are defined to be identical
  in the specification of literal list expressions (<ref>), OR

  * c_1 and c_2 are constant maps that are defined to be identical
  in the specification of literal map expressions (<ref>), OR

  * c_1 and c_2 are constant objects of the same class C
  and the value of each instance variable of c_1 is identical to
  the value of the corresponding instance variable of c_2. OR

  * c_1 and c_2 are the same object.



The definition of identity for doubles differs from that of equality
in that a NaN is identical to itself,
and that negative and positive zero are distinct.



The definition of equality for doubles is dictated by the IEEE 754 standard,
which posits that NaNs do not obey the law of reflexivity.
Given that hardware implements these rules,
it is necessary to support them for reasons of efficiency.

The definition of identity is not constrained in the same way.
Instead, it assumes that bit-identical doubles are identical.

The rules for identity make it impossible for a Dart programmer
to observe whether a boolean or numerical value is boxed or unboxed.





 ¬ß.¬ß Constants

constants


All usages of 'constant' in Dart are associated with compile time.
A potentially constant expression is an expression that will generally yield
a constant value when the values of certain parameters are given.
The constant expressions is a subset of the potentially constant expressions
that can be evaluated at compile time.



The constant expressions are restricted to expressions that
perform only simple arithmetic operations, boolean conditions,
and string and instance creation.
No user-written function body is executed
during constant expression evaluation,
only members of the system classes
Object, bool, int, double,
String, Type, Symbol, or Null.



The potentially constant expressions
  potentially constant expression
and constant expressionsconstant expression
are the following:



  * A literal boolean,  or  (<ref>),
  is a potentially constant and constant expression.


  * A literal number (<ref>) is
  a potentially constant and constant expression
  if it evaluates to an instance of type int or double.
  


  * A literal string (<ref>) with string interpolations
  (<ref>)
  with expressions e_1, ‚Ä¶, e_n is a potentially constant expression
  if e_1, ‚Ä¶, e_n are potentially constant expressions.
  The literal is further a constant expression
  if e_1, ‚Ä¶, e_n are constant expressions
  evaluating to instances of int, double,
  String, bool, or Null.
  
    These requirements hold trivially
    if there are no interpolations in the string.
  
  
    It would be tempting to allow string interpolation where the
    interpolated value is any compile-time constant.
    However, this would require running the toString() method
    for constant objects,
    which could contain arbitrary code.
  


  * A literal symbol (<ref>) is
  a potentially constant and constant expression.


  * The literal  (<ref>) is
  a potentially constant and constant expression.


  * An identifier that denotes a constant variable is
  a potentially constant and constant expression.


  * A qualified reference to a static constant variable
  (<ref>)
  that is not qualified by a deferred prefix,
  is a potentially constant and constant expression.
  
    For example, if class C declares a constant static variable v,
    C.v is a constant.
    The same is true if C is accessed via a prefix p;
    p.C.v is a constant unless p is a deferred prefix.
  


  * A simple or qualified identifier denoting a class,
  a mixin or a type alias that is not qualified by a deferred prefix,
  is a potentially constant and constant expression.
  
    The constant expression always evaluates to a Type object.
    For example, if C is the name of a class or type alias,
    the expression C is a constant,
    and if C is imported with a prefix p, p.C is
    a constant Type instance representing the type of C
    unless p is a deferred prefix.
  


  * Let e be a simple or qualified identifier denoting
  a top-level function (<ref>)
  or a static method (<ref>)
  that is not qualified by a deferred prefix.
  If e is not subject to generic function instantiation
  (<ref>)
  then e is a potentially constant and constant expression.
  If generic function instantiation does apply to e
  and the provided actual type arguments are T1s
  then e is a potentially constant and constant expression
  iff each T_j, j ‚àà 1 .. s, is a constant type expression
  (<ref>).


  * An identifier expression denoting a parameter of a constant constructor
  (<ref>)
  that occurs in the initializer list of the constructor,
  is a potentially constant expression.


  * A constant object expression (<ref>),
   C<T_1, ‚Ä¶, T_k>(arguments) or
   C<T_1, ‚Ä¶, T_k>.ùïÄ(arguments),
  or either expression without the leading  that occurs in
  a constant context,
  is a potentially constant expression.
  It is further a constant expression if the invocation evaluates to an object.
  
  
  
  It is a compile-time error if a constant object expression is
  not a constant expression (<ref>).


  * A constant list literal (<ref>),
   <T>[e_1, ‚Ä¶, e_n], or
  <T>[e_1, ‚Ä¶, e_n]
  that occurs in a constant context,
  is a potentially constant expression if T is a constant type expression,
  and e_1, ‚Ä¶ , e_n are constant expressions.
  It is further a constant expression
  if the list literal evaluates to an object.


  * A constant set literal (<ref>),
   <T>{e_1, ‚Ä¶, e_n}, or
  <T>{e_1, ‚Ä¶, e_n}
  that occurs in a constant context,
  is a potentially constant expression
  if T is a constant type expression,
  and e_1, ‚Ä¶ , e_n are constant expressions.
  It is further a constant expression
  if the set literal evaluates to an object.


  * A constant map literal (<ref>),
   <K, V>{k_1: v_1, ‚Ä¶, k_n: v_n}, or
  <K, V>{k_1: v_1, ‚Ä¶, k_n: v_n}
  that occurs in a constant context,
  is a potentially constant expression.
  It is further a constant expression
  if the map literal evaluates to an object.


  * A parenthesized expression (e) is
  a potentially constant expression
  if e is a potentially constant expression.
  It is further a constant expression if e is a constant expression.


  * An expression of the form identical(e_1, e_2) is
  a potentially constant expression
  if e_1 and e_2 are potentially constant expressions
  and identical is statically bound to
  the predefined dart function identical() discussed above
  (<ref>).
  It is further a constant expression
  if e_1 and e_2 are constant expressions.


  * An expression of the form e_1 != e_2 is
  equivalent to !(e_1 == e_2) in every way,
  including whether it is potentially constant or constant.


  * An expression of the form e_1 == e_2 is potentially constant
  if e_1 and e_2 are both potentially constant expressions.
  It is further constant if both e_1 and e_2 are constant, and
  either e_1 evaluates to an instance of double
  or an instance that that has primitive equality
  (<ref>),
  or e_2 evaluates to the null object
  (<ref>).


  * An expression of the form !e_1 is potentially constant
  if e_1 is potentially constant.
  It is further constant if e_1 is a constant expression that evaluates to
  an instance of type bool.


  * An expression of the form e_1 && e_2 is
  potentially constant if e_1 and e_2
  are both potentially constant expressions.
  It is further constant if e_1 is a constant expression and either
  
  
  * e_1 evaluates to , or
  
  * e_1 evaluates to  and e_2 is a constant expression
    that evaluates to an instance of type bool.
  


  * An expression of the form e_1 || e_2 is
  potentially constant if e_1 and e_2
  are both potentially constant expressions.
  It is further constant if e_1 is a constant expression and either
  
  
  * e_1 evaluates to , or
  
  * e_1 evaluates to  and e_2 is a constant expression
    that evaluates to an instance of type bool.
  


  * An expression of the form e_1 is
  a potentially constant expression
  if e_1 is a potentially constant expression.
  It is further a constant expression if e_1 is
  a constant expression that evaluates to an instance of type int
  such that  denotes an instance operator invocation.


  * An expression of one of the forms e_1 & e_2,
  e_1 | e_2, or e_1 e_2 is potentially constant
  if e_1 and e_2 are both potentially constant expressions.
  It is further constant if both e_1 and e_2 are constant expressions that
  both evaluate to instances of int,
  or both to instances of bool,
  such that the operator symbol
  &, |, respectively 
  denotes an instance operator invocation.


  * An expression of one of the forms
  e_1  e_2, e_1  e_2,
  or e_1  e_2 is potentially constant
  if e_1 and e_2 are both potentially constant expressions.
  It is further constant if both e_1 and e_2 are constant expressions that
  both evaluate to an instance of int,
  such that the operator symbol
  , , respectively 
  denotes an instance operator invocation.


  * An expression of the form e_1 + e_2 is
  a potentially constant expression if e_1 and e_2
  are both potentially constant expressions.
  It is further a constant expression
  if both e_1 and e_2 are constant expressions
  and either both evaluate to an instance of int or double,
  or both evaluate to an instance of String,
  such that + denotes an instance operator invocation.


  * An expression of the form -e_1 is a potentially constant expression
  if e_1 is a potentially constant expression.
  It is further a constant expression if e_1 is a constant expression that
  evaluates to an instance of type int or double,
  such that - denotes an instance operator invocation.


  * An expression of the form e_1 - e_2, e_1 * e_2,
  e_1 / e_2,e_1 / e_2, e_1 % e_2,
  e_1 < e_2, e_1 <= e_2, e_1 > e_2, or
  e_1 >= e_2
  is potentially constant
  if e_1 and e_2 are both potentially constant expressions.
  It is further constant if both e_1 and e_2 are constant expressions that
  evaluate to instances of int or double,
  such that the given operator symbol denotes
  an invocation of an instance operator.


  * An expression of the form e_1 ? e_2 : e_3
  is potentially constant if e_1, e_2, and e_3
  are all potentially constant expressions.
  It is constant if e_1 is a constant expression and either
  
  
  * e_1 evaluates to  and e_2 is a constant expression, or
  
  * e_1 evaluates to  and e_3 is a constant expression.
  


  * An expression of the form e_1 ?? e_2 is potentially constant
  if e_1 and e_2 are both potentially constant expressions.
  It is further constant if e_1 is a constant expression and either
  
  
  * e_1 evaluates to an object which is not the null object, or
  
  * e_1 evaluates to the null object, and e_2 is a constant expression.
  


  * An expression of the form e.length is potentially constant
  if e is a potentially constant expression.
  It is further constant if e is a constant expression that
  evaluates to an instance of String,
  such that length denotes an instance getter invocation.


  * An expression of the form e  as  T is potentially constant
  if e is a potentially constant expression
  and T is a constant type expression,
  and it is further constant if e is constant.
  
    It is a compile-time error to evaluate the constant expression
    if the cast operation would throw, that is,
    if e evaluates to an object which is not the null object
    and not of type T.
  


  * An expression of the form e  is  T is potentially constant
  if e is a potentially constant expression
  and T is a constant type expression,
  and it is further constant if e is constant.


  * An expression of the form e  is!  T
  is equivalent to !(e  is  T) in every way,
  including whether it's potentially constant or constant.



A
constant type expression
is one of:


  * An simple or qualified identifier
  denoting a type declaration (a type alias, class or mixin declaration)
  that is not qualified by a deferred prefix,
  optionally followed by type arguments of the form
  <T_1, ‚Ä¶, T_n>
  where T_1, ‚Ä¶, T_n are constant type expressions.

  * A type of the form FutureOr<T>
  where T is a constant type expression.

  * 
  
  
  
  A function type
  R Function<typeParameters>(argumentTypes)
  (where R and <typeParameters> may be omitted)
  and where R, typeParameters and argumentTypes
  (if present) contain only constant type expressions.

  * The type .

  * The type .















It is a compile-time error if an expression is required to be
a constant expression,
but its evaluation would throw an exception.
It is a compile-time error if an assertion is evaluated as part of
a constant object expression evaluation,
and the assertion would throw an exception.


It is a compile-time error if the value of a constant expression
depends on itself.


As an example, consider:



 CircularConsts {
  // Illegal program - mutually recursive compile-time constants
    i = j; // a compile-time constant
    j = i; // a compile-time constant
}





  ¬ß.¬ß.¬ß Further Remarks on Constants and Potential Constants

furtherCommentsOnConstantsAndPotentiallyConstants


There is no requirement that
every constant expression evaluate correctly.
Only when a constant expression is required
(e.g., to initialize a constant variable,
or as a default value of a formal parameter,
or as metadata)
do we insist that a constant expression actually
be evaluated successfully at compile time.



The above is not dependent on program control-flow.
The mere presence of a required compile-time constant
whose evaluation would fail within a program is an error.
This also holds recursively:
since compound constants are composed out of constants,
if any subpart of a constant would throw an exception when evaluated,
that is an error.
On the other hand, since implementations are free to compile code late,
some compile-time errors may manifest quite late:



 x = 1 / 0;
 y = 1 / 0;


 K {
  m1() {
     z = ;
     (z) {  x; }
     {  2; }
  }


  m2() {
     () {  y; }
     {  3; }
  }
}



An implementation is free to immediately issue a compilation error for x,
but it is not required to do so.
It could defer errors if it does not immediately compile
the declarations that reference x.
For example, it could delay giving a compilation error
about the method m1 until the first invocation of m1.
However, it could not choose to execute m1,
see that the branch that refers to x is not taken,
and return 2 successfully.

The situation with respect to an invocation of m2 is different.
Because y is not a compile-time constant (even though its value is),
one need not give a compile-time error upon compiling m2.
An implementation may run the code,
which will cause the getter for y to be invoked.
At that point, the initialization of y must take place,
which requires the initializer to be compiled,
which will cause a compilation error.



The treatment of  merits some discussion.
Consider  + 2.
This expression always causes an error.
We could have chosen not to treat it as a constant expression
(and in general, not to allow  as
a subexpression of numeric or boolean constant expressions).
There are two arguments for including it:
First, it is constant so we can evaluate it at compile time.
Second, it seems more useful to give
the error stemming from the evaluation explicitly.



One might reasonably ask why
e_1 ?  e_2 : e_3 and e_1 ??  e_2
have constant forms.
If e_1 is known statically, why do we need to test it?
The answer is that there are contexts where e_1 is a variable,
e.g., in constant constructor initializers such as
 C(foo): .foo = foo ?? someDefaultValue;



The difference between
a potentially constant expression and a constant expression
deserves some explanation.
The key issue is how one treats the formal parameters of a constructor.

If a constant constructor is invoked from a constant object expression,
the actual arguments will be required to be constant expressions.
Therefore, if we were assured that
constant constructors were always invoked from constant object expressions,
we could assume that the formal parameters of a constructor were
compile-time constants.

However, constant constructors can also be invoked from
ordinary instance creation expressions (<ref>),
and so the above assumption is not generally valid.

Nevertheless, the use of the formal parameters of a constant constructor
is of considerable utility.
The concept of potentially constant expressions is introduced to facilitate
limited use of such formal parameters.
Specifically, we allow the usage of
the formal parameters of a constant constructor
for expressions that involve built-in operators,
but not for constant objects, lists and maps.
For instance:



 C {
   x, y, z;
   C(p, q): x = q, y = p + 100, z = p + q;
}



The assignment to x is allowed under the assumption
that q is constant
(even though q is not, in general a compile-time constant).
The assignment to y is similar, but raises additional questions.
In this case, the superexpression of p is p + 100,
and it requires that p be a numeric constant expression
for the entire expression to be considered constant.
The wording of the specification allows us to assume
that p evaluates to an integer,
for an invocation of this constructor in a constant expression.
A similar argument holds for p and q
in the assignment to z.

However, the following constructors are disallowed:



 D {
   w;
   D.makeList(p): w =  [p]; // compile-time error
   D.makeMap(p): w =  {"help": q}; // compile-time error
   D.makeC(p): w =  C(p, 12); // compile-time error
}



The problem is that all these run afoul of the rules for
constant lists (<ref>),
maps (<ref>),
and objects (<ref>),
all of which independently require their subexpressions to be
constant expressions.



All of the illegal constructors of D above
could not be sensibly invoked via ,
because an expression that must be constant cannot depend on
a formal parameter, which may or may not be constant.
In contrast, the legal examples make sense regardless of
whether the constructor is invoked via  or via .

Careful readers will of course worry about cases where
the actual arguments to C() are constants, but are not numeric.
This is precluded by the rules on constant constructors
(<ref>),
combined with the rules for evaluating constant objects (<ref>).





  ¬ß.¬ß.¬ß Constant Contexts

constantContexts


Let e be an expression; e occurs in a
constant context
iff one of the following applies:









  * e is an element of a list or set literal whose first token is ,
  or e is a key or a value of an entry
  of a map literal whose first token is .

  * e occurs as @e in a construct derived from metadata.

  * e is an actual argument in an expression derived from
  constObjectExpression.

  * e is the initializing expression of a constant variable declaration
  (<ref>).

  * e is a switch case expression
  (<ref>).

  * e is an immediate subexpression of
  an expression e_0 which occurs in a constant context,
  where e_0 is
  
  
  not a function literal
  (<ref>).



A constant context is introduced in situations where
an expression is required to be constant.
This is used to allow the  modifier to be omitted
in cases where it does not contribute any new information.





 ¬ß.¬ß Null

null


The reserved word  evaluates to the null object.


<nullLiteral> ::= 



The null object is the sole instance of the built-in class Null.


Attempting to instantiate Null causes a compile-time error.
It is a compile-time error for a class to extend, mix in or implement
Null.
The Null class extends the Object class
and declares no methods except those also declared by Object.


The null object has primitive equality
(<ref>).



The static type of  is the Null type.




 ¬ß.¬ß Numbers

numbers


A numeric literalliteral!numeric
is either a decimal or hexadecimal numeral representing an integer value,
or a decimal double representation.


<numericLiteral> ::= <NUMBER>
  <HEX_NUMBER>

<NUMBER> ::= <DIGIT>+ (`.' <DIGIT>+)? <EXPONENT>?
  `.' <DIGIT>+ <EXPONENT>?

<EXPONENT> ::= (`e' | `E') (`+' | `-')? <DIGIT>+

<HEX_NUMBER> ::= `0x' <HEX_DIGIT>+
  `0X' <HEX_DIGIT>+

<HEX_DIGIT> ::= `a' .. `f'
  `A' .. `F'
  <DIGIT>



A numeric literal starting with `0x' or `0X'
is a hexadecimal integer literalliteral!hexadecimal integer.
It has the numeric integer value of the hexadecimal numeral
following `0x' (respectively `0X').


A numeric literal that contains only decimal digits is a
decimal integer literalliteral!decimal integer.
It has the numeric integer value of the decimal numeral.


An integer literalliteral!integer
is either a hexadecimal integer literal or a decimal integer literal.


Let l be an integer literal that is not the operand
of by a unary minus operator,
and let T be the static context type of l.
If double is assignable to T and int is not assignable to T,
then the static type of l is double;
otherwise the static type of l is int.


This means that an integer literal denotes a double
when it would satisfy the type requirement, and an int would not.
Otherwise it is an int, even in situations where that is an error.



A numeric literal that is not an integer literal is a
double literalliteral!double.

A double literal always contains either a decimal point or an exponent part.

The static type of a double literal is double.


If l is an integer literal with numeric value i and static type int,
and l is not the operand of a unary minus operator,
then evaluation of l proceeds as follows:

  
  *  If l is a hexadecimal integer literal,
  2^63‚â§ i < 2^64 and the int class is implemented as
  signed 64-bit two's complement integers,
  then l evaluates to an instance of the int class
  representing the numeric value i - 2^64,
  
  *  Otherwise l evaluates to an instance of the int class
  representing the numeric value i.
  It is a compile-time error if the integer i cannot be represented
  exactly by an instance of int.



Integers in Dart are designed to be implemented as
64-bit two's complement integer representations.
In practice, implementations may be limited by other considerations.
For example, Dart compiled to JavaScript may use the JavaScript number type,
equivalent to Dart double, to represent integers, and if so,
integer literals with more than 53 bits of precision cannot be represented
exactly.



A double literal evaluates to a an instance of the double class
representing a 64 bit double precision floating point number
as specified by the IEEE 754 standard.


An integer literal with static type double and numeric value i
evaluates to an instance of the double class representing the value i.
It is a compile-time error if the value i
cannot be represented precisely by an instance of double.


A 64 bit double precision floating point number
is usually taken to represent a range of real numbers
around the precise value denoted by the number's
sign, mantissa and exponent.
For integer literals evaluating to double
values we insist that the integer literal's numeric value
is the precise value of the double instance.



It is a compile-time error for a class to extend, mix in or implement
int.
It is a compile-time error for a class to extend, mix in or implement
double.
It is a compile-time error for any class
other than int and double to extend, mix in or implement
num.


The instances of int and double all override
the == operator inherited from the Object class.




 ¬ß.¬ß Booleans

booleans


The reserved words  and  evaluate to objects
truetrue, the object and
falsefalse, the object
that represent the boolean values true and false respectively.
They are the boolean literalsliteral!boolean.


<booleanLiteral> ::= 
  



Both true and false are instances of
the built-in class bool,
and there are no other objects that implement bool.
It is a compile-time error for a class to
extend, mix in or implement bool.


The  and  objects have primitive equality
(<ref>).



Invoking the getter runtimeType on a boolean value returns
the Type object that is the value of the expression bool.
The static type of a boolean literal is bool.




 ¬ß.¬ß Strings

strings


A string is a sequence of UTF-16 code units.


This decision was made for compatibility with web browsers and Javascript.
Earlier versions of the specification required a string to be
a sequence of valid Unicode code points.
Programmers should not depend on this distinction.



<stringLiteral> ::= (<multilineString> | <singleLineString>)+



A string can be a sequence of single line strings and multiline strings.


<singleLineString> ::= <RAW_SINGLE_LINE_STRING>
  <SINGLE_LINE_STRING_SQ_BEGIN_END>
  <SINGLE_LINE_STRING_SQ_BEGIN_MID> <expression> 
       (<SINGLE_LINE_STRING_SQ_MID_MID> <expression>)* 
       <SINGLE_LINE_STRING_SQ_MID_END>
  <SINGLE_LINE_STRING_DQ_BEGIN_END>
  <SINGLE_LINE_STRING_DQ_BEGIN_MID> <expression> 
       (<SINGLE_LINE_STRING_DQ_MID_MID> <expression>)* 
       <SINGLE_LINE_STRING_DQ_MID_END>

<RAW_SINGLE_LINE_STRING> ::=
  `r' `' ((`' | `
r' | `
n'))* `'
  `r' `"' ((`"' | `
r' | `
n'))* `"'

<STRING_CONTENT_COMMON> ::= (`
' | `' | `"' | `' | `
r' | `
n')
   <ESCAPE_SEQUENCE>
   `
' (`n' | `r' | `b' | `t' | `v' | `x' | `u' | `
r' | `
n')
   <SIMPLE_STRING_INTERPOLATION>

<STRING_CONTENT_SQ> ::= <STRING_CONTENT_COMMON> | `"'

<SINGLE_LINE_STRING_SQ_BEGIN_END> ::= 
  `' <STRING_CONTENT_SQ>* `'

<SINGLE_LINE_STRING_SQ_BEGIN_MID> ::= 
  `' <STRING_CONTENT_SQ>* `'

<SINGLE_LINE_STRING_SQ_MID_MID> ::= 
  `' <STRING_CONTENT_SQ>* `'

<SINGLE_LINE_STRING_SQ_MID_END> ::= 
  `' <STRING_CONTENT_SQ>* `'

<STRING_CONTENT_DQ> ::= <STRING_CONTENT_COMMON> | `'

<SINGLE_LINE_STRING_DQ_BEGIN_END> ::= 
  `"' <STRING_CONTENT_DQ>* `"'

<SINGLE_LINE_STRING_DQ_BEGIN_MID> ::= 
  `"' <STRING_CONTENT_DQ>* `'

<SINGLE_LINE_STRING_DQ_MID_MID> ::= 
  `' <STRING_CONTENT_DQ>* `'

<SINGLE_LINE_STRING_DQ_MID_END> ::= 
  `' <STRING_CONTENT_DQ>* `"'

A single line string is delimited by
either matching single quotes or matching double quotes.


Hence, 'abc' and "abc" are both legal strings,
as are 'He said "To be or not to be" did he not?' and
"He said 'To be or not to be' didn't he?".
However, "This' is not a valid string, nor is 'this".

The grammar ensures that a single line string cannot span more than
one line of source code,
unless it includes an interpolated expression that spans multiple lines.

Adjacent strings are implicitly concatenated to form a single string literal.


Here is an example:

print("A string" "and then another"); // A stringand then another
Dart also supports the operator + for string concatenation.

The + operator on Strings requires a String argument.
It does not coerce its argument into a string.
This helps avoid puzzlers such as

print("A simple sum: 2 + 2 = " +
            2 + 2);

which would print `A simple sum: 2 + 2 = 22' rather than
`A simple sum: 2 + 2 = 4'.
However, for efficiency reasons,
the recommended Dart idiom is to use string interpolation.

print("A simple sum: 2 + 2 = ${2+2}");

String interpolation works well for most cases.
The main situation where it is not fully satisfactory
is for string literals that are too large to fit on a line.
Multiline strings can be useful, but in some cases,
we want to visually align the code.
This can be expressed by writing
smaller strings separated by whitespace, as shown here:

'Imagine this is a very long string that does not fit on a line. What shall we do? '
'Oh what shall we do? '
'We shall split it into pieces '
'like so'.

An auxiliary
string interpolation state stack
is maintained outside the parser,
in order to ensure that string interpolations are matched up correctly.


This is necessary because the expression of a non-simple string interpolation
may itself contain string literals
with their own non-simple string interpolations.

For rules with names ‚Ä¶_BEGIN_MID,
a marker is pushed on the auxiliary stack to indicate that
a string interpolation of the given kind has started,
where the kind is , ", , or """.
For rules with names ‚Ä¶_MID_MID,
only the rule with the kind on the top of the auxiliary stack can be used.
For rules with names ‚Ä¶_MID_END,
only the rule with the kind on the top of the auxiliary stack can be used,
and the marker is then popped.


<multilineString> ::= <RAW_MULTI_LINE_STRING>
   <MULTI_LINE_STRING_SQ_BEGIN_END>
   <MULTI_LINE_STRING_SQ_BEGIN_MID> <expression> 
       (<MULTI_LINE_STRING_SQ_MID_MID> <expression>)* 
       <MULTI_LINE_STRING_SQ_MID_END>
   <MULTI_LINE_STRING_DQ_BEGIN_END>
   <MULTI_LINE_STRING_DQ_BEGIN_MID> <expression> 
       (<MULTI_LINE_STRING_DQ_MID_MID> <expression>)* 
       <MULTI_LINE_STRING_DQ_MID_END>

<RAW_MULTI_LINE_STRING> ::= `r' `' .*? `'
   `r' `"""' .*? `"""'

<QUOTES_SQ> ::= | `' | `'

<STRING_CONTENT_TSQ> ::= 
  <QUOTES_SQ> (<STRING_CONTENT_COMMON> | `"' | `
r' | `
n')

<MULTI_LINE_STRING_SQ_BEGIN_END> ::= 
  `' <STRING_CONTENT_TSQ>* `'

<MULTI_LINE_STRING_SQ_BEGIN_MID> ::= 
  `' <STRING_CONTENT_TSQ>* <QUOTES_SQ> `'

<MULTI_LINE_STRING_SQ_MID_MID> ::= 
  `' <STRING_CONTENT_TSQ>* <QUOTES_SQ> `'

<MULTI_LINE_STRING_SQ_MID_END> ::= 
  `' <STRING_CONTENT_TSQ>* `'

<QUOTES_DQ> ::= | `"' | `""'

<STRING_CONTENT_TDQ> ::= 
  <QUOTES_DQ> (<STRING_CONTENT_COMMON> | `' | `
r' | `
n')

<MULTI_LINE_STRING_DQ_BEGIN_END> ::= 
  `"""' <STRING_CONTENT_TDQ>* `"""'

<MULTI_LINE_STRING_DQ_BEGIN_MID> ::= 
  `"""' <STRING_CONTENT_TDQ>* <QUOTES_DQ> `'

<MULTI_LINE_STRING_DQ_MID_MID> ::= 
  `' <STRING_CONTENT_TDQ>* <QUOTES_DQ> `'

<MULTI_LINE_STRING_DQ_MID_END> ::= 
  `' <STRING_CONTENT_TDQ>* `"""'

<ESCAPE_SEQUENCE> ::= `
n' | `
r' | `
f' | `
b' | `
t' | `
v'
   `
x' <HEX_DIGIT> <HEX_DIGIT>
   `
u' <HEX_DIGIT> <HEX_DIGIT> <HEX_DIGIT> <HEX_DIGIT>
   `
u' <HEX_DIGIT_SEQUENCE> `'

<HEX_DIGIT_SEQUENCE> ::= 
  <HEX_DIGIT> <HEX_DIGIT>? <HEX_DIGIT>?
   <HEX_DIGIT>? <HEX_DIGIT>? <HEX_DIGIT>?

Multiline strings are delimited by either
matching triples of single quotes or
matching triples of double quotes.
If the first line of a multiline string consists solely of
the whitespace characters defined by the production WHITESPACE
(<ref>),
possibly prefixed by `
',
then that line is ignored,
including the line break at its end.


The idea is to ignore a whitespace-only first line of a multiline string,
where whitespace is defined as tabs, spaces and the final line break.
These can be represented directly,
but since for most characters prefixing by backslash is
an identity in a non-raw string,
we allow those forms as well.

In the rule for RAW_MULTI_LINE_STRING,
the two occurrences of .*?
denote a non-greedy token recognition step:
It terminates as soon as the lookahead is the specified next token
(that is, or """).


Note that multi-line string interpolation relies on
the auxiliary string interpolation state stack,
just like single-line string interpolation.

Strings support escape sequences for special characters.
The escapes are:

  * `
n' for newline, equivalent to `
x0A'.

  * `
r' for carriage return, equivalent to `
x0D'.

  * `
f' for form feed, equivalent to `
x0C'.

  * `
b' for backspace, equivalent to `
x08'.

  * `
t' for tab, equivalent to `
x09'.

  * `
v' for vertical tab, equivalent to `
x0B'.

  * `
x' <HEX_DIGIT>_1 <HEX_DIGIT>_2, equivalent to

  `
u' <HEX_DIGIT>_1 <HEX_DIGIT>_2 `'.

  * `
u' <HEX_DIGIT>_1 <HEX_DIGIT>_2 <HEX_DIGIT>_3 <HEX_DIGIT>_4,
  equivalent to

  `
u' <HEX_DIGIT>_1 <HEX_DIGIT>_2 <HEX_DIGIT>_3 <HEX_DIGIT>_4 `'.

  * `
u' <HEX_DIGIT_SEQUENCE> `' is
  the Unicode code point represented by the
  <HEX_DIGIT_SEQUENCE>.
  It is a compile-time error if the value of the
  <HEX_DIGIT_SEQUENCE>
  is not a valid Unicode code point.
  For example,`
u0A'is the code point U+000A.
  * $ indicating the beginning of an interpolated expression.

  * 
    kÃ®
    Otherwise, `
'Ã® indicates the character  for
    any  not in {`n', `r', `f', `b', `t', `v', `x', `u'}.
  
Any string may be prefixed with the character r,
indicating that it is a raw string,
in which case no escapes or interpolations are recognized.


Line breaks in a multiline string are represented by
the LINE_BREAK production.
A line break introduces a single newline character (U+000A)
into the string value.


It is a compile-time error if a non-raw string literal contains
a character sequence of the form `
x' that is not followed by
a sequence of two hexadecimal digits.
It is a compile-time error if a non-raw string literal contains
a character sequence of the form `
u' that is not followed by
either a sequence of four hexadecimal digits,
or by curly brace delimited sequence of hexadecimal digits.


<LINE_BREAK> ::= `
n'
   `
r
n'
   `
r'

All string literals evaluate to instances of the built-in class String.
It is a compile-time error for a class to
extend, mix in or implement String.
The String class overrides the == operator inherited from
the Object class.
The static type of a string literal is String.




  ¬ß.¬ß.¬ß String Interpolation
stringInterpolation
It is possible to embed expressions within non-raw string literals,
such that these expressions are evaluated,
and the resulting objects are converted into strings and
concatenated with the enclosing string.
This process is known as string interpolation.


<stringInterpolation> ::= <SIMPLE_STRING_INTERPOLATION>
   `' <expression> `'

<SIMPLE_STRING_INTERPOLATION> ::= 
  `' (<IDENTIFIER_NO_DOLLAR> | <BUILT_IN_IDENTIFIER> | )

The reader will note that the expression inside the interpolation
could itself include strings,
which could again be interpolated recursively.

An unescaped $ character in a string signifies
the beginning of an interpolated expression.
The $ sign may be followed by either:

  *  A single identifier ùïÄ that does not contain the $ character
  (but it can be a built-in identifier),
  or the reserved word .

  *  An expression e delimited by curly braces.

The form $ùïÄ is equivalent to the form ${ùïÄ}.
An interpolated string,s, with content
`s_0${e_1}s_1‚Ä¶s_n-1${e_n}s_n'
(where any ofs_0, ‚Ä¶, s_ncan be empty)
is evaluated by evaluating each expressione_i(1 ‚â§i ‚â§n)
into a stringr_iin the order they occur in the source text, as follows:

  *  Evaluate e_i to an object o_i.

  *  Invoke the toString method on o_i with no arguments,
  and let r_i be the returned object.

  *  If r_i is the null object, a dynamic error occurs.

Finally, the result of the evaluation ofsis
the concatenation of the stringss_0,r_1, ‚Ä¶,r_n, ands_n.




 ¬ß.¬ß Symbols
symbols
A symbol literalliteral!symbol
denotes a name that would be either
a valid declaration name, a valid library name, or .


<symbolLiteral> ::=
  `#' (<identifier> (`.' <identifier>)* | <operator> | )

The static type of a symbol literal is Symbol.


Let ùïÄ be an identifier that does not begin with an underscore
(`_').
The symbol literal #ùïÄ
evaluates to an instance of Symbol
representing the identifier ùïÄ.


A symbol literal #ùïÄ_1.ùïÄ_2.‚ãØ.ùïÄ_n
where ùïÄ1n are identifiers
evaluates to an instance of Symbol
representing that particular sequence of identifiers.

This kind of symbol literal denotes the name of a library declaration,
as specified in a libraryName.
Library names are not subject to library privacy, even
if some of its identifiers begin with an underscore.

A symbol literal #op
where op is derived from operator
evaluates to an instance of Symbol
representing that particular operator name.


The symbol literal #void
evaluates to an instance of Symbol
representing the reserved word .


For the valueoof a symbol literal representing a source code term
as specified in the previous paragraphs, we say thatois a
non-private symbol based onsymbol!non-private, based on
the string whose contents is the characters of that term, without whitespace.


Note that this does not apply for private symbols,
which are discussed below.
A private symbol is not based on any string.

Ifois the value of an invocation of the Symbol constructor
of the form
Symbol(e),   Symbol(e),
or   Symbol(e),
whereeis an expression
(constant if necessary)
that evaluates to a strings,
we say thatois a non-private symbol based ons.


Note that Symbol('_foo') is a non-private symbol,
and it is distinct from #_foo, as described below.

Assume thati ‚àà1,2,
and thato_iis the value of a constant expression
which is a symbol based on the strings_i.
If s_1 == s_2 theno_1ando_2is the same object.
That is, symbol instances are canonicalized.
Ifo_1ando_2are non-private symbols
(not necessarily constant)
based on stringss_1ands_2theno_1ando_2are equal according to operator ==
if and only if s_1 == s_2
(<ref>).


A symbol literal #_ùïÄ where _ùïÄ is an identifier
evaluates to an instance of Symbol
representing the private identifier _ùïÄ of the enclosing library.
All occurrences of #_ùïÄin the same library evaluate to
the same object,
and no other symbol literal or Symbol constructor invocation
evaluates to the same object,
nor to a Symbol instance that is equal to that object
according to the == operator.


One may well ask what is the motivation for introducing literal symbols?
In some languages, symbols are canonicalized whereas strings are not.
However literal strings are already canonicalized in Dart.
Symbols are slightly easier to type compared to strings
and their use can become strangely addictive,
but this is not nearly sufficient justification for adding
a literal form to the language.
The primary motivation is related to the use of reflection
and a web specific practice known as minification.

Minification compresses identifiers consistently throughout a program
in order to reduce download size.
This practice poses difficulties for reflective programs
that refer to program declarations via strings.
A string will refer to an identifier in the source,
but the identifier will no longer be used in the minified code,
and reflective code using these would fail.
Therefore, Dart reflection uses objects of type Symbol
rather than strings.
Instances of Symbol are guaranteed to be stable
with respect to minification.
Providing a literal form for symbols makes
reflective code easier to read and write.
The fact that symbols are easy to type and can often act as
convenient substitutes for enums are secondary benefits.


 ¬ß.¬ß Collection Literals
collectionLiterals
This section specifies several literal expressions denoting collections.
Some syntactic forms may denote more than one kind of collection,
in which case a disambiguation step is performed
in order to determine the kind
(<ref>).


The subsections of this section are concerned with mechanisms that are
common to all kinds of collection literals
(<ref>,
<ref>),
followed by a specification of list literals
(<ref>, <ref>),
followed by a specification of how to disambiguate and infer types
for sets and maps
(<ref>, <ref>),
and finally a specification of sets
(<ref>)
and maps
(<ref>).


<listLiteral> ::= ? <typeArguments>? `[' <elements>? `]'

<setOrMapLiteral> ::= ? <typeArguments>? `' <elements>? `'

<elements> ::= <element> (`,' <element>)* `,'?

<element> ::= <expressionElement>
   <mapElement>
   <spreadElement>
   <ifElement>
   <forElement>

<expressionElement> ::= <expression>

<mapElement> ::= <expression> `:' <expression>

<spreadElement> ::= (`...' | `...?') <expression>

<ifElement> ::=  `(' <expression> `)' <element> ( <element>)?

<forElement> ::= ?  `(' <forLoopParts> `)' <element>

Syntactically, a collection literal can be
a listLiteral or a setOrMapLiteral.
The contents of the collection is specified as a sequence of
collection literal elementscollection literal!elements,
in short elements.
Each element may be a declarative specification of a single entity,
such as an expressionElement or a mapElement,
it may specify a collection which is to be included,
of the form spreadElement,
or it may be a computational element specifying
how to obtain zero or more entities,
of the form ifElement or forElement.


Terms derived from element,
and the ability to build collections from them,
is also known as
UI-as-code.

The leaf elements of an element‚Ñìderived from
expressionElement or mapElement
is{‚Ñì}.
The leaf elements of an element of the form
 (e) ‚Ñì or
 (forLoopParts) ‚Ñì
is the leaf elements of‚Ñì.
The leaf elements of an element of the form
 (e) ‚Ñì_1  ‚Ñì_2
is the union of the leaf elements of‚Ñì_1and‚Ñì_2.
The leaf elements of a spreadElement is the empty set.


The leaf elements of a collection literal is always
a set of expression elements and/or map elements.

In order to allow collection literals to occur as constant expressions,
we specify what it means for an element‚Ñìto be
constantcollection literal element!constant
or
potentially constant
  collection literal element!potentially constant:


  * 
  When ‚Ñì is an expressionElement of the form e:

  ‚Ñì is a potentially constant element
  if e is a potentially constant expression,
  and ‚Ñì is a constant element
  if e is a constant expression.

  * 
  When ‚Ñì is a mapElement
  of the form `e_1: e_2':

  ‚Ñì is a potentially constant element
  if both e_1 and e_2 are potentially constant expressions,
  and it is a constant element if they are constant expressions.

  * 
  When ‚Ñì is a spreadElement
  of the form `...e' or `...?e':

  ‚Ñì is a potentially constant element
  if e is a potentially constant expression.

  ‚Ñì is a constant element
  if e is a constant expression that evaluates
  to a List, Set, or Map instance
  originally created by a list, set, or map literal.

  Moreover, ‚Ñì is a constant element if it is `...?e',
  where e is a constant expression that evaluates
  to the null object.

  * 
  When ‚Ñì is an ifElement
  of the form
    (b)  ‚Ñì_1
  or the form
    (b)  ‚Ñì_1    ‚Ñì_2:

  ‚Ñì is a potentially constant element
  if b is a potentially constant expression,
  ‚Ñì_1 is potentially constant,
  and so is ‚Ñì_2, if present.

  ‚Ñì is a constant element if b is a constant expression
  and:

  
  * ‚Ñì is   (b)  ‚Ñì_1 and
    either b evaluates to  and ‚Ñì_1 is constant,
    or b evaluates to  and ‚Ñì_1 is potentially constant.
  
  * ‚Ñì is   (b)  ‚Ñì_1    ‚Ñì_2 and
    either b evaluates to ,
    ‚Ñì_1 is constant,
    and ‚Ñì_2 is potentially constant;
    or b evaluates to ,
    ‚Ñì_1 is potentially constant,
    and ‚Ñì_2 is constant.
  
A forElement can never occur in a constant collection literal.












































































  ¬ß.¬ß.¬ß Type Promotion
collectionLiteralTypePromotion
An ifElement interacts with type promotion
in the same way that  statements do.
Let‚Ñìbe an ifElement of the form
  (b)  ‚Ñì_1 or
  (b)  ‚Ñì_1    ‚Ñì_2.
Ifbshows that a local variablevhas typeT, then
the type ofvis known to beTin‚Ñì_1,
unless any of the following are true:


  * v is potentially mutated in ‚Ñì_1,

  * v is potentially mutated within a function
  other than the one where v is declared, or

  * v is accessed by a function defined in ‚Ñì_1 and
  v is potentially mutated anywhere in the scope of v.


Type promotion will likely get more sophisticated in a future version of Dart.
When that happens,
ifElements will continue to match  statements
(<ref>).


  ¬ß.¬ß.¬ß Collection Literal Element Evaluation
collectionLiteralElementEvaluation
The evaluation of a sequence of collection literal elements
(<ref>)
yields a
collection literal object sequence
  collection literal!object sequence,
also called an object sequence when no ambiguity can arise.


We use the notation

‚Ä¶[[...]]@
  
to denote an object sequence with explicitly listed elements,
and we use `+' to compute the concatenation of object sequences
(as in s_1 + s_2),
which is an operation that will succeed and has no side-effects.
Each element in the sequence is an objectoor a pairo_1: o_2.
There is no notion of an element type for an object sequence,
and hence no notion of dynamic errors arising from
a type mismatch during concatenation.


Object sequences can safely be treated as a low-level mechanism
which may omit otherwise required actions like dynamic type checks
because every access to an object sequence occurs
in code created by language defined desugaring
on statically checked constructs.
It is left unspecified how an object sequence is implemented,
it is only required that it contains the indicated objects or pairs
in the given order.
For each kind of collection,
the sequence is used in the given order to populate the collection,
in a manner which is specific to the kind,
and which is specified separately
(<ref>, <ref>, <ref>).

There may be an actual data structure
representing the object sequence at run time,
but the object sequence could also be eliminated, e.g.,
because each element is inserted directly into the target collection
as soon as it has been computed.
Note that each object sequence will exclusively contain objects,
or it will exclusively contain pairs,
because any attempt to create a mixed sequence would cause
an error at compile time or at run time
(the latter may occur for a spread element with static type ).

Assume that a literal collection target is given,
and the object sequence obtained as described below will be used
to populate target.
LetT_targetdenote the dynamic type of target.


Access to the type of target is needed below
in order to raise dynamic errors at specific points during
the evaluation of an object sequence.
Note that the dynamic type of target is statically known,
except for the binding of any type variables in its typeArguments.
This implies that some questions can be answered at compile-time, e.g.,
whether or not Iterable occurs as a superinterface of
T_target.
In any case, T_target is guaranteed to implement
Iterable (when target is a list or a set)
or Map (when target is a map),
but never both.

Assume that a location in code and a dynamic context is given,
such that ordinary expression evaluation is possible.
Evaluation of a collection literal element sequence
  collection literal element!evaluation of sequence
at that location and in that context is specified as follows:


Lets_syntaxof the form ‚Ñì1k be
a sequence of collection literal elements.
The sequence of objectss_objectobtained by evaluatings_syntaxis the concatenation of the sequences of objects
obtained by evaluating each element‚Ñì_j,j ‚àà1 .. k:s_object=‚Ñì_1+‚Ä¶+‚Ñì_k,
where ‚Ñì_j denotes the object sequence yielded by
evaluation of a single collection literal element‚Ñì_j.


When a pseudo-statement of the form
s := s + ‚Ñì;
is used in normative code below,
it denotes the extension ofswith the object sequence
yielded by evaluation of‚Ñì,
but it also denotes the specification of actions taken to produce
said object sequence,
and to produce the side effects associated with this computation,
as implied by evaluation of expressions and execution of statements
as specified below for the evaluation of ‚Ñì.


When a pseudo-statement of the form
‚Ñì := s;
occurs in normative code below,
it occurs at a point where the computation is complete
and it specifies that the value of ‚Ñì iss.
Evaluation of a collection literal element ‚Ñì
  collection literal element!evaluation
in the given context
to an object sequence
‚Ñì
  evaluateElement(l)@evaluateElement(‚Ñì)
is then specified as follows:


Expression element
In this case‚Ñìis an expressione;eis evaluated to an objectoand‚Ñì := o.

Map element
In this case‚Ñìis pair of expressions
e_1:e_2;
firste_1is evaluated to an objecto_1,
thene_2is evaluated to an objecto_2,
and‚Ñì := o_1:o_2.

Spread element
The element‚Ñìis of the form `...e' or `...?e'.
Evaluateeto an objecto_spread.

  * 
  When ‚Ñì is `...e':
  
  If o_spread is the null object then a dynamic error occurs.
  Otherwise evaluation proceeds with step 2.

  When ‚Ñì is `...?e':
  If o_spread is the null object then
  ‚Ñì :=.
  Otherwise evaluation proceeds with step 2.

  * 
  Let T_spread be the dynamic type of o_spread.
  Let S be the static type of e.
  When S is not a top type
  (<ref>),
  let S_spread be S.
  When S is a top type:
  If target is a list or a set then
  let S_spread be Iterable<>;
  otherwise
  (where target is a map),
  let S_spread be Map<,  >.

  
  * 
    When target is a list or a set
    and T_spread implements
    (<ref>)
    Iterable,
    the following code is executed in the context where ‚Ñì occurs,
    where spread, s, v, and value are fresh variables,
    and Value is a fresh type variable bound to the
    actual type argument of T_target at Iterable
    (<ref>):

    
[t]S_spread spread = o_spread;
s = ;
 ( v  spread) {
  Value value = v;
  s := s + value;
}‚Ñì := s;

      The code makes use of a pseudo-variable s denoting an object sequence.
      We do not specify the type of s,
      this variable is only used to indicate the required
      semantic actions taken to gather the resulting object sequence.
      In the case where the implementation does not have
      a representation of s at all,
      the action may be to extend target immediately.
      A similar approach is used in subsequent cases.
    
  * 
    When target is a map and T_spread implements
    Map,
    the following code is executed in the context where ‚Ñì occurs,
    where spread, s, v, key, and value
    are fresh variables,
    and Key and Value are fresh type variables bound to the
    first respectively second actual type argument
    of T_target at Map:

    
[t]S_spread spread = o_spread;
s = ;
 ( v  spread) {
  Key key = v.key;
  Value value = v.value;
  s := s + key: value;
}‚Ñì := s;

    It is allowed for an implementation to delay the dynamic errors
    that occur if the given key does not have the type Key,
    or the given value does not have the type Value,
    but it cannot occur after the pair has been appended to s.
  
  * 
    Otherwise, a dynamic error occurs.

    
      This occurs when the target is an iterable respectively a map,
      and the spread is not, which is possible for
      a spread whose static type is .
    
This may not be the most efficient way to traverse the items in a collection,
and implementations may of course use any other approach
with the same observable behavior.
However, in order to give implementations more room to optimize
we also allow the following.

Ifo_spreadis an object whose dynamic type implements
(<ref>)
List, Queue, or Set,
an implementation may choose to call length on the object.
Ifo_spreadis an object
whose dynamic type implements List,
an implementation may choose to call operator []
in order to access elements from the list.
If it does so, it will only pass indices
that are non-negative and less than the value returned by length.


This may allow for more efficient code for
allocating the collection and accessing its parts.
The given classes are expected to have
an efficient and side-effect free implementation
of length and operator [].
A Dart implementation may detect whether these options apply
at compile time based on the static type of e,
or at runtime based on the actual value.

If element
When‚Ñìis an ifElement of the form
  (b)  ‚Ñì_1 or
  (b)  ‚Ñì_1    ‚Ñì_2,
the conditionbis evaluated to a valueo_b.
Ifo_bis  then‚Ñì := ‚Ñì_1.
Ifo_bis  and‚Ñì_2is present then‚Ñì := ‚Ñì_2,
and if‚Ñì_2is not present then‚Ñì := .

Ifo_bis neither  nor  then a dynamic error occurs.

For element
LetPbe derived from <forLoopParts> and
let‚Ñìbe a forElement of the form
?    (P)  ‚Ñì_1,
where `?' indicates that  may be present or absent.
To evaluate‚Ñì,
the following code is executed in the context where‚Ñìoccurs,
where  is present if and only if it is present in‚Ñì:


[t]s = ;
?  (P) {s := s + ‚Ñì_1;
}‚Ñì := s;


  ¬ß.¬ß.¬ß List Literal Inference
listLiteralInference
This section specifies how a list literal list is traversed and an
inferred element typelist literal!element type
for list is determined.
We specify first how to infer the element type of a single element,
then how to use that result to infer
the element type of list as a whole.


The context typeP(<ref>)
for each element of list is
obtained from the context type of list.
If downwards inference constrains the type of list
to List<P_e> or Iterable<P_e> for someP_ethenPisP_e.
Otherwise,Pis 
(<ref>).


Let‚Ñìbe a term derived from element.
Inference of the element type of‚Ñìwith context typePproceeds as follows,
where the context type for inference of an element type is alwaysP,
unless anything is said to the contrary:


Expression element
In this case‚Ñìis an expressione.
The inferred element type of‚Ñìis

the inferred type ofein contextP.

Map element





This cannot occur:
it is a compile-time error
when a leaf element of a list literal is a map element
(<ref>).

Spread element
Letebe the expression of‚Ñì.
If‚Ñìis `...e',
letSbe the inferred type ofein context Iterable<P>.
Otherwise
(when ‚Ñì is `...?e'),


letSbe the non-nullable type of





the inferred type ofein context Iterable<P>?.


  * 
  If S implements Iterable,
  the inferred element type of ‚Ñì is
  the type argument of S at Iterable.

  * 
  If S is ,
  the inferred element type of ‚Ñì is .

  * 
  If S is Null and the spread operator is ...?,
  the inferred element type of ‚Ñì is Null.

  * 
  Otherwise, a compile-time error occurs.


If element
In this case‚Ñìis of the form
  (b)  ‚Ñì_1 or
  (b)  ‚Ñì_1    ‚Ñì_2.
The conditionbis always inferred with a context type of bool.

Assume that `  ‚Ñì_2' is not present.
Then, if the inferred element type of‚Ñì_1isS,
the inferred element type of‚ÑìisS.

Otherwise, `  ‚Ñì_2' is present.
If the inferred element type of‚Ñì_1isS_1and
the inferred element type of‚Ñì_2isS_2,
the inferred element type of‚Ñìis
the least upper bound ofS_1andS_2.

For element
In this case‚Ñìis of the form
?    (P)  ‚Ñì_1
wherePis derived from forLoopParts and
`?' indicates that  may be present or absent.

The same compile-time errors occur for‚Ñìas
the errors that would occur with the corresponding  statement
?    (P)  {},
located in the same scope as‚Ñì.
Moreover, the errors and type analysis of‚Ñìis performed
as if it occurred in the body scope of said  statement.

For instance, if P is of the form
  v    e_1
then the variable v is in scope for ‚Ñì.


Inference for the parts
(
such as the iterable expression of a for-in,
or the forInitializerStatement of a for loop
)
is done as for the corresponding  statement,
including  if and only if the element includes .
Then, if the inferred element type of‚Ñì_1isS,
the inferred element type of‚ÑìisS.


In other words, inference flows upwards from the body element.


Finally, we define
type inference on a list literal
  type inference!list literal
as a whole.
Assume that list is derived from listLiteral
and contains the elements ‚Ñì1n,
and the context type for list isP.


  * 
  If P is  then
  the inferred element type for list is T,
  where T is the least upper bound of
  the inferred element types of ‚Ñì1n.


  * 
  Otherwise,
  the inferred element type for list is T,
  where T is determined by downwards inference.

In both cases, the static type of list is List<T>.




  ¬ß.¬ß.¬ß Lists
lists
A list literalliteral!list
denotes a list object, which is an integer indexed collection of objects.
The grammar rule for listLiteral is specified elsewhere
(<ref>).


When a given list literalehas no type arguments,
the type argumentTis selected as specified elsewhere
(<ref>),
andeis henceforth treated as
(<ref>)
<T>e.


The static type of a list literal of the form <T>e
is List<T>
(<ref>).

Letebe a list literal of the form
<T>[‚Ñì1m].
It is a compile-time error if a leaf element ofeis a
mapElement.
It is a compile-time error if, for somej ‚àà1 .. m,‚Ñì_jdoes not have an element type,
or the element type of‚Ñì_jmay not be assigned toT.


A list may contain zero or more objects.
The number of objects in a list is its size.
A list has an associated set of indices.
An empty list has an empty set of indices.
A non-empty list has the index set{0, ‚Ä¶, n - 1}wherenis the size of the list.
It is a dynamic error to attempt to access a list
using an index that is not a member of its set of indices.


The system libraries define many members for the type List,
but we specify only the minimal set of requirements
which are used by the language itself.

If a list literalebegins with the reserved word 
oreoccurs in a constant context
(<ref>),
it is a
constant list literalliteral!list!constant,
which is a constant expression
(<ref>)
and therefore evaluated at compile time.
Otherwise, it is a
run-time list literalliteral!list!run-time
and it is evaluated at run time.
Only run-time list literals can be mutated
after they are created.

Attempting to mutate a constant list literal will result in a dynamic error.





Note that the collection literal elements of a constant list literal
occur in a constant context
(<ref>),
which means that  modifiers need not be specified explicitly.

It is a compile-time error
if an element of a constant list literal is not constant.
It is a compile-time error if the type argument of a constant list literal
(no matter whether it is explicit or inferred)
is not a constant type expression
(<ref>).


The binding of a formal type parameter of an enclosing class or function
is not known at compile time,
so we cannot use such type parameters inside constant expressions.

The value of a constant list literal
?  <T>[‚Ñì1m]
is an objectowhose class implements the built-in class
List<t>
wheretis the actual value ofT(<ref>),
and whose contents is the object sequence o1n obtained by
evaluation of ‚Ñì1m
(<ref>).
Theith object ofo(at indexi - 1) is theno_i.


Let ?  <T_1>[‚Ñì_11, ‚Ä¶, ‚Ñì_1m_1]
and ?  <T_2>[‚Ñì_21, ‚Ä¶, ‚Ñì_2m_2]
be two constant list literals.
Leto_1with contentso_11, ‚Ä¶, o_1nand actual type argumentt_1respectivelyo_2with contentso_21, ‚Ä¶, o_2nand actual type argumentt_2be the result of evaluating them.
Then identical(o_1, o_2) evaluates to  iff
t_1 == t_2 and identical(o_1i, o_2i)
evaluates to  for alli ‚àà1 .. n.


In other words, constant list literals are canonicalized.
There is no need to consider canonicalization
for other instances of type List,
because such instances cannot be
the result of evaluating a constant expression.

A run-time list literal
<T>[‚Ñì1m]
is evaluated as follows:

  * 
  The elements ‚Ñì1m are evaluated
  (<ref>),
  to an object sequence o1n.

  * 
  A fresh instance (<ref>) o, of size n,
  whose class implements the built-in class List<t>
  is allocated,
  where t is the actual value of T
  (<ref>).

  * 
  The operator []= is invoked on o with
  first argument i and second argument
  o_i+1, 0 ‚â§ i < n.

  * 
  The result of the evaluation is o.

The objects created by list literals do not override
the == operator inherited from the Object class.


Note that this document does not specify an order
in which the elements are set.
This allows for parallel assignments into the list
if an implementation so desires.
The order can only be observed as follows (and may not be relied upon):
if element i is not a subtype of the element type of the list,
a dynamic type error will occur when a[i] is assigned o_i-1.


  ¬ß.¬ß.¬ß Set and Map Literal Disambiguation
setAndMapLiteralDisambiguation
Some terms like {} and { ...ùïÄ } are ambiguous:
they may be either a set literal or a map literal.
This ambiguity is eliminated in two steps.
The first step uses only the syntax and context type,


and is described in this section.
The second step uses expression types and is described next
(<ref>).


Letebe a setOrMapLiteral
with leaf elementsLand context typeC.
IfCis  then letSbe undefined.


Otherwise letSbe the greatest closure of C
(<ref>).



A future version of this document will specify context types.
The basic intuition is that a
context type
is the type declared for a
receiving entity such as
a formal parameter p or a declared variable v.
That type will be the context type for
an actual argument passed to p,
respectively an initializing expression for v.
In some situations the context has no constraints,
e.g., when a variable is declared with  rather than a type annotation.
This gives rise to an
unconstrained context typecontext type!unconstrained,
[]@,
which may also occur in a composite term, e.g., List<>.


The greatest closure of a context type C is
approximately the least common supertype of all types
obtainable by replacing  by a type.

The disambiguation step of this section is
the first applicable entry in the following list:


  *  When e has type arguments T1k, k > 0:
  If k = 1 then e is a set literal with static type
  Set<T_1>.
  If k = 2 then e is a map literal with static type
  Map<T_1,  T_2>.
  Otherwise a compile-time error occurs.

  * 
  When S implements
  (<ref>)
  Iterable but not Map,
  e is a set literal.
  When S implements Map but not Iterable,
  e is a map literal.

  * 
  When L‚â†‚àÖ (that is, e has leaf elements):
  If L contains a mapElement
  as well as an expressionElement,
  a compile-time error occurs.
  Otherwise, if L contains an expressionElement,
  e is a set literal.
  Otherwise L contains a mapElement, and e is a map literal.

  * 
  When e is of the form {} and S is undefined,
  e is a map literal.
  
    There is no deeper reason for this choice,
    but the fact that {} is a map by default
    was useful when set literals were introduced,
    because it would be a breaking change to make it a set.
  
  * 
  Otherwise, e is still ambiguous.
  
    In this case e is non-empty, but contains only spreads
    wrapped zero or more times in ifElements or forElements.
    Disambiguation will then occur during inference
    (<ref>).
  
When this step does not determine a static type,
it will be determined by type inference
(<ref>).

If this process successfully disambiguates the literal
then we say thateis
unambiguously a setset!unambiguously
or
unambiguously a mapmap!unambiguously,
as appropriate.




  ¬ß.¬ß.¬ß Set and Map Literal Inference
setAndMapLiteralInference
This section specifies how a setOrMapLiteraleis traversed
and an associated
inferred element typeset or map literal!element type
and/or an associated
inferred key and value type pair
  set or map literal!key and value type pair
is determined.


If e has an element type then it may be a set,
and if it has a key and value type pair then it may be a map.

However, if the literal e contains a spread element of type ,
that element cannot be used to determine whether e is a set or a map.
The ambiguity is represented as having both
an element type and a key and value type pair.

It is an error if the ambiguity is not resolved by some other elements,
but if it is resolved then the dynamic spread element is required
to evaluate to a suitable instance
(implementing Iterable when e is a set,
and implementing Map when e is a map),
which means that it is a dynamic error if there is a mismatch.
In other situations it is a compile-time error to have both
an element type and a key and value type pair,
because e must be both a set and a map.
Here is an example:
 x = <int, int>{};
Iterable l = [];
Map m = {};

 main() { v1 = {...x};       // Compile-time error: ambiguous v2 = {...x, ...l}; // A set, dynamic error when `x` is evaluated v3 = {...x, ...m}; // A map, no dynamic errors v4 = {...l, ...m}; // Compile-time error: must be set and map}
Let collection be a collection literal
derived from setOrMapLiteral.
The inferred type of an element is an element typeT,
a pair of a key and value type(K, V), or both.
It is computed relative to a context typeP(<ref>),
which is determined as follows:


  * 
  If collection is unambiguously a set
  (<ref>)
  then P is Set<P_e>,
  
  where P_e is determined by downwards inference,
  and may be 
  (<ref>)
  if downwards inference does not constrain it.

  
  
    A future version of this document will specify inference,
    the notion of downwards inference,
    and constraining.
    The brief intuition is that inference selects values for
    type parameters in generic constructs
    where no type arguments have been provided,
    aiming at a type which matches a given context type;
    downwards inference does this by passing information
    from a given expression into its subexpressions,
    and upwards inference propagates information in the opposite direction.
    Constraints are expressed in terms of context types;
    being unconstrained means having  as the context type.
    Having a context type that contains
    one or more occurrences of 
    provides a partial constraint on the inferred type.
  
  * 
  If collection is unambiguously a map
  then P is Map<P_k,  P_v>
  where P_k and P_v are determined by downwards inference,
  and may be 
  if the downwards context does not constrain one or both.

  * 
  Otherwise, collection is ambiguous,
  and the downwards context for the elements of collection
  is .

We say that a collection literal element
can be a setcollection literal element!can be a set
if it has an element type;
it
can be a mapcollection literal element!can be a map
if it has a key and value type pair;
it
must be a setcollection literal element!must be a set
if it can be a set and has and no key and value type pair;
and it
must be a mapcollection literal element!must be a map
if can be a map and has no element type.


Let‚Ñìbe a term derived from element.
Inference of the type of
  type inference!collection literal element‚Ñìwith context typePthen proceeds
as follows:


Expression element
In this case‚Ñìis an expressione.

IfPis ,
the inferred element type of‚Ñìis
the inferred type ofein context .

IfPis Set<P_e>,
the inferred element type of‚Ñìis
the inferred type ofein contextP_e.

Map element
In this case‚Ñìis a pair of expressions e_k: e_v.

IfPis ,
the inferred key and value type pair of‚Ñìis(K, V),
whereKandVis
the inferred type ofe_krespectivelye_v,
in context .

IfPis Map<P_k,  P_v>,
the inferred key and value type pair of‚Ñìis(K, V),
whereKis
the inferred type ofe_kin contextP_k, and
theVis
the inferred type ofe_vin contextP_v.

Spread element
In this case‚Ñìis of the form
`...e' or `...?e'.
IfPis  then letSbe
the inferred type ofein context .
Then:


  * 
  If S implements Iterable,
  the inferred element type of ‚Ñì is
  the type argument of S at Iterable.

  
    This is the result of constraint matching for X
    using the constraint S  <:  Iterable<X>.
    Note that when S implements a class like Map or Iterable,
    it cannot be a subtype of Null
    (<ref>).
  
  * 
  If S implements Map,
  the inferred key and value type pair of ‚Ñì is (K, V),
  where K is the first and V the second type argument
  of S at Map.

  
    This is the result of constraint matching for X and Y using
    the constraint S  <:  Map<X,  Y>.

    Note that this case and the previous case
    can match on the same element simultaneously
    when S implements both Iterable and Map.
    The same situation arises several times below.
    In such cases we rely on other elements to disambiguate.
  
  * 
  If S is  then
  the inferred element type of ‚Ñì is ,
  and the inferred key and value type pair of ‚Ñì is
  (, ).

  
    We produce both an element type and a key and value type pair here,
    and rely on other elements to disambiguate.
  
  * 
  If S is Null and the spread operator is ...? then
  the inferred element type of ‚Ñì is Null,
  and the inferred key and value type pair (Null, Null).

  * 
  Otherwise, a compile-time error occurs.



Otherwise, ifPis Set<P_e> then letSbe
the inferred type ofein context Iterable<P_e>, and then:


  * 
  If S implements Iterable,
  the inferred element type of ‚Ñì is
  the type argument of S at Iterable.
  
    This is the result of constraint matching for X using
    the constraint S <: Iterable<X>.
  
  * 
  If S is ,
  the inferred element type of ‚Ñì is .

  * 
  If S is Null and the spread operator is ...?,
  the inferred element type of ‚Ñì is Null.

  * 
  Otherwise, a compile-time error occurs.

Otherwise, ifPis Map<P_k,  P_v> then letSbe
the inferred type ofein contextP, and then:


  * 
  If S implements Map,
  the inferred key and value type pair of ‚Ñì is (K, V),
  where K is the first and V the second type argument of
  S at Map.
  
    This is the result of constraint matching for X and Y using
    the constraint S <: Map<X,  Y>.
  
  * 
  If S is ,
  the inferred key and value type pair of ‚Ñì is

  (, ).

  * 
  If S is Null and the spread operator is ...?,
  the inferred key and value type pair (Null, Null).

  * 
  Otherwise, a compile-time error occurs.


If element
In this case‚Ñìis of the form
  (b)  ‚Ñì_1 or
  (b)  ‚Ñì_1    ‚Ñì_2.
The conditionbis always inferred with a context type of bool.

Assume that `  ‚Ñì_2' is not present. Then:

  * 
  If the inferred element type of ‚Ñì_1 is S,
  the inferred element type of ‚Ñì is S.

  * 
  If the inferred key and value type pair of ‚Ñì_1 is (K, V),
  the inferred key and value type pair of ‚Ñì is (K, V).


Otherwise, `  ‚Ñì_2' is present.
It is a compile error if‚Ñì_1must be a set and‚Ñì_2must be a map,
or vice versa.


This means that one cannot spread a map on one branch and a set on the other.
Since  provides both an element type and a key and value type pair,
a  spread in either branch does not cause the error to occur.


Then:


  * 
  If the inferred element type of ‚Ñì_1 is S_1 and
  the inferred element type of ‚Ñì_2 is S_2,
  the inferred element type of ‚Ñì is
  the least upper bound of S_1 and S_2.

  * 
  If the inferred key and value type pair of e_1 is
  (K_1, V_1)
  and the inferred key and value type pair of e_2 is
  (K_2, V_2),
  the inferred key and value type pair of ‚Ñì is
  (K, V),
  where K is the least upper bound of K_1 and K_2, and
  and V is the least upper bound of V_1 and V_2.


For element
In this case‚Ñìis of the form
?    (P)  ‚Ñì_1
wherePis derived from forLoopParts and
`?' indicates that  may be present or absent.

The same compile-time errors occur for‚Ñìas
the errors that would occur with the corresponding  statement
?    (P)  {},
located in the same scope as‚Ñì.
Moreover, the errors and type analysis of‚Ñìis performed
as if it occurred in the body scope of said  statement.


For instance, if P is of the form
  v    e_1
then the variable v is in scope for ‚Ñì.


Inference for the parts
(
such as the iterable expression of a for-in,
or the forInitializerStatement of a for loop
)
is done as for the corresponding  statement,
including  if and only if the element includes .


  * 
  If the inferred element type of ‚Ñì_1 is S then
  the inferred element type of ‚Ñì is S.

  * 
  If the inferred key and value type pair of e_1 is (K, V),
  the inferred key and value type pair of ‚Ñì is (K, V).

In other words, inference flows upwards from the body element.


Finally, we define
type inference on a set or map literal
  type inference!set or map literal
as a whole.
Assume that collection is derived from setOrMapLiteral,
and the context type for collection isP.


  * 
  If collection is unambiguously a set:

  
  * 
    If P is  then
    the static type of collection is Set<T>
    where T is the least upper bound of
    the inferred element types of the elements.
  
  * 
    Otherwise, the static type of collection is T
    where T is determined by downwards inference.

    
      Note that the inference will never produce a key and value type pair
      with the given context type.
    

  The static type of collection is then Set<T>.

  * 
  If collection is unambiguously a map
  where P is Map<P_k,  P_v> or P is 
  and the inferred key and value type pairs are
  KV1n:

  If P_k is  or P is ,
  the static key type of collection is K
  where K is the least upper bound of K1n.
  Otherwise the static key type of collection is K
  where K is determined by downwards inference.

  If P_v is  or P is ,
  the static value type of collection is V
  where V is the least upper bound of V1n.
  Otherwise the static value type of collection is V
  where V is determined by downwards inference.

  
    Note that inference will never produce a element type here
    given this downwards context.
  

  The static type of collection is then Map<K,  V>.

  * 
  Otherwise, collection is still ambiguous,
  the downwards context for the elements of collection
  is ,
  and the disambiguation is done using
  the immediate elements of collection as follows:

  
  * 
    If all elements can be a set,
    and at least one element must be a set,
    then collection is a set literal with
    static type Set<T> where T is
    the least upper bound of the element types of the elements.
  
  * 
    If all elements can be a map,
    and at least one element must be a map, then e is
    a map literal with static type Map<K,  V> where K is
    the least upper bound of the key types of the elements and V is
    the least upper bound of the value types.
  
  * 
    Otherwise, a compile-time error occurs.
    In this case the literal cannot be disambiguated.
This last error can occur if the literal must be both a set and a map.
Here is an example:
 iterable = [1, 2];
 map = {1: 2};
 ambiguous = {...iterable, ...map}; // Compile-time error

Or, if there is nothing indicates that it is either a set or a map:
 dyn;
 ambiguous = {...dyn}; // Compile-time error

  ¬ß.¬ß.¬ß Sets
sets
A set literalliteral!set denotes a set object.
The grammar rule for setOrMapLiteral which covers
set literals as well as map literals occurs elsewhere
(<ref>).
A set literal consists of zero or more collection literal elements
(<ref>).
A term derived from setOrMapLiteral
may be a set literal or a map literal,
and it is determined via a disambiguation step
whether it is a set literal or a map literal
(<ref>, <ref>).


When a given set literalehas no type arguments,
the type argumentTis selected as specified elsewhere
(<ref>),
andeis henceforth treated as
(<ref>)
<T>e.


The static type of a set literal of the form <T>e
is Set<T>
(<ref>).

Letebe a set literal of the form
<T>{‚Ñì1m}.
It is a compile-time error if a leaf element ofeis a
mapElement.
It is a compile-time error if, for somej ‚àà1 .. m,‚Ñì_jdoes not have an element type,
or the element type of‚Ñì_jmay not be assigned toT.


A set may contain zero or more objects.
Sets have a method which can be used to insert objects;
this will incur a dynamic error if the set is not modifiable.
Otherwise, when inserting an objecto_newinto a sets,
if an objecto_oldexists inssuch that
o_old == o_new evaluates to 
then the insertion makes no changes tos;
if no such object exists,o_newis added tos;
in both cases the insertion completes successfully.


A set is ordered: iteration over the elements of a set
occurs in the order the elements were added to the set.


The system libraries define many members for the type Set,
but we specify only the minimal set of requirements
which are used by the language itself.

Note that an implementation may require
consistent definitions of several members
of a class implementing Set in order to work correctly.
For instance, there may be a getter hashCode which is required
to have a behavior which is in some sense consistent with operator ==.
Such constraints are documented in the system libraries.

If a set literalebegins with the reserved word 
oreoccurs in a constant context
(<ref>),
it is a
constant set literalliteral!set!constant
which is a constant expression
(<ref>)
and therefore evaluated at compile time.
Otherwise, it is a
run-time set literalliteral!set!run-time
and it is evaluated at run time.
Only run-time set literals can be mutated after they are created.

Attempting to mutate a constant set literal will result in a dynamic error.





Note that the element expressions of a constant set literal
occur in a constant context
(<ref>),
which means that  modifiers need not be specified explicitly.

It is a compile-time error if
a collection literal element in a constant set literal
is not a constant expression.
It is a compile-time error if
an element in a constant set literal
does not have primitive equality
(<ref>).
It is a compile-time error if two elements of a constant set literal are equal
according to their == operator
(<ref>).
It is a compile-time error if the type argument of a constant set literal
(no matter whether it is explicit or inferred)
is not a constant type expression
(<ref>).


The binding of a formal type parameter of an enclosing class or function
is not known at compile time,
so we cannot use such type parameters inside constant expressions.

The value of a constant set literal
?  <T>{‚Ñì1m}
is an objectowhose class implements the built-in class
Set<t>
wheretis the actual value ofT(<ref>),
and whose contents is the set of objects in
the object sequence o1n obtained by
evaluation of ‚Ñì1m
(<ref>).
The elements ofooccur in the same order as
the objects in said object sequence
(which can be observed by iteration).


Let ?  <T_1>{ ‚Ñì_11, ‚Ä¶, ‚Ñì_1m_1 }
and ?  <T_2>{ ‚Ñì_21, ‚Ä¶, ‚Ñì_2m_2 }
be two constant set literals.
Leto_1with contentso_11, ‚Ä¶, o_1nand actual type argumentt_1respectivelyo_2with contentso_21, ‚Ä¶, o_2nand actual type argumentt_2be the result of evaluating them.
Then identical(o_1, o_2) evaluates to  iff

t_1 == t_2 and identical(o_1i, o_2i)
evaluates to  for alli ‚àà1 .. n.


In other words, constant set literals are canonicalized if they have
the same type argument and the same values in the same order.
Two constant set literals are never identical
if they have a different number of elements.
There is no need to consider canonicalization
for other instances of type Set,
because such instances cannot be
the result of evaluating a constant expression.

A run-time set literal <T>{‚Ñì1n}
is evaluated as follows:

  * 
  The elements ‚Ñì1m are evaluated
  (<ref>),
  to an object sequence o1n.

  * 
  A fresh object (<ref>) o
  implementing the built-in class Set<t> is created,
  where t is the actual value of T
  (<ref>).

  * 
  For each object o_j in o1n, in order,
  o_j is inserted into o.
  
    Note that this leaves o unchanged when o already contains
    and object o which is equal to o_j according to operator ==.
  
  * 
  The result of the evaluation is o.

The objects created by set literals do not override
the == operator inherited from the Object class.




  ¬ß.¬ß.¬ß Maps
maps
A map literalliteral!map denotes a map object,
which is a mapping from keys to values.
The grammar rule for setOrMapLiteral which covers both
map literals and set literals occurs elsewhere
(<ref>).
A map literal consists of zero or more collection literal elements
(<ref>).
A term derived from setOrMapLiteral
may be a set literal or a map literal,
and it is determined via a disambiguation step
whether it is a set literal or a map literal
(<ref>, <ref>).


When a given map literalehas no type arguments,
the type argumentsKandVare selected as specified elsewhere
(<ref>),
andeis henceforth treated as
(<ref>)
<K, V>e.


The static type of a map literal of the form <K, V>e
is Map<K, V>
(<ref>).

Letebe a map literal of the form
<K, V>{‚Ñì1m}.
It is a compile-time error if a leaf element ofeis an
expressionElement.
It is a compile-time error if, for somej ‚àà1 .. m,‚Ñì_jdoes not have a key and value type pair;
or the key and value type pair of‚Ñì_jis(K_j, V_j),
andK_jmay not be assigned toKorV_jmay not be assigned toV.


A map object consists of zero or more map entries.
Each entry has a key and a value,
and we say that the map
bindsmap!binds or
mapsmap!maps
the key to the value.
A key and value pair is
added to a map using operator []=,
and the value for a given key is retrieved from a map using operator [].
The keys of a map are treated similarly to a set
(<ref>):
When binding a keyk_newto a valuevin a mapm(as in m[k_new] = v),
ifmalready has a keyk_oldsuch that
k_old == k_new evaluates to ,mwill bindk_oldtov;
otherwise
(when no such key k_old exists),
a binding fromk_newtovis added tom.


A map is ordered: iteration over the keys, values, or key/value pairs
occurs in the order in which the keys were added to the set.


The system libraries support many operations on an instance
whose type implements Map,
but we specify only the minimal set of requirements
which are used by the language itself.

Note that an implementation may require
consistent definitions of several members
of a class implementing Map in order to work correctly.
For instance, there may be a getter hashCode which is required
to have a behavior which is in some sense consistent with operator ==.
Such constraints are documented in the system libraries.

If a map literalebegins with the reserved word ,
or ifeoccurs in a constant context
(<ref>),
it is a
constant map literalliteral!map!constant
which is a constant expression
(<ref>)
and therefore evaluated at compile time.
Otherwise, it is a
run-time map literalliteral!map!run-time
and it is evaluated at run time.
Only run-time map literals can be mutated after they are created.

Attempting to mutate a constant map literal will result in a dynamic error.





Note that the key and value expressions of a constant map literal
occur in a constant context
(<ref>),
which means that  modifiers need not be specified explicitly.

It is a compile-time error
if a collection literal element in a constant map literal is not constant.
It is a compile-time error if
a key in a constant map literal
does not have primitive equality
(<ref>).
It is a compile-time error if two keys of a constant map literal are equal
according to their == operator
(<ref>).
It is a compile-time error if a type argument of a constant map literal
(no matter whether it is explicit or inferred)
is not a constant type expression
(<ref>).


The binding of a formal type parameter of an enclosing class or function
is not known at compile time,
so we cannot use such type parameters inside constant expressions.

The value of a constant map literal
?  <T_1, T_2>{‚Ñì1m}
is an objectowhose class implements the built-in class
Map<t_1,  t_2>,
wheret_1andt_2is the actual value ofT_1respectivelyT_2(<ref>).
The key and value pairs ofois
the pairs of the object sequence kv1n obtained by
evaluation of ‚Ñì1m
(<ref>),
in that order.


Let ?  <U_1, V_1>{‚Ñì1m_1}
and ?  <U_2, V_2>{‚Ñì1m_2}
be two constant map literals.
Leto_1with contents k_1v_11n
and actual type argumentsu_1,v_1respectivelyo_2with contents k_2v_21n
and actual type argumentu_2,v_2be the result of evaluating them.
Then identical(o_1, o_2) evaluates to  iff
u_1 == u_2, v_1 == v_2,
identical(k_1i, k_2i), and
identical(v_1i, v_2i)
for alli ‚àà1 .. n.


In other words, constant map literals are canonicalized.
There is no need to consider canonicalization
for other instances of type Map,
because such instances cannot be
the result of evaluating a constant expression.

A run-time map literal
<T_1, T_2>{‚Ñì1m}
is evaluated as follows:

  * 
  The elements ‚Ñì1m are evaluated
  (<ref>),
  to an object sequence kv1n.

  * 
  A fresh instance (<ref>) o
  whose class implements the built-in class Map<t_1,  t_2>
  is allocated,
  where t_1 and t_2 are the actual values of T_1 respectively T_2
  (<ref>).

  * 
  The operator []= is invoked on o
  with first argument k_i and second argument v_i,
  for each i ‚àà 1 .. n, in that order.

  * 
  The result of the evaluation is o.

The objects created by map literals do not override
the == operator inherited from the Object class.




 ¬ß.¬ß Throw
throw
The throw expression is used to throw an exception.


<throwExpression> ::=  <expression>

<throwExpressionWithoutCascade> ::=  <expressionWithoutCascade>

Evaluation of a throw expression of the form
e;
proceeds as follows:


The expressioneis evaluated to an objectv(<ref>).


There is no requirement that the expression e must evaluate to
any special kind of object.

Ifvis the null object (<ref>), then a NullThrownError is thrown.
Otherwise lettbe a stack trace corresponding to the current execution state,
and the  statement throws withvas exception object
andtas stack trace (<ref>).


Ifvis an instance of class Error or a subclass thereof,
and it is the first time that Error object is thrown,
the stack tracetis stored onvso that it will be returned
by the stackTrace getter inherited from Error.


If the same Error object is thrown more than once,
its stackTrace getter will return the stack trace from
the first time it was thrown.

The static type of a throw expression is.




 ¬ß.¬ß Function Expressions
functionExpressions
A function literalliteral!function
is an anonymous declaration and an expression
that encapsulates an executable unit of code.










<functionExpression> ::= <formalParameterPart> <functionExpressionBody>

<functionExpressionBody> ::= ? `=>' <expression>
   ( `*'? |  `*')? <block>

The grammar does not allow a function literal to declare a return type,
but it is possible for a function literal to have a
declared return typeliteral!function!declared return type,
because it can be obtained by means of type inference.
Such a return type is included
when we refer to the declared return type of a function.


Type inference will be specified in a future version of this document.
Currently we consider type inference to be a phase that has completed,
and this document specifies the meaning of Dart programs
where inferred types have already been added.

We say that a typeTderives a future typetype!derives a future typeFin the following cases, using the first applicable case:




  * 
  If T is a type which is introduced by
  a class, mixin, or enum declaration,
  and if T or a direct or indirect superinterface
  (<ref>)
  of T is Future<U> for some U,
  then T derives the future type Future<U>.

  * 
  If T is the type FutureOr<U> for some U,
  then T derives the future type FutureOr<U>.

  * 
  If T is S? for some S, and
  S derives the future type F,
  then T derives the future type F?.

  * 
  If T is a type variable with bound B, and
  B derives the future type F,
  then T derives the future type F.

  * 
    There is no rule for the case where T is of the form X & S
    because this will never occur
    (this concept is only used in , which is defined below).
  
When none of these cases are applicable,
we say thatTdoes not derive a future type.


Note that if T derives a future type F then TF,
and F is always of the form G<...> or G<...>?,
where G is Future or FutureOr. The proof is by induction on the
structure of T:


  * 
  If T is a type which is introduced by
  a class, mixin, or enum declaration,
  and if T or a direct or indirect superinterface
  (<ref>)
  of T is Future<U> for some U, then, letting
  G = Future and F = G<U>, T <: F.

  * 
  If T is the type FutureOr<U> for some U, then by reflexivity,
  T <: FutureOr<U>. Letting G = FutureOr and
  F = G<U>, it follows that T <: F.

  * 
  If T is S? for some S, and
  S derives the future type F',
  then by the induction hypothesis, S <: F', where F' is of the form
  G'<U> or G'<U>? and G' is Future or
  FutureOr. Therefore, S? <: F'?, and by substitution,
  T <: F'?. Since T?? = T? for all T, it follows that
  T <: G'<U>?. So, letting G = G' and F = G<U>?,
  it follows that T <: F.

  * 
  If T is a type variable with bound B, and
  B derives the future type F,
  then by the induction hypothesis, B <: F', where F' is of the form
  G'<U> or G'<U>? and G' is Future or
  FutureOr. Also, since B is the bound of T, T <: B, so by
  transitivity, T <: F'. Therefore, letting G = G' and F = F', it
  follows that T <: F.


Also note that 'derives' in this context refers to the computation
where a type T is given, the supertypes of T are searched,
and a type F of one of those forms is selected.
There is no connection to the notion of a 'derived class' meaning 'subclass'
that some programming language communities use.

We define the auxiliary function
Tflatten(t)@flatten(T)
as follows, using the first applicable case:


  *  If T is X & S
  for some type variable X and type S then
  
  *  if S derives a future type U
    then TU.
  
  *  otherwise,
    TX.
  
  *  If T derives a future type Future<S>
  or FutureOr<S>
  then TS.


  *  If T derives a future type Future<S>? or
  FutureOr<S>? then TS?.


  *  Otherwise, TT.

This definition guarantees that for any type T,
T <: FutureOr<T>. The proof is by induction on the
structure of T:


  *  If T is X & S then
  
  *  if S derives a future type U,
    then T <: S and S <: U, so T <: U.
    By the induction hypothesis, U <: FutureOr<U>.
    Since T = U in this case, it follows that
    U <: FutureOr<T>, and so
    T <: FutureOr<T>.
  
  *  otherwise, T <: X.
    By the induction hypothesis, X <: FutureOr<X>.
    Since T = X in this case, it follows that
    U <: FutureOr<T>, and so
    T <: FutureOr<T>.
  
  *  If T derives a future type Future<S>
  or FutureOr<S>, then, since Future<S> <: FutureOr<S>,
  it follows that T <: FutureOr<S>. Since T = S
  in this case, it follows that T <: FutureOr<T>.


  *  If T derives a future type Future<S>? or
  FutureOr<S>?, then, since Future<S>? <: FutureOr<S>?,
  it follows that T <: FutureOr<S>?.
  FutureOr<S>? <: FutureOr<S?> for any type S (this can be shown
  using the union type subtype rules and from
  Future<S> <: Future<S?> by covariance), so by transivitity,
  T <: FutureOr<S?>. Since T = S? in this case,
  it follows that T <: FutureOr<T>.


  *  Otherwise, T = T, so
  FutureOr<T> = FutureOr<T>. Since
  T <: FutureOr<T>, it follows that
  T <: FutureOr<T>.

Positional, arrow
The static type of a function literal of the form

<>(T_1 a_1, ‚Ä¶, T_n a_n, [T_n+1 x_n+1 = d_1, ‚Ä¶, T_n+k x_n+k = d_k]) => e
is
T_0,


whereT_0is the static type ofe.

Positional, arrow, future
The static type of a function literal of the form

<>(T_1 a_1, ‚Ä¶, T_n a_n, [T_n+1 x_n+1 = d_1, ‚Ä¶, T_n+k x_n+k = d_k])  => e
is
Future<T_0>,


whereT_0is the static type ofe.

Named, arrow
The static type of a function literal of the form

<>(T_1 a_1, ‚Ä¶, T_n a_n,{T_n+1 x_n+1 = d_1, ‚Ä¶, T_n+k x_n+k = d_k}) => e
is
T_0,


whereT_0is the static type ofe.

Named, arrow, future
The static type of a function literal of the form

<>(T_1 a_1, ‚Ä¶, T_n a_n,{T_n+1 x_n+1 = d_1, ‚Ä¶, T_n+k x_n+k = d_k})  => e
is
Future<T_0>,


whereT_0is the static type ofe.

Positional, block
The static type of a function literal of the form

<XBS>(T_1 a_1, ‚Ä¶, T_n a_n, [T_n+1 x_n+1 = d_1, ‚Ä¶, T_n+k x_n+k= d_k]) {s}
is

Positional, block, future
The static type of a function literal of the form

<>(T_1 a_1, ‚Ä¶, T_n a_n, [T_n+1 x_n+1 = d_1, ‚Ä¶, T_n+k x_n+k = d_k]) {s}
is

Future.

Positional, block, stream
The static type of a function literal of the form

<>(T_1 a_1, ‚Ä¶, T_n a_n, [T_n+1 x_n+1 = d_1, ‚Ä¶, T_n+k x_n+k= d_k]) *{s}
is

Stream.

Positional, block, iterable
The static type of a function literal of the form

<>(T_1 a_1, ‚Ä¶, T_n a_n, [T_n+1 x_n+1 = d_1, ‚Ä¶, T_n+k x_n+k= d_k]) *{s}
is

Iterable.

Named, block
The static type of a function literal of the form

<>(T_1 a_1, ‚Ä¶, T_n a_n, [T_n+1 x_n+1 = d_1, ‚Ä¶, T_n+k x_n+k= d_k]) {s}
is

.

Named, block, future
The static type of a function literal of the form

<>(T_1 a_1, ‚Ä¶, T_n a_n,{T_n+1 x_n+1 = d_1, ‚Ä¶, T_n+k x_n+k = d_k}) {s}
is

Future.

Named, block, stream
The static type of a function literal of the form

<>(T_1 a_1, ‚Ä¶, T_n a_n,{T_n+1 x_n+1 = d_1, ‚Ä¶, T_n+k x_n+k = d_k}) *{s}
is

Stream.

Named, block, iterable
The static type of a function literal of the form

<>(T_1 a_1, ‚Ä¶, T_n a_n,{T_n+1 x_n+1 = d_1, ‚Ä¶, T_n+k x_n+k = d_k}) *{s}
is

Iterable.

In all of the above cases,
the type argument lists are omitted whenm=0,
and wheneverT_iis not specified,i ‚àà1 .. n+k,
it is considered to have been specified as .


Evaluation of a function literal yields a function objecto.


The run-time type of o is specified based on
the static type T of the function literal
and the binding of type variables occurring in T
at the occasion where the evaluation occurred
(<ref>).


 ¬ß.¬ß This
this
The reserved word  denotes
the target of the current instance member invocation.


<thisExpression> ::= 
The static type of  is the interface of the
immediately enclosing class, enum, or mixin, if any.
The static type of  is
the  type of the enclosing extension, if any
(<ref>).


If none of those declarations exist,
an occurrence of  is a compile-time error
(<ref>).

It is a compile-time error if  appears, implicitly or explicitly,
in a top-level function or variable initializer, in a factory constructor,
or in a static method or variable initializer,
or in the initializing expression of a non-late instance variable.




 ¬ß.¬ß Instance Creation
instanceCreation
Instance creation expressions generally produce instances
and invoke constructors to initialize them.


The exception is that
a factory constructor invocation works like a regular function call.
It may of course evaluate an instance creation expression and thus
produce a fresh instance,
but no fresh instances are created as a direct consequence of
the factory constructor invocation.

It is a compile-time error if
the typeTin an instance creation expression of one of the forms

T.ùïÄ(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k),

T(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k),

T.ùïÄ(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k),

T(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
is an enumerated type (<ref>).




  ¬ß.¬ß.¬ß New
new
The new expression invokes a constructor (<ref>).


<newExpression> ::=  <constructorDesignation> <arguments>

Letebe a new expression of the form

T.ùïÄ(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
or the form

T(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k).


It is a compile-time error ifTis not
a class or a parameterized type accessible in the current scope,
or ifTis a parameterized type which is not a class.

For instance,  F<int>() is an error if F is a type alias
that does not denote a class.

IfTis a parameterized type (<ref>)
S<U_1, ‚Ä¶, U_m>,
letRbe the generic classS,
and let
X_1  B_1, ‚Ä¶, X_p  B_p
be the formal type parameters ofS.
IfTis not a parameterized type, letRbeT.


  * 
  If e is of the form
  T.ùïÄ(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
  it is a compile-time error if R.ùïÄ is not the name of
  a constructor declared by R, or ùïÄ is not accessible.

  * 
  If e is of the form
  T(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
  it is a compile-time error if R is not the name of
  a constructor declared by R.

Letqbe the above-mentioned constructor named R.ùïÄ orR.


It is a compile-time error ifRis abstract
andqis not a factory constructor.
It is a compile-time error ifRis a non-generic class
andTis a parameterized type.


It is a compile-time error ifRis a generic class
andTis not a parameterized type.
It is a compile-time error ifRis a generic class,Tis a parameterized type, andm ‚â† p.
That is, the number of type arguments is incorrect.
It is a compile-time error ifRis a generic class,Tis a parameterized type,
andTis not regular-bounded
(<ref>).


Ifqis a redirecting factory constructor,
it is a compile-time error ifqin some number of
redirecting factory redirections redirects to itself.

It is possible and allowed for a redirecting factory q'
to enter an infinite loop, e.g.,
because q' redirects to a non-redirecting factory constructor
q‚Äù whose body uses q' in an instance creation expression.
Only loops that consist exclusively of redirecting factory redirections
are detected at compile time.

LetS_ibe the static type of
the formal parameter of the constructor R.ùïÄ (respectivelyR)
corresponding to the actual argumenta_i,i ‚àà1 .. n+k.
It is a compile-time error if the static type ofa_i, i ‚àà1 .. n + kis not assignable to[U_1/X_1, ‚Ä¶, U_m/X_m]S_i.

The non-generic case is covered with m = 0.

The static type ofeisT.


Evaluation ofeproceeds as follows:


First, the argument part

<U_1, ‚Ä¶, U_m>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
is evaluated, yielding the evaluated actual argument part

<u_1, ‚Ä¶, u_m>(o_1, ‚Ä¶, o_n, x_n+1: o_n+1, ‚Ä¶, x_n+k: o_n+k).

Note that the non-generic case is covered by letting m = 0.
If for anyj ‚àà1 .. n + kthe run-time type ofo_jis not a subtype of[u_1/X_1, ‚Ä¶, u_m/X_m]S_j,
a dynamic type error occurs.


Non-loaded deferred constructors
IfTis a deferred type with prefixp,
then ifphas not been successfully loaded,
a dynamic error occurs.

Generative constructors
Whenqis a generative constructor
(<ref>)
evaluation proceeds to allocate a fresh instance
(<ref>),i, of classT.





Thenqis executed to initializeiwith respect to
the bindings that resulted from the evaluation of the argument list, and,
ifRis a generic class,
with its type parameters bound tou_1, ‚Ä¶, u_m.


If execution ofqcompletes normally (<ref>),eevaluates toi.
Otherwise execution ofqthrows an exception objectxand stack tracet,
and then evaluation ofealso throws exception objectxand stack tracet(<ref>).

Redirecting factory constructors
Whenqis a redirecting factory constructor
(<ref>)
of the form ? T(p_1, ‚Ä¶, p_n+k) = c; or
of the form ? T.ùïÄ(p_1, ‚Ä¶, p_n+k) = c;
where ? indicates that  may be present or absent,
the remaining evaluation ofeis equivalent to
evaluating
c(v_1, ‚Ä¶, v_n, x_n+1: v_n+1, ‚Ä¶, x_n+k: v_n+k)
in an environment wherev_jis a fresh variable bound too_jforj ‚àà1 .. n + k, andX_jis bound tou_jforj ‚àà1 .. m.

We need access to the type variables because c may contain them.

Non-redirecting factory constructors
Whenqis a non-redirecting factory constructor,
the body ofqis executed with respect to
the bindings that resulted from the evaluation of the argument list,
and with the type parameters, if any, ofqbound to
the actual type argumentsu_1, ‚Ä¶, u_m.
If this execution returns an object
(<ref>)
theneevaluates to the returned object.
Otherwise, if the execution completes normally or returns with no object,
theneevaluates to the null object (<ref>).
Otherwise the execution throws an exceptionxand stack tracet,
and then evaluation ofealso throwsxandt(<ref>).


A factory constructor can be declared in an abstract class and used safely,
as it will either produce a valid instance or throw.


  ¬ß.¬ß.¬ß Const
const
A constant object expression invokes a constant constructor
(<ref>).


<constObjectExpression> ::=  <constructorDesignation> <arguments>

Letebe a constant object expression of the form

T.ùïÄ(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
or the form

T(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k).


It is a compile-time error ifTis not
a class or a parameterized type accessible in the current scope,
or ifTis a parameterized type which is not a class.
It is a compile-time error ifTis a deferred type
(<ref>).

In particular, T must not be a type variable.

It is a compile-time error ifa_iis not a constant expression
for somei ‚àà1 .. n + k.


IfTis a parameterized type (<ref>)
S<U_1, ‚Ä¶, U_m>,
letRbe the generic classS,
and let
X_1  B_1, ‚Ä¶, X_p  B_p
be the formal type parameters ofS.
IfTis not a parameterized type, letRbeT.


IfTis a parameterized type,
it is a compile-time error ifU_jis not a constant type expression for anyj ‚àà1 .. m.


  * 
  If e is of the form
  T.ùïÄ(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
  it is a compile-time error if R.ùïÄ is not the name of
  a constant constructor declared by R, or ùïÄ is not accessible.

  * 
  If e is of the form
  T(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
  it is a compile-time error if R is not the name of
  a constant constructor declared by R.

Letqbe the above-mentioned constant constructor named R.ùïÄ orR.






It is a compile-time error ifRis abstract
andqis not a factory constructor.
It is a compile-time error ifRis a non-generic class
andTis a parameterized type.


It is a compile-time error ifRis a generic class
andTis not a parameterized type.
It is a compile-time error ifRis a generic class,Tis a parameterized type, andm ‚â† p.
That is, the number of type arguments is incorrect.
It is a compile-time error ifRis a generic class,Tis a parameterized type,
andTis not regular-bounded
(<ref>).


LetS_ibe the static type of
the formal parameter of the constructor R.ùïÄ (respectivelyR)
corresponding to the actual argumenta_i,i ‚àà1 .. n+k.
It is a compile-time error if the static type ofa_i, i ‚àà1 .. n + kis not assignable to[U_1/X_1, ‚Ä¶, U_m/X_m]S_i.

The non-generic case is covered with m = 0.

The static type ofeisT.


Evaluation ofeproceeds as follows:


Ifeis of the form
T.ùïÄ(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
letibe the value of the expressione':

T.ùïÄ(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k).


Let o be the result of an evaluation of e',
at some point in time of some execution of the program
in the library L where e occurs.
The result of an evaluation of e' in L
at some other time and/or in some other execution will
yield a result o', such that o' would be replaced by o
by canonicalization as described below.
This means that the value is well-defined.

Ifeis of the form
T(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k),
letibe the value of
T(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k).

Which is well-defined for the same reason.


  *  If during execution of the program,
  a constant object expression has already evaluated to
  an instance j of class R with type arguments U_i, 1 ‚â§ i ‚â§ m, then:
  
  *  For each instance variable f of i,
    let v_if be the value of the instance variable f in i, and
    let v_jf be the value of the instance variable f in j.
    If identical(v_if, v_jf)
    for all instance variables f in i
    then the value of e is j,
    otherwise the value of e is i.
  
  *  Otherwise the value of e is i.

In other words, constant objects are canonicalized.
In order to determine if an object is actually new, one has to compute it;
then it can be compared to any cached instances.
If an equivalent object exists in the cache,
we throw away the newly created object and use the cached one.
Objects are equivalent if
they have identical type arguments and identical instance variables.
Since the constructor cannot induce any side effects,
the execution of the constructor is unobservable.
The constructor need only be executed once per call site, at compile time.

It is a compile-time error if evaluation of a constant object
results in an uncaught exception being thrown.


To see how such situations might arise, consider the following examples:

 A { x;
   A(p): x = p * 10;
}
 IntPair { IntPair(.x, .y);
   int x;
   int y;
   *(v) =>  IntPair(x*v, y*v);
}
 a1 =  A(true); // compile-time error a2 =  A(5); // legal a3 =  A( IntPair(1,2)); // compile-time error
Due to the rules governing constant constructors,
evaluating the constructor A()
with the argument "x" or the argument  IntPair(1, 2)
would cause it to throw an exception, resulting in a compile-time error.
In the latter case, the error is caused by the fact that
 * can only be used with a few ‚Äúwell-known‚Äù types,
which is required in order to avoid running arbitrary code during
the evaluation of constant expressions.


 ¬ß.¬ß Spawning an Isolate
spawningAnIsolate
Spawning an isolate is accomplished via what is syntactically
an ordinary method call,
invoking one of the static methods spawnUri or spawn defined in
the Isolate class in the library dart:isolate.
However, such calls have the semantic effect of creating
a new isolate with its own memory and thread of control.


An isolate's memory is finite, as is the space available to
its thread's call stack.

It is possible for a running isolate to exhaust its memory or stack,
resulting in a dynamic error that cannot be effectively caught,
which will force the isolate to be suspended.


As discussed in section <ref>,
the handling of a suspended isolate is the responsibility of the runtime.


 ¬ß.¬ß Function Invocation
functionInvocation
Function invocation occurs in the following cases:
when a function expression (<ref>)
is invoked (<ref>),
when a method (<ref>),
getter (<ref>, <ref>)
or setter (<ref>)
is invoked,
or when a constructor is invoked
(either via instance creation (<ref>),
constructor redirection (<ref>),
or super initialization).
The various kinds of function invocation differ as to
how the function to be invoked,f, is determined,
as well as whether  (<ref>) is bound.
Oncefhas been determined,
formal type parameters offare bound to
the corresponding actual type arguments,
and the formal parameters offare bound to corresponding actual arguments.
When the body offis executed it will be executed
with the aforementioned bindings.


Executing a body of the form => e is equivalent to executing
a body of the form { return e; }.
Execution a body of the form  => e is equivalent to executing
a body of the form { return e; }.


Iffis synchronous and is not a generator (<ref>) then
execution of the body offbegins immediately.
If the execution of the body offreturns an objectv(<ref>),
the invocation evaluates tov.
If the execution completes normally or it returns without an object,
the invocation evaluates to the null object (<ref>).
If the execution throws an exception object and stack trace,
the invocation throws the same exception object and stack trace
(<ref>).


A complete function body can never break or continue
(<ref>)
because a  or  statement must always occur inside
the statement that is the target of the  or .
This means that a function body can only
either complete normally, throw, or return.
Completing normally or returning without an object is treated
the same as returning with the null object (<ref>),
so the result of executing a function body can always be used as
the result of evaluating an expression,
either by evaluating to an object, or by the evaluation throwing.

Iffis marked * (<ref>),
then a fresh instance (<ref>)iimplementing Iterable<U> is immediately returned,
whereUis the actual type
(<ref>)
corresponding to the element type off(<ref>).


A Dart implementation will need to provide
a specific implementation of Iterable
that will be returned by * methods.
A typical strategy would be to produce an instance of
a subclass of class IterableBase defined in dart:core.
The only method that needs to be added
by the Dart implementation in that case is iterator.

The iterable implementation must comply with
the contract of Iterable and should not
take any steps identified as exceptionally efficient in that contract.


The contract explicitly mentions a number of situations
where certain iterables could be more efficient than normal.
For example, by precomputing their length.
Normal iterables must iterate over their elements to determine their length.
This is certainly true in the case of a synchronous generator,
where each element is computed by a function.
It would not be acceptable to pre-compute the results of the generator
and cache them, for example.

When iteration over the iterable is started, by getting
an iteratorjfrom the iterable and calling moveNext(),
execution of the body offwill begin.
When execution of the body offcompletes (<ref>),

  *  If it returns without an object or it completes normally
  (<ref>),
  j is positioned after its last element,
  so that its current value is the null object
  (<ref>)
  and the current call to moveNext() on j returns false,
  as must all further calls.

  *  If it throws an exception object e and stack trace t
  then the current value of j is the null object
  (<ref>)
  and the current call to moveNext() throws e and t as well.
  Further calls to moveNext() must return false.

Each iterator starts a separate computation.
If the * function is impure,
the sequence of objects yielded by each iterator may differ.


One can derive more than one iterator from a given iterable.
Note that operations on the iterable itself can create distinct iterators.
An example would be length.
It is conceivable that different iterators might yield
sequences of different length.
The same care needs to be taken when writing * functions as when
writing an Iterator class.
In particular, it should handle multiple simultaneous iterators gracefully.
If the iterator depends on external state that might change,
it should check that the state is still valid after every yield
(and maybe throw a ConcurrentModificationError if it isn't).

Each iterator runs with its own shallow copies of all local variables;
in particular, each iterator has the same initial arguments,
even if their bindings are modified by the function.

Two executions of an iterator interact only via state outside the function.




Iffis marked  (<ref>),
then a fresh instance (<ref>)ois associated with the invocation,
where the dynamic type ofoimplements Future<T>,
whereTis the actual type
(<ref>)
corresponding to the future value type off.
Then the body offis executed until it either suspends or completes,
at which pointois returned.

The body of f may suspend during the evaluation of an  expression
or execution of an asynchronous  loop.

The futureois completed when execution of the body offcompletes
(<ref>).
If execution of the body returns an object,ois completed with that object.
If it completes normally or returns without an object,ois completed with the null object (<ref>),
and if it throws an exceptioneand stack tracet,ois completed with the erroreand stack tracet.
If execution of the body throws before the body suspends the first time,
completion ofohappens at some future time after the invocation has returned.

The caller needs time to set up error handling for the returned future,
so the future is not completed with an error
before it has been returned.

Iffis marked * (<ref>),
then a fresh instance (<ref>)simplementing Stream<U> is immediately returned,
whereUis the actual type
(<ref>)
corresponding to the element type off(<ref>).
Whensis listened to, execution of the body offwill begin.
When execution of the body offcompletes:

  *  If it completes normally or returns without an object
  (<ref>),
  then if s has been canceled
  then its cancellation future is completed with the null object (<ref>).

  *  If it throws an exception object e and stack trace t:
  
  *  If s has been canceled then its cancellation future is completed
    with error e and stack trace t.
  
  *  otherwise the error e and stack trace t are emitted by s.
  
  * s is closed.

The body of an asynchronous generator function
cannot break, continue or return with an object
(<ref>).
The first two are only allowed in contexts that
will handle the break or continue,
and return statements with an expression are not allowed
in generator functions.

When an asynchronous generator's stream has been canceled,
cleanup will occur in the  clauses (<ref>) inside the generator.
We choose to direct any exceptions that occur at this time
to the cancellation future rather than have them be lost.


  ¬ß.¬ß.¬ß Actual Argument Lists
actualArgumentLists
Actual argument lists have the following syntax:


<arguments> ::= `(' (<argumentList> `,'?)? `)'

<argumentList> ::= <namedArgument> (`,' <namedArgument>)*
   <expressionList> (`,' <namedArgument>)*

<namedArgument> ::= <label> <expression>

Argument lists allow an optional trailing comma after the last argument
(`,'?).
An argument list with such a trailing comma is equivalent in all ways to
the same parameter list without the trailing comma.
All argument lists in this specification are shown without a trailing comma,
but the rules and semantics apply equally to
the corresponding argument list with a trailing comma.


LetLbe an argument list of the form
(e_1 ‚Ä¶, e_m, y_m+1: e_m+1‚Ä¶, y_m+p: e_m+p)
and assume that the static type ofe_iisS_i,i ‚àà1 .. m+p.
The static argument list type ofLis then
(S_1 ‚Ä¶, S_m, S_m+1 y_m+1‚Ä¶, S_m+p y_m+p).


LetSbe the static argument list type

(S_1 ‚Ä¶, S_m, S_m+1 y_m+1‚Ä¶, S_m+p y_m+p)
and letPbe the formal parameter list

(T_1 x_1 ‚Ä¶, T_n x_n,[T_n+1 x_n+1 = d_1, ‚Ä¶, T_n+k x_n+k = d_k])
where each parameter may be marked 
(not shown, but allowed).


We say thatSis
a subtype match forPiffp = 0,n ‚â§m ‚â§n+k, andS_iis
a subtype ofT_ifor alli ‚àà1 .. m.
We say thatSis
an assignable match forPiffp = 0,n ‚â§m ‚â§n+k, andS_iis
assignable toT_ifor alli ‚àà1 .. m.


LetSbe the static argument list type

(S_1 ‚Ä¶, S_m, S_m+1 y_m+1‚Ä¶, S_m+p y_m+p)
and letPbe the formal parameter list

(T_1 x_1 ‚Ä¶, T_n x_n,{T_n+1 x_n+1 = d_1, ‚Ä¶, T_n+k x_n+k = d_k})
where each parameter may be marked 
(not shown, but allowed).


We say thatSis
a subtype match forPiffm = n,{y_m+1‚Ä¶, y_m+p} ‚äÜ{x_n+1‚Ä¶, x_n+k},S_iis a subtype ofT_ifor alli ‚àà1 .. m,
andS_iis a subtype ofT_jwhenevery_i = x_jandj ‚ààn + 1 .. n + k, for alli ‚ààm + 1 .. m + p.
We say thatSis an assignable match forPiffm = n,{y_m+1‚Ä¶, y_m+p} ‚äÜ{x_n+1‚Ä¶, x_n+k},S_iis assignable toT_ifor alli ‚àà1 .. m,
andS_iis assignable toT_jwhenevery_i = x_jandj ‚ààn + 1 .. n + k, for alli ‚ààm + 1 .. m + p.


In short, an actual argument list is a match for a formal parameter list
whenever the former can safely be passed to the latter.


  ¬ß.¬ß.¬ß Actual Argument List Evaluation
actualArguments
Function invocation involves evaluation of
the list of actual arguments to the function,
and binding of the results to the function's formal parameters.


When parsing an argument list, an ambiguity may arise because
the same source code could be one generic function invocation,
and it could be two or more relational expressions and/or shift expressions.
In this situation, the expression is always parsed
as a generic function invocation.






An example is f(a<B, C>(d)),
which may be an invocation of f passing
two actual arguments of type bool, or
an invocation of f passing the result returned by
an invocation of the generic function a.
Note that the ambiguity can be eliminated by omitting
the parentheses around the expression d,
or adding parentheses around one of the relational expressions.

When the intention is to pass
several relational or shift expressions as actual arguments
and there is an ambiguity, the source code can easily be adjusted
to a form which is unambiguous.
Also, we expect that it will be more common to have
generic function invocations as actual arguments
than having relational or shift expressions that happen to match up
and have parentheses at the end, such that the ambiguity arises.

Evaluation of an actual argument part of the form

<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_m, q_1: a_m+1, ‚Ä¶, q_l: a_m+l)
proceeds as follows:


The type argumentsA_1, ‚Ä¶, A_rare evaluated
in the order they appear in the program,
producing typest_1, ‚Ä¶, t_r.
The argumentsa_1, ‚Ä¶, a_m+lare evaluated
in the order they appear in the program,
producing objectso_1, ‚Ä¶, o_m+l.


Simply stated, an argument part consisting of s type arguments,
m positional arguments, and l named arguments is
evaluated from left to right.
Note that the type argument list is omitted when r = 0
(<ref>).


  ¬ß.¬ß.¬ß Binding Actuals to Formals
bindingActualsToFormals
In the following, the non-generic case is covered implicitly:
When the number of actual type arguments is zero
the entire type argument list <‚Ä¶> is omitted,
and similarly for empty type parameter lists (<ref>).

Consider an invocationiof a functionfwith
an actual argument part of the form
<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_m, q_1: a_m+1, ‚Ä¶, q_l: a_m+l).


Note that f denotes a function in a semantic sense,
rather than a syntactic construct.
A reference to this section is used in other sections
when the static analysis of an invocation is specified,
and the static type of f has been determined.
The function itself may have been obtained from a function declaration,
from an instance bound to  and an instance method declaration,
or as a function object obtained by evaluation of an expression.
Because of that, we cannot indicate here which syntactic construct
corresponds to f.

A reference to this section is also used in other sections
when actual arguments are to be bound to the corresponding formal parameters,
and f is about to be invoked, to specify the dynamic semantics.

We do not call f a `function object' here, because we do not wish to imply
that every function invocation must involve a separate evaluation
of an expression that yields a function object,
followed by an invocation of that function object.
For instance, an implementation should be allowed to compile the invocation
of a top-level function as a series of steps whereby a stack frame is
created, followed by a low-level jump to the generated code for the body.
So, in this section,
the word `function' is more low-level than `function object',
but `function' still denotes a semantic entity
which is associated with a function declaration,
even though there may not be a corresponding entity in the heap at run time.


It is a compile-time error ifq_j = q_kfor anyj k.


For a given typeT_0, we introduce the notion of a
T_0 bounded typetype!T0 bounded:T_0itself isT_0bounded;
ifBisT_0bounded andXis a type variable with boundBthenXisT_0bounded;
finally, ifBisT_0bounded andXis a type variable
thenX & BisT_0bounded.
In particular, a
 bounded typetype!dynamic bounded
is either  itself
or a type variable whose bound is  bounded,
or an intersection whose second operand is  bounded.
Similarly for a
 bounded typetype!function bounded.


A
function-type bounded typetype!function-type bounded
is a typeTwhich isT_0bounded whereT_0is a function type
(<ref>).
A function-type bounded typeThas an
associated function type
which is the unique function typeT_0such thatTisT_0bounded.


If the static type offis  bounded or  bounded,
no further static checks are performed on the invocationi(apart from separate static checks on subterms like arguments),
and the static type ofiis .
Otherwise, it is a compile-time error if the static type offis not
function-type bounded.


If no error occurred and the static analysis ofiis not complete
then the static typeT_foffis function-type bounded;
letFbe the associated function type ofT_f.


LetS_0be the return type ofF,
letX_1  B_1, ‚Ä¶, X_s  B_sbe the formal type parameters,
lethbe the number of required parameters,
letp_1, ‚Ä¶, p_nbe the positional parameters,
and letp_h+1, ‚Ä¶, p_h+kbe the optional parameters ofF.
LetS_ibe the static type of the formal parametersp_i, i ‚àà1 .. h+k,
and for eachqletS_qbe the type of the parameter namedq,
where each parameter type is obtained by replacingX_jbyA_j, j ‚àà1 .. s,
in the given parameter type annotation.
Finally, letT_ibe the static type ofa_i.


We have an actual argument list consisting of r type arguments,
m positional arguments, and l named arguments.
We have a function with s type parameters,
h required parameters, and k optional parameters.
Figure¬†<ref> shows how this situation arises.











#1#1
  Actual arguments:[ <r type>
      (
      [ m positional      l named ]) ]
  Declaration with named parameters: n = h[ <s type>
      (
      [   h required   k optional;           2c; n positional      k named;              ]) ]
  Declaration with optional positional parameters: n = h + k[ <s type>
      (
      [     h required     k optional;             2c; 2cn positional ]) ]
  Possible actual argument parts and formal parameter parts.


It is a compile-time error ifr ‚â† s.
It is a compile-time error ifr = sand for somej ‚àà1 .. s,A_j ‚âÆ: [A_1/X_1, ‚Ä¶, A_r/X_s]B_j.
It is a compile-time error unlessh ‚â§m ‚â§n.
Ifl > 0,
it is a compile-time error unlessFhas named parameters andq_j ‚àà{p_h+1, ‚Ä¶, p_h+k}, j ‚àà1 .. l.


That is, the number of type arguments must match the number of type parameters,
and the bounds must be respected.
We must receive at least the required number of positional arguments,
and not more than the total number of positional parameters.
For each named argument there must be a named parameter with the same name.

The static type ofiis[A_1/X_1, ‚Ä¶, A_r/X_s]S_0.


It is a compile-time error ifT_jmay not be assigned toS_j, j ‚àà1 .. m.
It is a compile-time error ifT_m+jmay not be assigned toS_q_j, j ‚àà1 .. l.


Consider the case where the function invocation in focus here is
an instance method invocation.
In that case, for each actual argument,
the corresponding parameter may be covariant.
However, the above assignability requirements apply equally
both when the parameter is covariant and when it is not.

Parameter covariance in an instance method invocation can be introduced by
a subtype of the statically known receiver type,
which means that any attempt to flag a given actual argument as dangerous
due to the dynamic type check that it will be subjected to
will be incomplete:
some actual arguments can be subjected to such a dynamic type check
even though this is not known statically at the call site.
This is not surprising for a mechanism like parameter covariance which is
designed for the very purpose of allowing developers to explicitly request
that this specific kind of compile-time safety is violated.
The point is that this mechanism postpones the enforcement of
the underlying invariant to run time,
and in return allows some useful program designs
that would otherwise be rejected at compile-time.

For the dynamic semantics,
letfbe a function withstype parameters andhrequired parameters;
letp_1, ‚Ä¶, p_nbe the positional parameters off;
and letp_h+1, ‚Ä¶, p_h+kbe the optional parameters declared byf.


An evaluated actual argument part

<t_1, ‚Ä¶, t_r>(o_1, ‚Ä¶, o_m, q_1: o_m+1, ‚Ä¶, q_l: o_m+l)
derived from an actual argument part of the form

<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_m, q_1: a_m+1, ‚Ä¶, q_l: a_m+l)
is bound to the formal type parameters and formal parameters offas follows:



Ifr = 0ands > 0then
iffdoes not have default type arguments
(<ref>)
then a dynamic error occurs.
Otherwise replace the actual type argument list:
Letrbesand lett_ifori ‚àà1 .. sbe the result of
instantiation to bound
(<ref>)
on the formal type parameters off,
substituting the actual values of any free type variables
(<ref>).
Otherwise, ifr ‚â† s, a NoSuchMethodError is thrown.



Ifl > 0andn ‚â† h, a NoSuchMethodError is thrown.

Ifm < h, orm > n, a NoSuchMethodError is thrown.

Furthermore, eachq_i, i ‚àà1 .. l,
must have a corresponding named parameter in the set{p_h+1, ‚Ä¶, p_h+k},
or a NoSuchMethodError is thrown.

Thenp_iis bound too_i, i ‚àà1 .. m,
andq_jis bound too_m+j, j ‚àà1 .. l.
All remaining formal parameters offare bound to their default values.


All of these remaining parameters are necessarily optional
and thus have default values.



It is a dynamic type error ift_iis not a subtype of the actual bound
(<ref>)
of theith type argument off, for actual type argumentst_1, ‚Ä¶, t_r.


It is a dynamic type error ifo_iis not the null object (<ref>)
and the actual type
(<ref>)
ofp_iis not a supertype of the dynamic type ofo_i, i ‚àà1 .. m.


It is a dynamic type error ifo_m+jis
not the null object and the actual type
(<ref>)
ofq_jis not a supertype of the dynamic type ofo_m+j, j ‚àà1 .. l.




  ¬ß.¬ß.¬ß Unqualified Invocation
unqualifiedInvocation
An unqualified function invocationihas the form

ùïÄ<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k),


where ùïÄ is an identifier.


Note that the type argument list is omitted when r = 0 (<ref>).

Perform a lexical lookup of ùïÄ
(<ref>)
from the location ofi.


Lexical lookup yields a declaration
LetDbe the declaration yielded by the lexical lookup of ùïÄ.


  * 
  When D is a type declaration, that is,
  a declaration of a class, mixin, enum, type alias, or type parameter,
  the following applies:
  If D is a declaration of a class C
  that has a constructor named C
  then the meaning of i depends on the context:
  If i occurs in a constant context
  (<ref>),
  then i is treated as
  (<ref>)
    i;
  if i does not occur in a constant context
  then i is treated as   i.
  If D is not a class declaration,
  or it declares a class named C that has no constructor named C,
  a compile-time error occurs.

  * 
  Otherwise, if D is a declaration of
  a local function,
  a library function, or
  a library or static getter, or a variable,
  then i is treated as
  (<ref>)
  a function expression invocation
  (<ref>).

  * 
  Otherwise, if D is
  a static method or getter
  (which may be implicitly induced by a static variable)
  in the enclosing class or mixin C,
  i is treated as
  (<ref>)
  C.i
  (<ref>).

  * 
  If D is an instance member of an extension E
  with type parameters X1k,
  i is treated as E<X1k>().i.
  Both the static analysis and evaluation
  proceeds with the transformed expression,
  so there is no need to further specify the treatment of i.

  
    In other words, inside E the instance members of E will shadow
    the instance members of the  type, that is,
    the extension has higher priority than the object interface.
    The opposite is true for invocations everywhere outside E.

    There is no need to consider an instance member of a class,
    because a lexical lookup in a class will never yield a declaration
    which is an instance member.
  
Lexical lookup yields an import prefix
When the lexical lookup of ùïÄ yields an import prefix,
a compile-time error occurs.
Lexical lookup yields nothing
When the lexical lookup of ùïÄ yields nothing,iis treated as
(<ref>)
the ordinary method invocation
.i
(<ref>).


This occurs when the lexical lookup has determined that
i must invoke an instance member of a class or an extension,
and the location of i can access ,
and the interface of the enclosing class has a member named ùïÄ,
or there is an applicable extension with such a member.
Both the static analysis and evaluation proceeds with
.i,
so there is no need to further specify the treatment of i.

Note that an unqualified invocation does not specify an evaluation semantics.
This is because every case which is not an error ends in the conclusion that
the unqualified invocation should be treated as some other construct,
which is specified elsewhere.


  ¬ß.¬ß.¬ß Function Expression Invocation
functionExpressionInvocation
A function expression invocationihas the form

e_f<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k),


wheree_fis an expression.


Note that the type argument list is omitted when r = 0
(<ref>).

Consider the situation wheree_fdenotes a classCthat contains a declaration of a constructor namedC,
or it is of the form e'_f.ùïÄ wheree'_fdenotes a classCthat contains a declaration of
a constructor named C.ùïÄ.
Ifioccurs in a constant context
(<ref>)
theniis treated as   i,
and ifidoes not occur in a constant context
theniis treated as   i.


When i is treated as another construct i',
both the static analysis and the dynamic semantics
is specified in the section about i'
(<ref>).

Otherwise, it is a compile-time error ife_fis a type literal.


This error was already specified elsewhere
(<ref>)
for the case where e_f is an identifier,
but e_f may also have other forms, e.g., p.C.

Otherwise, ife_fis an identifier ùïÄ, then ùïÄ must necessarily denote
a local function, a library function, a library or static getter,
or a variable as described above,
oriwould not have been treated as a function expression invocation.


Ife_fis a property extraction expression
(<ref>)
thenitreated as an ordinary method invocation
(<ref>).


a.b(x) is treated as a method invocation of method
b() on object a,
not as an invocation of getter b on a
followed by a function call (a.b)(x).
If a method or getter b exists, the two will be equivalent.
However, if b is not defined on a,
the resulting invocation of noSuchMethod() would differ.
The Invocation passed to noSuchMethod() would describe
a call to a method b with argument x in the former case,
and a call to a getter b (with no arguments) in the latter.

LetFbe the static type ofe_f.
IfFis an interface type that has a method named ,iis treated as
(<ref>)
the ordinary invocation

e_f.<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k).


Otherwise, the static analysis ofiis performed as specified
in Section¬†<ref>,
usingFas the static type of the invoked function,
and the static type ofiis as specified there.


Evaluation of a function expression invocation

e_f<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
proceeds to evaluatee_f, yielding an objecto.
Letfbe a fresh variable bound too.
Ifois a function object then the function invocation

f<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
is evaluated by binding actuals to formals
as specified in Section¬†<ref>,
and executing the body offwith those bindings;
the returned result is then the result of evaluatingi.


Otherwiseois not a function object.
Ifohas a method named 
the following ordinary method invocation is evaluated,
and its result is then the result of evaluatingi:

f.call<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k).


Otherwiseohas no method named .
A new instanceimof the predefined class Invocation is created,
such that:

  * im.isMethod evaluates to .

  * im.memberName evaluates to the symbol #call.

  * im.positionalArguments evaluates to an unmodifiable list
  whose dynamic type implements List<Object>,
  containing the objects resulting from evaluation of
  <Object>[a_1, ‚Ä¶, a_n].

  * im.namedArguments evaluates to an unmodifiable map
  whose dynamic type implements Map<Symbol, Object>,
  with the keys and values resulting from evaluation of

  <Symbol, Object>{#x_n+1: a_n+1, ‚Ä¶, #x_n+k: a_n+k}.

  * im.typeArguments evaluates to an unmodifiable list
  whose dynamic type implements List<Type>,
  with the values resulting from evaluation of

  <Type>[A_1, ‚Ä¶, A_r].

Then the method invocation f.noSuchMethod(im) is evaluated,
and its result is then the result of evaluatingi.


The situation where noSuchMethod is invoked can only arise
when the static type of e_f is .
The run-time semantics ensures that
a function invocation may amount to an invocation of
the instance method .
However, an interface type with a method named 
is not itself a subtype of any function type
(<ref>).


 ¬ß.¬ß Function Closurization
functionClosurization
Letfbe an expression denoting
a declaration of a top-level function, a local function,
a static method of a class, of a mixin, or of an extension
(<ref>);
or letfbe a function literal
(<ref>).
Evaluation offyields a function object
which is the outcome of a function closurization
applied to the declaration denoted byfrespectively to the function literalfconsidered as a function declaration.



Closurizationclosurization
denotes instance method closurization
(<ref>)
as well as function closurization,
and it is also used as a shorthand for either of them
when there is no ambiguity.


Function closurization applied to a function declarationfamounts to the creation of a function objectowhich is an instance of a classCwhose interface is
a subtype of the actual typeF(<ref>)
corresponding to the signature in the function declarationf,
using the current bindings of type variables, if any.
There does not exist a function typeF'which is a proper subtype ofFsuch thatCis a subtype ofF'.


If f is a static method or a top-level function
then o has primitive equality
(<ref>).

In other words, C has the freedom to be a proper subtype of
the function type that we can read off of the declaration of f
because it may need to be a specific internal platform defined class,
but C does not have the freedom to be a subtype of
a different and more special function type, and it cannot be Null.

An invocation ofowith a given argument list will bind actuals to formals
in the same way as an invocation off(<ref>),
and then execute the body offin the captured scope amended with the bound parameter scope,
yielding the same completion
(<ref>)
as the invocation offwould have yielded.


Lete_1ande_2be two constant expressions that both
evaluate to a function object which is obtained by function closurization
of the same function declaration.
In this case identical(e_1, e_2) shall evaluate to true.


That is, constant expressions whose evaluation is a function closurization
are canonicalized.


 ¬ß.¬ß Generic Function Instantiation
genericFunctionInstantiation






Generic function instantiation is a mechanism that yields
a non-generic function object based on a given generic function.


The essence of generic function instantiation
is to allow for ‚Äúcurried‚Äù invocations,
in the sense that a generic function can receive its actual
type arguments separately
(it must then receive all type arguments, not just some of them),
and that yields a non-generic function object.
The type arguments are passed implicitly, based on type inference;

a future version of Dart may allow for passing them explicitly.
Here is an example:
X fg<X  num>(X x) => x;

 A { X fs<X  num>(X x) => x;
}
 main() {
  X fl<X  num>(X x) => x;
  List<int (int)> functions = [fg, A.fs, fl];
}

Each function object stored in functions
has dynamic type int  (int),
and it is obtained by implicitly
‚Äúpassing the actual type argument int‚Äù
to the corresponding generic function.

f,G
Letfbe an expression whose static typeGis
T_0,X_j,B_j,s,p
a generic function type of the form
T_0XBsp
where (p) is derived from formalParameterList.
Note that s > 0 because G is generic.
Assume that the context type is a non-generic function typeF.
In this situation a compile-time error occurs
(<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>),
except when the following step succeeds:


Generic function type instantiation
  generic function type instantiation:
Type inference is applied toGwith context typeF,
and it yields the actual type argument list
T_j
T1s.


The generic function type instantiation fails
in the case where type inference fails,
in which case the above mentioned compile-time error occurs.
It will be specified in a future version of this document
how type inference computes T1s
(<ref>).

Assume that the generic function type instantiation succeeded.
Let F' denote the type[T_1/X_1, ‚Ä¶, T_s/X_s](T_0p).

Note that it is guaranteed that F' is assignable to F,
or inference would have failed.

Henceforth in the static analysis,
this occurrence offis considered to have static typeF'.


Execution offproceeds as follows.
Evaluatefto an objecto.

A dynamic error occurs ifois the null object.
Let S_0YB'sq be the dynamic type ofo(by soundness, this type is a subtype of G).fthen evaluates to a function objecto'with dynamic type[t_1/Y_1, ‚Ä¶, t_s/Y_s](S_0q),
wheret_jis the actual value ofT_j, forj ‚àà1 .. k.
An invocation ofo'with actual arguments args has
the same effect as an invocation ofowith actual type arguments t1s and actual arguments args.


Letf_1andf_2be two constant expressions that are subject to
generic function instantiation.
Assume thatf_1andf_2without a context type evaluate too_1respectivelyo_2such that identical(o_1, o_2) is true.
Assume that the given context types give rise to a successful
generic function type instantiation with
the same actual type arguments forf_1andf_2,
yielding the non-generic function objectso'_1respectivelyo'_2.
In this case identical(o'_1, o'_2) shall evaluate to true.


That is, constant expressions whose evaluation is
a generic function instantiation are canonicalized,
based on the underlying function and on the actual type arguments.
As a consequence, they are also equal according to operator ==.

Letg_1andg_2be two expressions
(which may or may not be constant)
that are subject to generic function instantiation.
Assume thatg_1andg_2without a context type evaluate too_1respectivelyo_2such that o_1 == o_2) is true.
Assume that the given context types give rise to a successful
generic function type instantiation with
the same actual type arguments forg_1andg_2,
yielding the non-generic function objectso'_1respectivelyo'_2.
In this case o'_1 == o'_2 shall evaluate to true.


When one or both of the expressions is not constant,
it is unspecified whether
identical(o_1,  o_2) evaluates to  or ,
but operator == yields true for equal function objects
instantiated with the same actual type arguments.

No notion of equality is appropriate when the type arguments differ,
even if the resulting function objects
turn out to have exactly the same type at run time,
because execution of two function objects that differ in these ways
can have different side-effects and return different results
when executed starting from exactly the same state.


 ¬ß.¬ß Lookup
lookup
A lookup is a procedure which selects
a concrete instance member declaration based on a traversal of
a sequence of classes, starting with a given classCand proceeding with the superclass of the current class at each step.
A lookup may be part of the static analysis, and it may be performed
at run time. It may succeed or fail.


We define several kinds of lookup with a very similar structure.
We spell out each of them in spite of the redundancy,
in order to avoid introducing meta-level abstraction mechanisms
just for this purpose.
The point is that we must indicate for each lookup
which kind of member it is looking for,
because, e.g., a `method lookup' and a `getter lookup' are used
in different situations.
#1
The result of a
#1 lookup for m in o with respect to L starting in class C
is the result of a #1 lookup for m in C with respect to L.
The result of a #1 lookup for m in C with respect to L is:
If C declares a concrete instance #1 named m
that is accessible to L,
then that #1 declaration is the result of the #1 lookup,
and we say that the #1 was  looked up in C.
Otherwise, if C has a superclass S,
the result of the #1 lookup is
the result of a #1 lookup for m in S with respect to L.
Otherwise, we say that the #1 lookup has failed.


Let m be an identifier, o an object, L a library,
and C a class which is the class of o or a superclass thereof.

methodgettersetter#1
The result of a
#1 lookup for m in o with respect to L
is the result of a
#1 lookup for m in o with respect to L
starting with the class of o.

Let m be an identifier, o an object, and L a library.
methodgettersetter
Note that for getter (setter) lookup, the result may be
a getter (setter) which has been induced by an instance variable
declaration.

Note that we sometimes use phrases like `looking up method m'
to indicate that a method lookup is performed,
and similarly for setter lookups and getter lookups.

The motivation for ignoring abstract members during lookup
is largely to allow smoother mixin composition.


 ¬ß.¬ß Top level Getter Invocation
topLevelGetterInvocation
Evaluation of a top-level getter invocationiof the formm,
wheremis an identifier,
proceeds as follows:


The getter functionmis invoked.
The value ofiis the result returned by the call to the getter function.

Note that the invocation is always defined.
Per the rules for identifier references,
an identifier will not be treated as a top-level getter invocation
unless the getter i is defined.

The static type ofiis the declared return type ofm.




 ¬ß.¬ß Member Invocations
memberInvocations[t][    .22 Simple member
invocation   .17 Corresponding member name;                       r.ùïÄ, r?.ùïÄ                               ùïÄ;     r.ùïÄ = e,
          r?.ùïÄ = e                              ùïÄ=; r.ùïÄ(args),
          r?.ùïÄ(args)                               ùïÄ;                r.ùïÄ<types>(args)                               ùïÄ;               r?.ùïÄ<types>(args)                               ùïÄ;                              -r                          unary-;                               r                                ;                             r‚äïe                               ‚äï;                            r[e]                              [];                    r[e_1] = e_2                             []=;                         r(args)                                ;                  r<types>(args)                                ;                                 ]  [ .23 Composite member
invocation   .18 Corresponding member name;                         r.ùïÄ‚äó= e                               ùïÄ;                        r?.ùïÄ‚äó= e                               ùïÄ;                   r[e_1] ‚äó= e_2                              [];                    ++r.ùïÄ, --r.ùïÄ                               ùïÄ;                    r.ùïÄ++, r.ùïÄ--                               ùïÄ;                  ++r[e], --r[e]                              [];                  r[e]++, r[e]--                              [] ]
[t]
    In the tables above,
    r, e, e_1, e_2 are expressions;
    args is derived from arguments;
    types is derived from typeArguments;
    `‚äï' is an operator which is not ==;
    
    and `‚äó=' is a compoundAssignmentOperator.
  
  Member invocations with syntactic receiver r.
A member invocation is an expression with a specific syntactic form
whose dynamic semantics involves invocation of
one or two instance members of a given receiver,
or invocation of extension members.
This section specifies which syntactic forms are member invocations,
and defines some terminology
which is needed in order to denote
specific parts of several syntactic forms collectively.


The static analysis and dynamic semantics of
each of the syntactic forms that are member invocations
is specified separately,
this section is only concerned with
the syntactic classification and terminology.


For example, one kind of member invocation is an ordinary method invocation
(<ref>).

A
simple member invocationmember invocation!simple
respectively
composite member invocationmember invocation!composite
on a
syntactic receivermember invocation!syntactic receiver
expressionris an expression of
one of the forms shown in Fig.¬†<ref>.
Each member invocation has a
corresponding member name
  member invocation!corresponding member name
as shown in the figure.


Each member invocation in Fig.¬†<ref> that contains
? is a
conditional member invocationmember invocation!conditional.
An
unconditional member invocationmember invocation!unconditional
is a member invocation which is not conditional.


For a simple member invocation the corresponding member name is
the name of the member which is invoked
in the case where the member invocation invokes an instance member.
For a composite member invocation it is the name of the getter
and the basename of both the getter and the setter.

Note that r cannot be 
even though .m() invokes an instance method.
This is because the semantics of a superinvocation is different from
that of other invocations.
Among the binary operators, == is not included.
This is because evaluation of e_1 == e_2
involves more steps than an instance member invocation.
Similarly, &&, and || are not included
because their evaluation does not involve method invocation.
[h][                                                                                                ;                                            r?.ùïÄ                                r' ==  ?  : r'.ùïÄ;                                        r?.ùïÄ = e                            r' ==  ?  : r'.ùïÄ = e;                                      r?.ùïÄ(args)                          r' ==  ?  : r'.ùïÄ(args);                               r?.ùïÄ<types>(args)                    r' ==  ?  : r.ùïÄ<types>(args);                                           r?[e]                               r' ==  ?  : r'[e];                                   r?[e_1] = e_2                       r' ==  ?  : r'[e_1] = e_2;                                       r.ùïÄ ??= e                       vr'.ùïÄv ==  ? r'.ùïÄ = e : v;                                         r.ùïÄ‚äó= e                                   r'.ùïÄ = r'.ùïÄ‚äóe;                                        r?.ùïÄ‚äó= e                          r' ==  ?  : r'.ùïÄ ‚äó=  e;                                  r[e_1] ??= e_2 ve_1v'r'[v]
          v' ==  ? r'[v] = e_2 : v';                                   r[e_1] ‚äó= e_2                         ve_1r'[v] = r'[v] ‚äó e_2;                                           ++r.ùïÄ                                        r.ùïÄ += 1;                                           --r.ùïÄ                                        r.ùïÄ -= 1;                                           r.ùïÄ++                            vr'.ùïÄv'r'.ùïÄ = v + 1v;                                           r.ùïÄ--                            vr'.ùïÄv'r'.ùïÄ = v - 1v;                                          ++r[e]                                       r[e] += 1;                                          --r[e]                                       r[e] -= 1;                                          r[e]++          vev'r'[v]v‚Äù
          r'[v] = v' + 1v';                                          r[e]--          vev'r'[v]v‚Äù
          r'[v] = v' - 1v' ]
  Desugaring of member invocations.
    `‚äó=' is a compoundAssignmentOperator.
    The first applicable rule is used.
    In particular, `‚äó=' cannot be `??='
    when an earlier rule with `??=' matches.
    r' is known as the replacement receiver of
    the composite member invocation,
    and it is specified in the main text
    (<ref>).
A composite member invocation is an abbreviated form
whose meaning is reduced to simple member invocations
as shown in Fig.¬†<ref>.
This step is known as a desugaring transformation,
and we say that the resulting expression has been desugared.
Fig.¬†<ref> contains
several occurrences ofr'which is the
replacement receivermethod invocation!replacement receiver
of the composite method invocation.
The meaning of each occurrence ofr'is determined as follows:


When the receiverris an extension application
(<ref>)
of the form E<T1k>(e_r)
(where k = 0 means that the type argument list is absent):
Letv_rbe a fresh variable bound to the value ofe_rand with the same static type ase_r,
thenr'is E<T1k>(v_r) when it occurs
as the receiver of a member invocation,
and otherwiser'isv_r.


Whenris not an extension application,r'is a fresh variable bound to the value ofr,
with the same static type asr.


This corresponds to an extra outermost  in each rule
in Fig.¬†<ref>
where r' occurs,
and an explicit distinction between the two forms of r,
but the figure would be considerably more verbose if it had been
specified in that manner.


 ¬ß.¬ß Method Invocation
methodInvocation
Method invocation can take several forms as specified below.




  ¬ß.¬ß.¬ß Ordinary Invocation
ordinaryInvocation
An ordinary method invocation can be conditional or unconditional.


e?.m<‚ãØ>(‚ãØ)
Consider a
conditional ordinary method invocation
  method invocation!conditional ordinaryiof the form
e?.m<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k).


Note that non-generic invocations arise as the special case where
the number of type arguments is zero,
in which case the type argument list is omitted,
and similarly for formal type parameter lists (<ref>).

The static type ofiis the same as the static type of

e.m<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k).


Exactly the same compile-time errors that would be caused by

e.m<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
are also generated in the case ofi.


Evaluation ofiproceeds as follows:


Ifeis a type literal or denotes an extension,iis treated as

e.m<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k).


Otherwise, evaluateeto an objecto.
Ifois the null object,ievaluates to the null object (<ref>).
Otherwise letvbe a fresh variable bound tooand evaluate
v.m<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
to an objectr.
Theneevaluates tor.

C.m<‚ãØ>(‚ãØ)
A static member invocationmember invocation!staticiis an invocation of the form
C.m<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k),
whereCis a type literal, orCdenotes an extension.


Non-generic invocations arise as the special case
where the number of type arguments is zero (<ref>).

A compile-time error occurs
unlessCdenotes a class, a mixin, or an extension that declares
a static member namedm,
which we will call the
denoted memberstatic member invocation!denoted member
ofi.
When the denoted member is a static method, letFbe its function type;
when the denoted member is a static getter, letFbe its return type;
when the denoted member is neither, a compile-time error occurs.


The static analysis ofiis then performed
as specified in Section¬†<ref>,
consideringFto be the static type of the function to call,
and the static type ofiis as specified there.


Evaluation of a static method invocationiof the form

C.m<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
proceeds as follows:


If the denoted member ofiis a static method,
letfbe the function declared by that member.
The binding of actual arguments to formal parameters is performed
as specified in Section¬†<ref>.
The body offis then executed with respect to the bindings
that resulted from the evaluation of the argument part.
The value ofiis the object returned by the execution off's body.


If the denoted member ofiis a static getter,
invoke said getter and letv_fbe
a fresh variable bound to the returned object.
Then the value ofiis the value of
v_f<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k).

e.m<‚ãØ>(‚ãØ)
An unconditional ordinary method invocation
  method invocation!unconditional ordinaryihas the form
e.m<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k),
whereeis an expression that is not a type literal,
and does not denote an extension.


Non-generic invocations arise as the special case
where the number of type arguments is zero (<ref>).

LetTbe the static type ofe.


IfTis  bounded
(<ref>)
andmis one of
hashCode, noSuchMethod, runtimeType, or toString
then we say thatiis a
dynamic Object member invocation
  dynamic Object member invocation,
whose static analysis is specified separately below.


Otherwise, it is a compile-time error ifTdoes not have an accessible
(<ref>)
instance member namedm, unless either:


  * T is  bounded;
  in this case no further static checks are performed on i
  (apart from separate static checks on subterms like arguments)
  and the static type of i is .
  Or

  * T is  bounded
  (<ref>)
  and m is ;
  in this case no further static checks are performed on i
  (apart from separate static checks on subterms like arguments)
  and the static type of i is .

This means that for invocations of an instance method named ,
a receiver of type  is treated like a receiver of type .
The expectation is that any concrete subclass of 
will implement ,
but there is no method signature
which can be assumed for  in 
because every signature will conflict with
some potential overriding declarations.

IfTdid not have an accessible member namedmthe static type ofiis ,
and no further static checks are performed oni(
except that subexpressions of i are subject to their own static analysis
).


Ifiis a dynamic Object member invocation
(<ref>)
then the static type of the member is specified in
Section¬†<ref>.
In this case, ifmis hashCode or runtimeType
then letFbe the return type of said getter;
ifmis noSuchMethod or toString
then letFbe the type of said method.


Note that it is always a compile-time error if m
is hashCode or runtimeType.

Otherwise, T.m denotes an instance member.
LetLbe the library that containsi.
Letdbe the result of method lookup forminTwith respect toL,
and if the method lookup succeeded then letFbe the static type ofd.


Otherwise, letdbe the result of getter lookup
forminTwith respect toL,
and letFbe the return type ofd.
(
Since T.m exists we cannot have a failure in both lookups.
)
If the getter return typeFis an interface type
that has a method named ,iis treated as
(<ref>)
the ordinary invocation

e.m.call<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k),


which determines any further static analysis.


Otherwise, the static analysis ofiis performed
as specified in Section¬†<ref>,
consideringFto be the static type of the function to call,
and the static type ofiis as specified there,
except that invocations of methods named remainder
or clamp on subtypes of num that are not subtypes of Never
have special rules similar to those for additive (<ref>)
and multipliative (<ref>) operators.


Letibe an invocation of the form e.remainder(e_2)
and letCbe the context type ofi.
The context type ofe_2is then determined as follows:
If Tnum and not TNever, then:

  *  If intC and not numC,
      and Tint
      then the context type of e_2 is int.
  
  *  If doubleC and not numC,
      and not Tdouble
     then the context type of e_2 is double.
  
  *  Otherwise the context type of e_2 is num.

Let furtherSbe the static type ofe_2.
If Tnum and not TNever
andSis assignable to num,
then the static type ofiis determined as follows:

  *  If Tdouble
    then the static type of i is T.
  
  *  Otherwise, if Sdouble
    and not SNever,
    then the static type of i is double.
  
  *  Otherwise, if Tint,
    Sint and not SNever,
    then the static type of i is int.
  
  *  Otherwise the static type of i is num.

Letibe an invocation of the form e.clamp(e_2,  e_3),
where Tnum and not TNever,
and letCbe the context type ofi.
The context type ofe_2ande_3is then determined as follows:

  *  If Tint,
    intS and not numS,
    then the context type of e_2 and e_3 is int.
  
  *  If Tdouble,
    doubleS and not numS,
    then the context type of e_2 and e_3 is double.
  
  *  Otherwise the context type of e_2 and e_3 is num.

Let furtherT_2be the static type ofe_2andT_3be the static type
ofe_3.

  *  If all of T, T_2 and T_3 are subtypes of int, but
    not subtypes of Never, then the static type of i is int.
  
  *  If all of T, T_2 and T_3 are subtypes of double, but
    not subtypes of Never, then the static type of i is double.
  
  *  Otherwise the static type of i is num.

It is a compile-time error to invoke an instance method on a type literal
that is immediately followed by the token `.' (a period).

For instance, int.toString() is an error.

The reason for this rule is that member access on a type literal
is reserved for invocation of static members.
Invocation of a static member of a class, mixin, enum, or extension
uses said entity as a namespace,
not as an actual class, mixin, enum, or extension.
In particular, the syntactic receiver is not evaluated
to an object‚Äîthat would not even be possible for an extension.

A member access on a type literal
(e.g., C.id(), C.id, or C?.id()),
always treats the declaration denoted by the literal as
a namespace for accessing static members or constructors.
For instance, int.toString() is an error
because int does not declare a static member named toString.
It will not evaluate int to a Type object
and then call its toString instance method.
To do that, you can use (int).toString().
Note that cascades are different:
they always evaluate their receiver to an object first.

As a natural consequence,
a type literal cannot be the receiver in
an implicit invocation of an extension method
(<ref>).

Evaluation of an unconditional ordinary method invocationiof the form
e.m<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
proceeds as follows:


First, the expressioneis evaluated to an objecto.
Letfbe the result of looking up
(<ref>)
methodminowith respect to the current libraryL.


If the method lookup succeeded,
the binding of actual arguments to formal parameters is performed
as specified in Section¬†<ref>.
The body offis then executed with respect to the bindings
that resulted from the evaluation of the argument list,
and with  bound too.
The value ofiis the object returned by the execution off's body.


If the method lookup failed,
then letgbe the result of looking up getter
(<ref>)minowith respect toL.


If the getter lookup succeeded then invoke the gettero.mand letv_gbe the returned object.
Then the value ofiis the value of

v_g<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k).


If getter lookup has also failed,
then a new instanceimof the predefined class Invocation is created,
such that:

  * im.isMethod evaluates to .

  * im.memberName evaluates to the symbol m.

  * im.positionalArguments evaluates to an unmodifiable list
  whose dynamic type implements List<Object>,
  containing the objects resulting from the evaluation of
  <Object>[a_1, ‚Ä¶, a_n].

  * im.namedArguments evaluates to an unmodifiable map
  whose dynamic type implements Map<Symbol, Object>,
  with the keys and values resulting from the evaluation of

  <Symbol, Object>{#x_n+1: a_n+1, ‚Ä¶, #x_n+k: a_n+k}.

  * im.typeArguments evaluates to an unmodifiable list
  whose dynamic type implements List<Type>,
  containing the objects resulting from the evaluation of
  <Type>[A_1, ‚Ä¶, A_r].

Then the method noSuchMethod() is looked up inoand
invoked with argumentim,
and the result of this invocation is the result of evaluatingi.


The situation where noSuchMethod is invoked can only arise
when the static type of e is .
Notice that the wording avoids re-evaluating the receiver o and
the arguments a_i.


  ¬ß.¬ß.¬ß Cascades
cascades
A cascade is a kind of expression that allows for performing
multiple operations on a given object
without storing it in a variable and accessing it via a name.
In general, a cascade can be recognized by the use of exactly two periods,
...


<cascade> ::= <cascade> `..' <cascadeSection>
   <conditionalExpression> (`?..' | `..') <cascadeSection>

<cascadeSection> ::= <cascadeSelector> <cascadeSectionTail>

<cascadeSelector> ::= `[' <expression> `]'
   <identifier>

<cascadeSectionTail> ::= <cascadeAssignment>
   <selector>* (<assignableSelector> <cascadeAssignment>)?

<cascadeAssignment> ::= <assignmentOperator> <expressionWithoutCascade>

A cascaded member accesscascaded member access
is an expression derived from cascade.


A cascadeSection allows for accessing members, including setters.
The motivation for having a cascaded member access is that it allows for
performing a chain of operations based on an object
while preserving a reference to that object for further processing.

Let e_0 be an extension application
(<ref>).
Note that it is then a compile-time error
to have a cascade of the form
e_0..c or e_0?..c,
where c is a cascadeSection.

For example, C()..foo.bar = 2 allows us to obtain a reference to
the object o which is the result of evaluating C(),
and at the same time use o to invoke the getter foo and
the setter bar= on the value returned by that getter.

An expression of the form e_0?..s wheree_0is a conditionalExpression andsis a cascadeSection is an
initially conditional cascaded member access
  cascaded member access!initially conditional.
Moreover, if e_0 is
an initially conditional cascaded member access andsis derived from cascadeSection then
e_0..s is also initially conditional.


In short, a cascade is initially conditional if
the ‚Äúinnermost dots‚Äù are ?.. rather than ...
Note that only the innermost dots can have the ?.
All the non-innermost ones are implicitly skipped if the receiver is null,
so any ? on a non-innermost .. would be useless.

The static analysis and dynamic semantics of a cascaded member access
is specified in terms of the following desugaring step.


Letebe a cascaded member access which is not initially conditional.
This implies that there exist terms c1k
derived from cascadeSection
and a conditionalExpressione_0which is not an extension application,
andeis e_0..c_1 ‚ãØ..c_k.
In this case,eis desugared to

ve_0v_1v.c_1, ‚ãØv_kv.c_kv.


Letebe a cascaded member access which is initially conditional.
This implies that there exist terms c1k
derived from cascadeSection
and a conditionalExpressione_0which is not an extension application,
andeis e_0?..c_1 ‚ãØ..c_k.
In this case,eis desugared to

ve_0
v ==  ?  : v_1v.c_1v_kv.c_kv.


Note that the grammar is such that v.c_j is
a syntactically correct expression for all j.


  ¬ß.¬ß.¬ß Superinvocations
superInvocations
A method superinvocationihas the form
i, m, A_j, a_j, x_j.m<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k).


Note that non-generic invocations arise as
the special case where the number of type arguments is zero,
in which case the type argument list is omitted,
and similarly for formal type parameter lists (<ref>).

It is a compile-time error if a method superinvocation occurs
in a top-level function or variable initializer,
in an instance variable initializer or initializer list,
in class Object,
in a factory constructor,
or in a static method or variable initializer.


, L
Let  be the superclass (<ref>)
of the immediately enclosing class for i,
D, F
and let L be the library that contains i.
Let the declaration D be
the result of looking up the method m in 
with respect to L (<ref>),
and let F be the static type of D.
Otherwise, if the method lookup failed,
let the declaration D be the result of looking up
the getter m with respect to L in 
(<ref>),
and let F be the return type of D.
If both lookups failed, a compile-time error occurs.


Otherwise (when one of the lookups succeeded),
the static analysis of i is performed
as specified in Section¬†<ref>,
considering the function to have static type F,
and the static type of i is as specified there.


Note that member lookups ignore abstract declarations,
which means that there will be a compile-time error
if the targeted member m is abstract,
as well as when it does not exist at all.

An
implicit  superinvocation
  method superinvocation!implicit 
has the form

<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k),


and it is treated as

.<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k).


The type argument list is again omitted when r = 0.

o, C, 
Evaluation of i proceeds as follows:
Let o be the current binding of ,
let C be the enclosing class for i,
and let  be the superclass (<ref>) of C.
Let L be the library that contains C.
D, f
Let the declaration D be the result of looking up
the method m with respect to L in o starting with 
(<ref>).
If the lookup succeeded,
let f denote the function associated with D.

Otherwise (when method lookup failed),
let the declaration D be the result of looking up
the getter m with respect to L in o starting with 
(<ref>).
If the getter lookup succeeded,
invoke said getter with  bound to o,
and let f denote the returned object.


It cannot occur that both lookups fail,
because the corresponding lookups would then have failed at compile-time,
in which case the program has a compile-time error.

Otherwise perform the binding of actual arguments to formal parameters for
f<A_1, ‚Ä¶, A_r>(a_1, ‚Ä¶, a_n, x_n+1: a_n+1, ‚Ä¶, x_n+k: a_n+k)
as specified in Section¬†<ref>,
and execute the body of f with said bindings
plus a binding of  to o.
The result returned by f is then the result of evaluating i.



  ¬ß.¬ß.¬ß Sending Messages
sendingMessages
Messages are the sole means of communication among isolates.
Messages are sent by invoking specific methods in the Dart libraries; there is no specific syntax for sending a message.


In other words, the methods supporting sending messages
embody primitives of Dart that are not accessible to ordinary code,
much like the methods that spawn isolates.


 ¬ß.¬ß Property Extraction
propertyExtraction
Property extractionproperty extraction
allows for a member to be accessed as a property rather than a function.
A property extraction can be either:

  *  An instance method closurization,
  which converts a method into a function object
  (<ref>).
  Or

  *  A getter invocation, which returns
  the result of invoking of a getter method
  (<ref>).

Function objects derived from members via closurization
are colloquially known as tear-offs.

Property extraction comes in several forms, as described below.


Conditional
Consider a conditional property extraction expression
  property extraction!conditionaliof the form e?.ùïÄ.


Ifeis a type literal,iis treated as e.ùïÄ.


Otherwise, the static type ofiis the same as
the static type of e.ùïÄ.
LetTbe the static type ofe,
and letybe a fresh variable of typeT.
Except for errors insideeand references to the namey,
exactly the same compile-time errors that would be caused by y.ùïÄ
are also generated in the case of e?.ùïÄ.


Evaluation of a conditional property extraction expressioniof the form e?.ùïÄ proceeds as follows:


Ifeis a type literal oredenotes an extension,
evaluation ofiamounts to evaluation of e.ùïÄ.


Otherwise evaluateeto an objecto.
Ifois the null object,ievaluates to the null object (<ref>).
Otherwise letxbe a fresh variable bound tooand evaluate x.ùïÄ to an objectr.
Thenievaluates tor.

Static
Let ùïÄ be an identifier;
a static property extraction
  property extraction!staticiis an expression of the form C.ùïÄ,
whereCis a type literal orCdenotes an extension.


A compile-time error occurs
unlessCdenotes a class, a mixin, or an extension that declares
a static member namedm,
which we will call the
denoted memberstatic property extraction!denoted member
ofi.
If the denoted member is a static getter,
the static type ofiis the return type of said getter;
if the denoted member is a static method,
the static type ofiis the function type of said method;
if the denoted member is neither, a compile-time error occurs.


Evaluation of a static property extractioniof the form C.ùïÄ
proceeds as follows:
If the denoted member ofiis a static getter,
said getter is invoked, yielding an objecto,
andithen evaluates too.
If the denoted member ofiis a static method,ievaluates to a function object by function closurization
(<ref>)
applied to said static method.

Unconditional
Let ùïÄ be an identifier;
an unconditional property extraction
  property extraction!unconditional
is an expression of the form e.ùïÄ
whereeis an expression that is not a type literal,
and does not denote an extension
(<ref>);
or it is an expression of the form .ùïÄ
(<ref>).

Implicit
Letebe an expression whose static type is
an interface type that has a method named .
In the case where the context type foreis a function type
or the type ,eis treated as e..


This means that a ‚Äúcallable object‚Äù may be treated as a function
that supports a mechanism similar to function closurization
(<ref>)
by desugaring it to a method closurization on .
This only occurs when it is statically known that it is a callable object,
and when the context type requires a function.


  ¬ß.¬ß.¬ß Getter Access and Method Extraction
getterAccessAndMethodExtraction
Consider an unconditional property extractioni(<ref>)
of the form e.ùïÄ.
It is a compile-time error if ùïÄ is the name of
an instance member of the built-in class Object
andeis a type literal.


This means that we cannot use int.toString
to obtain a function object for the toString method of the
Type object for int.
But we can use (int).toString:
e is then not a type literal, but a parenthesized expression.

This is a pragmatic trade-off.
The ability to tear off instance methods on instances of Type
was considered less useful,
and it was considered more useful to insist on the simple rule that
a method tear-off on a type literal is always a tear-off
of a static method on the denoted class.

LetTbe the static type ofe.


IfTis  bounded
(<ref>)
andmis one of
hashCode, noSuchMethod, runtimeType, or toString
then we say thatiis a
dynamic Object property extraction
  dynamic Object property extraction,
whose static analysis is specified separately below.


Otherwise, it is a compile-time error ifTdoes not have
a method or getter named ùïÄ
unlessTis  bounded,
orTis  bounded
(<ref>)
and ùïÄ is .
The static type ofiis:


  *  The return type as specified in Section¬†<ref>
  if i is a dynamic Object property extraction
  and ùïÄ is hashCode or runtimeType.

  *  The static type as specified in Section¬†<ref>
  if i is a dynamic Object property extraction
  and ùïÄ is noSuchMethod or toString.

  *  The declared return type of T.ùïÄ,
  if T has an accessible instance getter named ùïÄ.

  *  The function type of the method signature T.ùïÄ,
  if T has an accessible instance method named ùïÄ.

  *  if T is  bounded and ùïÄ is .

  *  The type  otherwise.
  This only occurs when T is  bounded.
Note that the type of a method tear-off ignores
whether any given parameter is covariant.
However, the dynamic type of a function object
thus obtained does take parameter covariance into account.

Evaluation of a property extractioniof the form e.ùïÄ
proceeds as follows:


First, the expressioneis evaluated to an objecto.
Letfbe the result of looking up (<ref>) method
(<ref>)
ùïÄ inowith respect to the current libraryL.
If method lookup succeeds thenievaluates to
the closurization of methodfon objecto(<ref>).


Note that f is never an abstract method,
because method lookup skips abstract methods.
If the method lookup failed, e.g.,
because there is an abstract declaration of ùïÄ, but no concrete declaration,
we will continue to the next step.
However, since methods and getters never override each other,
getter lookup will necessarily fail as well,
and noSuchMethod() will ultimately be invoked.
The regrettable implication is that the error will refer to a missing getter
rather than an attempt to closurize an abstract method.

Otherwise,iis a getter invocation.
Letfbe the result of looking up (<ref>) getter
(<ref>)
ùïÄ inowith respect toL.
Otherwise, the body offis executed with  bound too.
The value ofiis the result returned by the call to the getter function.


If the getter lookup has failed,
then a new instanceimof the predefined class Invocation is created,
such that:

  * im.isGetter evaluates to .

  * im.memberName evaluates to the symbol m.

  * im.positionalArguments evaluates to an object
  whose dynamic type implements List<Object>,
  and which is empty and unmodifiable.

  * im.namedArguments evaluates to an object
  whose dynamic type implements Map<Symbol, Object>,
  and which is empty and unmodifiable.

  * im.typeArguments evaluates to an object
  whose dynamic type implements List<Type>,
  and which is empty and unmodifiable.

Then the method noSuchMethod() is looked up
inoand invoked with argumentim,
and the result of this invocation is the result of evaluatingi.


The situation where noSuchMethod is invoked can only arise
when the static type of e is .


  ¬ß.¬ß.¬ß Super Getter Access and Method Closurization
superGetterAccessAndMethodClosurization
Consider a property extractioniof the form .ùïÄ.


LetSbe the superclass of the immediately enclosing class.
It is a compile-time error ifSdoes not have
an accessible instance method or getter named ùïÄ.
The static type ofiis:


  *  The declared return type of S.ùïÄ,
  if S has an accessible instance getter named ùïÄ.

  *  The function type of the method signature S.ùïÄ,
  if S has an accessible instance method named ùïÄ.

  *  The type  otherwise.
  This only occurs when T is  or .
Note that the type of a method tear-off ignores
whether any given parameter is covariant.
However, the dynamic type of a function object
thus obtained does take parameter covariance into account.

Evaluation of a property extractioniof the form.mproceeds as follows:


Letgbe the method implementation currently executing,
and letCbe the class in whichgis declared.
LetSbe the superclass ofC.
Letfbe the result of looking up method ùïÄ inSwith respect to the current libraryL.
If method lookup succeeds thenievaluates to
the closurization of methodfwith respect to superclassS(<ref>).


Otherwise,iis a getter invocation.
Letfbe the result of looking up
getter ùïÄ inSwith respect toL.
The body offis executed with  bound to the current value of .
The value ofiis the result returned by the call to the getter function.


The getter lookup will not fail, because it is a compile-time error to have
a super property extraction of a member ùïÄ when the superclass S
does not have a concrete member named ùïÄ.


  ¬ß.¬ß.¬ß Instance Method Closurization
instanceMethodClosurization
This section specifies the dynamic semantics of instance method closurizations.


Note that the non-generic case is covered implicitly using s = 0,
in which case the type parameter declaration lists
and the actual type argument lists passed in invocations
are omitted (<ref>).

An instance method closurization
is a closurization of some method on some object, defined below,
or a super closurization (<ref>).


Letobe an object, and letube a fresh final variable bound too.
The closurization of methodfon objectois defined to be equivalent
(except for equality, as noted below) to:







  * 
<XB's>
(Tp1n,{T_n+1 p_n+1 = d_1, ‚Ä¶, T_n+k p_n+k = d_k}) =>
  u.m<X1s>(p1n, p_n+1: p_n+1, ‚Ä¶, p_n+k: p_n+k);

where f is an instance method named m
which has type parameter declarations
,
required parameters p1n,
and named parameters pn+1n+k with defaults d1k,
using null for parameters whose default value is not specified.

  * 
<XB's>
(Tp1n,[T_n+1 p_n+1 = d_1, ‚Ä¶, T_n+k p_n+k = d_k]) =>
  u.m<X1s>(p1n+k);

where f is an instance method named m
which has type parameter declarations
,
required parameters p1n,
and optional positional parameters
pn+1n+k with defaults d1k,
using null for parameters whose default value is not specified.B'_j, j ‚àà1 .. s, are determined as follows:
Ifois an instance of a non-generic class,B'_j = B_j, j ‚àà1 .. s.
Otherwise, letX'_1, ‚Ä¶, X'_s'be
the formal type parameters of the class ofo,
andt'_1, ‚Ä¶, t'_s'be the actual type arguments.
ThenB'_j = [t'_1/X'_1, ‚Ä¶, t'_s'/X'_s']B_j, j ‚àà1 .. s.


That is, we replace the formal type parameters of the enclosing class,
if any,
by the corresponding actual type arguments.

The parameter typesT_j, j ‚àà1 .. n+k, are determined as follows:
Let the method declarationDbe the implementation ofmwhich is invoked by the expression in the body.
LetTbe the class that containsD.


Note that T is the dynamic type of o, or a superclass thereof.

For each parameterp_j,j ‚àà1 .. n+k, ifp_jis covariant
(<ref>)
thenT_jis the built-in class Object.


This is concerned with the dynamic type of the function object obtained by
the member closurization.
The static type of the expression that gives rise to the member closurization
is specified elsewhere
(<ref>,
<ref>).
Note that for the static type it is ignored whether a parameter is covariant.

IfTis a non-generic class then forj ‚àà1 .. n+k,T_jis a type annotation that denotes the same type as that
which is denoted by the type annotation on
the corresponding parameter declaration inD.
If that parameter declaration has no type annotation thenT_jis .


OtherwiseTis a generic instantiation of a generic classG.
LetX‚Äù_1, ‚Ä¶, X‚Äù_s‚Äùbe the formal type parameters ofG,
andt‚Äù_1, ‚Ä¶, t‚Äù_s‚Äùbe the actual type arguments ofoatT.
ThenT_jis a type annotation that denotes[t‚Äù_1/X‚Äù_1, ‚Ä¶, t‚Äù_s‚Äù/X‚Äù_s‚Äù]S_j,
whereS_jis the type annotation of the corresponding parameter inD.
If that parameter declaration has no type annotation thenT_jis .


There is one way in which
the function object yielded by the instance method closurization differs from
the function object obtained by function closurization on
the above mentioned function literal:
Assume thato_1ando_2are objects,mis an identifier,
andc_1andc_2are function objects
obtained by closurization ofmono_1respectivelyo_2.
Then c_1 == c_2 evaluates to true
if and only ifo_1ando_2is the same object.




In particular, two closurizations of a method m
from the same object are equal,
and two closurizations of a method m
from non-identical objects are not equal.
Assuming that v_i is a fresh variable bound to an object, i ‚àà 1 .. 2,
it also follows that identical(v_1.m, v_2.m) must be false
when v_1 and v_2 are not bound to the same object.
However, Dart implementations are not required to canonicalize function objects,
which means that identical(v_1.m, v_2.m) is not guaranteed to be true,
even when it is known that v_1 and v_2 are bound to the same object.

The special treatment of equality in this case facilitates
the use of extracted property functions in APIs where callbacks
such as event listeners must often be registered and later unregistered.
A common example is the DOM API in web browsers.


  ¬ß.¬ß.¬ß Super Closurization
superClosurization
This section specifies the dynamic semantics of
super closurizations.


Note that the non-generic case is covered implicitly using s = 0,
in which case the type parameter declarations are omitted (<ref>).

Consider expressions in the body of a classTwhich is
a subclass of a given classS,
where a method declaration that implementsfexists inS,
and there is no classUwhich is
a subclass ofSand a superclass ofTwhich implementsf.


In short, consider a situation where
a superinvocation of f will execute f as declared in S.

A super closurization
is a closurization of a method with respect to a class, as defined next.
The closurization of a methodfwith respect to the classSis defined to be equivalent
(except for equality, as noted below) to:









  * 
<XB's>
(Tp1n,{T_n+1 p_n+1 = d_1, ‚Ä¶, T_n+k p_n+k = d_k}) =>
  .m<X1s>(p1n, p_n+1: p_n+1, ‚Ä¶, p_n+k: p_n+k);

where f is an instance method named m
which has type parameter declarations
,
required parameters p1n,
and named parameters pn+1n+k with defaults d1k.

  * 
<XB's>
(Tp1n,[T_n+1 p_n+1 = d_1, ‚Ä¶, T_n+k p_n+k = d_k]) =>
  .m<X1s>(p1n+k);

where f is an instance method named m
which has type parameter declarations
,
required parameters p1n,
and optional positional parameters
pn+1n+k with defaults d1k.

Note that a super closurization is an instance method closurization,
as defined in (<ref>).B'_j, j ‚àà1 .. s, are determined as follows:
IfSis a non-generic class thenB'_j = B_j, j ‚àà1 .. s.
Otherwise, letX'_1, ‚Ä¶, X'_s'be the formal type parameters ofS,
andt'_1, ‚Ä¶, t'_s'be the actual type arguments of  atS.
ThenB'_j = [t'_1/X'_1, ‚Ä¶, t'_s'/X'_s']B_j, j ‚àà1 .. s.


That is, we replace the formal type parameters of the enclosing class, if any,
by the corresponding actual type arguments.
We need to consider the type arguments with respect to a specific class because
it is possible for a class to pass different type arguments to its superclass
than the ones it receives itself.

The parameter typesT_j, j ‚àà1 .. n+k, are determined as follows:
Let the method declarationDbe the implementation ofminS.


For each parameterp_j,j ‚àà1 .. n+k, ifp_jis covariant
(<ref>)
thenT_jis the built-in class Object.


This is concerned with the dynamic type of the function object obtained by
the super closurization.
The static type of the expression that gives rise to the super closurization
is specified elsewhere
(<ref>,
<ref>).
Note that for the static type it is ignored whether a parameter is covariant.

IfSis a non-generic class then forj ‚àà1 .. n+k,T_jis a type annotation that denotes the same type as that
which is denoted by the type annotation on
the corresponding parameter declaration inD.
If that parameter declaration has no type annotation thenT_jis .


OtherwiseSis a generic instantiation of a generic classG.
LetX‚Äù_1, ‚Ä¶, X‚Äù_s‚Äùbe the formal type parameters ofG,
andt‚Äù_1, ‚Ä¶, t‚Äù_s‚Äùbe the actual type arguments ofoatS.
ThenT_jis a type annotation that denotes[t‚Äù_1/X‚Äù_1, ‚Ä¶, t‚Äù_s‚Äù/X‚Äù_s‚Äù]S_j,
whereS_jis the type annotation of the corresponding parameter inD.
If that parameter declaration has no type annotation thenT_jis .


There is one way in which
the function object yielded by the super closurization differs from
the function object obtained by function closurization on
the above mentioned function literal:
Assume that an occurrence of the expression .min a given class
is evaluated on two occasions where 
is bound too_1respectivelyo_2,
and the resulting function objects arec_1respectivelyc_2:
c_1 == c_2 is then true
if and only ifo_1ando_2is the same object.




  ¬ß.¬ß.¬ß Generic Method Instantiation
genericMethodInstantiation


Generic method instantiation is a mechanism that yields
a non-generic function object,
based on a property extraction which denotes an instance method closurization
(<ref>, <ref>).


It is a mechanism which is very similar to instance method closurization,
but it only occurs in situations where
a compile-time error would otherwise occur.

The essence of generic method instantiation
is to allow for ‚Äúcurried‚Äù invocations,
in the sense that a generic instance method can receive its actual
type arguments separately during closurization
(it must then receive all type arguments, not just some of them),
and that yields a non-generic function object.
The type arguments are passed implicitly, based on type inference;
a future version of Dart may allow for passing them explicitly.
Here is an example: A {
  X fi<X  num>(X x) => x;
}
 B  /* or   */ A {
  X fi<X  num>(X x, [List<X> xs]) => x;
}
 main() {
  A a = B();
  int (int) f = a.fi;
}

The function object which is stored in f at the end of main
has dynamic type int  (int, [List<int>]),
and it is obtained by implicitly
‚Äúpassing the actual type argument int‚Äù
to the denoted generic instance method,
thus obtaining a non-generic function object of the specified type.

Note that this function object accepts an optional positional argument,
even though this is not part of
the statically known type of the corresponding instance method,
nor of the context type.

In other words, generic method instantiation yields a function
whose signature matches the context type as far as possible,
but with respect to its parameter list shape
(that is, the number of positional parameters and their optionality,
or the set of names of named parameters),
it will be determined by the method signature of the actual instance method
of the given receiver.
Of course, the difference can only be such that the actual type is

a subtype of the given context type,
otherwise the declaration of that instance method
would have been a compile-time error.

Letibe a property extraction expression of the form
e?.ùïÄ, e.ùïÄ, or .ùïÄ
(<ref>, <ref>),
which is statically resolved to denote an instance method named ùïÄ,
and letGbe the static type ofi.
Consider the situation whereGis a function type of the form
T_0XBsparameters
withs > 0(that is, G is a generic function type),
and the context type is a non-generic function typeF.
In this situation a compile-time error occurs
(<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>),
except when generic function type instantiation
(<ref>)
succeeds, that is:


Type inference is applied toGwith context typeF,
and it succeeds, yielding the actual type argument list
T1s.

gmiName






































Consider the situation where generic function type instantiation succeeded.
Let  be a fresh name which is associated with ùïÄ,
which is private if and only if ùïÄ is private.

An implementation could use, say, foo_* when ùïÄ is foo,
which is known to be fresh because
user-written identifiers cannot contain `*'.

The program is then modified as follows:


  *  When i is e?.ùïÄ:
  Replace i by e?.<T1s>().

  *  When i is e.ùïÄ:
  Replace i by e.<T1s>().

  *  When i is .ùïÄ:
  Replace i by .<T1s>().

The inserted expressions have no compile-time error and can be executed,
because the corresponding generic method is induced implicitly.
We use the phrase
generic instantiation method
to denote these implicitly induced methods,
and designate the method that induced it as its
targetgeneric instantiation method!target.


Assume that a class C declares a generic instance method named ùïÄ,
with a method signature corresponding to a generic function type G,
formal type parameters ,
and formal parameter declarations parameters.
Let arguments denote the corresponding actual argument list,
passing these parameters.

For instance, parameters could be

Tp1n,{T_n+1 p_n+1 = d_1, ‚Ä¶, T_n+k p_n+k = d_k}
in which case arguments would be
p1n, p_n+1: p_n+1, p_n+k: p_n+k.

Let G' be the same function type as G,
except that it omits the formal type parameter declarations.

For instance, if G is
X, Y numX x, List<Y> ys
then G' is
X x, List<Y> ys.
Note that G' will typically contain free type variables.

An instance method with the name  is then implicitly induced,
with the same behavior as the following declaration
(except for equality of the returned function object,
which is specified below):


G'<>() {   (parameters) => .ùïÄ<X1s>(arguments);
}
Let o be an instance of a class which contains
an implicitly induced declaration of 
as described above.

Consider the situation where the program evaluates
two invocations of this method with the same receiver o,
and with actual type arguments whose actual values are

the same types t1s for both invocations,
and assume that the invocations returned
the instances o_1 respectively o_2.

It is then guaranteed that o_1 and o_2 are equal
according to operator ==.
It is unspecified whether
identical(o_1, o_2)
evaluates to  or .


No notion of equality is appropriate with different receivers,
nor when different type arguments are provided,
because execution of two function objects that differ in these ways
can have different side-effects and return different results
when executed starting from exactly the same state.


 ¬ß.¬ß Assignment
assignment
An assignment changes the value associated with a variable,
or invokes a setter.


<assignmentOperator> ::= `='
   <compoundAssignmentOperator>

<compoundAssignmentOperator> ::= `*='
   `/='
   `¬†/='
   `%='
   `+='
   `-='
   `='
   `='
   `='
   `&='
   `^='
   `|='
   `??='

ùïÄ = e
Consider an assignmentaof the form ùïÄ = e,
where ùïÄ is an identifier.
Perform a lexical lookup of ùïÄ= from the location of ùïÄ.


  * 
  When the lexical lookup yields a declaration D of a local variable v
  (which may be a formal parameter),
  a compile-time error occurs if v is final
  or if the static type of e is not assignable to the declared type of v.

  * 
  When the lexical lookup yields a declaration D
  which is not a local variable,
  it is guaranteed to be a setter
  (that may be explicit or induced implicitly by a variable)
  because other declarations do not have a name
  of the form ùïÄ=.

  If D is the declaration of a static setter in class or mixin C
  then a is treated as
  (<ref>)
  the assignment C.ùïÄ = e.

  
    Further analysis as well as evaluation of C.ùïÄ = e
    proceeds as specified elsewhere.
  

  Otherwise, a compile-time error occurs,
  unless the static type of e is assignable to the parameter type of D.

  * 
  When the lexical lookup yields nothing,
  a is treated as
  (<ref>)
  .ùïÄ = e.

  
    In this case it is known that a has access to 
    (<ref>),
    and the interface of the enclosing class has a member named ùïÄ=,
    or there is an applicable extension with a member named ùïÄ=.
    Both the static analysis and evaluation proceeds with
    .ùïÄ = e,
    so there is no need to further specify the treatment of a.
  
  * 
    The lexical lookup can never yield an import prefix,
    because they never have a name of the form ùïÄ=.
  
In all cases
(whether or not ùïÄ is a local variable, etc.),
the static type ofais the static type ofe.


Evaluation of an assignmentaof the form ùïÄ = e
proceeds as follows.
Perform a lexical lookup of ùïÄ= from the location of ùïÄ.


  * 
  In the case where the lexical lookup yields
  a declaration D of a local variable v,
  (which may be a formal parameter),
  the expression e is evaluated to an object o,
  and the variable v is bound to o.
  Then a evaluates to the object o
  (<ref>).

  * 
  In the case where the lexical lookup of ùïÄ=
  from the location of ùïÄ
  yields a declaration D,
  D is necessarily a top level setter s
  (possibly implicitly induced by a variable).

  The expression e is evaluated to an object o.
  Then the setter s is invoked
  with its formal parameter bound to o.
  Then a evaluates to the object o.

  
    D cannot be a static setter in a class C,
    because a is then treated as
    C.ùïÄ = e,
    which is specified elsewhere.
  
  * 
    The case where the lexical lookup of ùïÄ=
    yields nothing cannot occur,
    because that case is treated as
    .ùïÄ = e,
    whose evaluation is specified elsewhere.
  
p.ùïÄ = e
Consider an assignmentaof the form p.ùïÄ = e,
wherepis an import prefix and ùïÄ is an identifier.


A compile-time error occurs,
unlessphas a member which is a settersnamed id=
(which may be implicitly induced by a variable declaration)
such that the static type ofeis assignable to the parameter type ofs.


The static type ofais the static type ofe.



Evaluation of an assignmentaof the form p.ùïÄ = e
proceeds as follows:
The expressioneis evaluated to an objecto.
Then the setter denoted by p.ùïÄ is invoked
with its formal parameter bound too.
Thenaevaluates to the objecto.

e_1?.v = e_2
Consider an assignmentaof the form e_1?.v = e_2.
Exactly the same compile-time errors that would be caused by
e_1.v = e_2 are also generated in the case ofa.
The static type ofais the static type ofe_2.


Evaluation of an assignmentaof the form e_1?.v = e_2
proceeds as follows:
Ife_1is a type literal,ais equivalent to e_1.v = e_2.
Otherwise evaluatee_1to an objecto.
Ifois the null object,aevaluates to the null object (<ref>).
Otherwise letxbe a fresh variable bound tooand evaluate x.v = e_2 to an objectr.
Thenaevaluates tor.

e_1.v = e_2
Consider an assignmentaof the form e_1.v = e_2.
LetTbe the static type ofe_1.
IfTis , no further checks are performed.
Otherwise, it is a compile-time error unlessThas an accessible instance setter named v=.
It is a compile-time error unless the static type ofe_2may be assigned to the declared type of the formal parameter of said setter.
Whether or notTis ,
the static type ofais the static type ofe_2.


Evaluation of an assignment of the form e_1.v = e_2
proceeds as follows:
The expressione_1is evaluated to an objecto_1.
Then, the expressione_2is evaluated to an objecto_2.
Then, the setter v= is looked up (<ref>)
ino_1with respect to the current library.

It is a dynamic type error if the dynamic type ofo_2is not a subtype of the actual parameter type of said setter
(<ref>).
Otherwise, the body of the setter is executed with
its formal parameter bound too_2and  bound too_1.


If the setter lookup has failed, then a new instanceimof
the predefined class Invocation is created, such that:

  * im.isSetter evaluates to .

  * im.memberName evaluates to the symbol v=.

  * im.positionalArguments evaluates to an object
  whose dynamic type implements List<Object>,
  which is unmodifiable, and which contains the same objects as
  <Object>[o_2].

  * im.namedArguments evaluates to an object
  whose dynamic type implements Map<Symbol, Object>,
  and which is empty and unmodifiable.

  * im.typeArguments evaluates to an object
  whose dynamic type implements List<Type>,
  and which is empty and unmodifiable.

Then the method noSuchMethod() is looked up ino_1and invoked with argumentim.


The situation where noSuchMethod is invoked can only arise
when the static type of e_1 is .

The value of the assignment expression iso_2irrespective of whether setter lookup has failed or succeeded.

.v = e
Consider an assignmentaof the form .v = e.
LetS_staticbe the superclass of the immediately enclosing class.
It is a compile-time error ifS_staticdoes not have
a concrete accessible instance setter named v=.
Otherwise, it is a compile-time error if the static type ofemay not be assigned to the static type of the formal parameter of said setter.
The static type ofais the static type ofe.


Evaluation of an assignment of the form .v = e
proceeds as follows:
Letgbe the currently executing method, and letCbe
the class in whichgwas looked up.
LetS_dynamicbe the superclass ofC.
The expressioneis evaluated to an objecto.
Then, the setter v= is looked up (<ref>)
inS_dynamicwith respect to the current library.
The body of v= is executed with its formal parameter bound tooand  bound to the current value of .


The setter lookup will not fail, because it is a compile-time error
when no concrete setter named v= exists in S_static.

The value of the assignment expression iso.



It is a dynamic type error ifois not the null object (<ref>)
and the dynamic type ofois
not a subtype of the actual type of the formal parameter of v=
(<ref>) inS_static.

e_1[e_2] = e_3
Consider an assignmentaof the form e_1[e_2] = e_3.
LetTbe the static type ofe_1.
IfTis , no further checks are performed.
Otherwise, it is a compile-time error unlessThas a method named []=.
LetS_2be the static type of the
first formal parameter of the method []=,
andS_3the static type of the second.
It is a compile-time error unless the static type ofe_2respectivelye_3may be assigned toS_2respectivelyS_3.
Whether or notTis ,
the static type ofais the static type ofe_3.


Evaluation of an assignmentaof the form e_1[e_2] = e_3
proceeds as follows:
Evaluatee_1to an objecto,
then evaluatee_2to an objecti,
and finally evaluatee_3to an objectv.
Call the method []= onowithias first argument andvas second argument.
Thenaevaluates tov.



[e_1] = e_2
Consider an assignmentaof the form [e_1] = e_2.
LetS_staticbe the superclass of the immediately enclosing class.
It is a compile-time error ifS_staticdoes not have a method []=.
Otherwise, letS_1be the static type of the
first formal parameter of the method []=,
andS_2the static type of the second.
It is a compile-time error if the static type ofe_1respectivelye_2may not be assigned toS_1respectivelyS_2.
The static type ofais the static type ofe_2.


For evaluation, an assignment of the form [e_1] = e_2
is equivalent to the expression .[e_1] = e_2.


  ¬ß.¬ß.¬ß Compound Assignment
compoundAssignment
v ??= e
Consider a compound assignmentaof the form v ??= e
wherevis an identifier or an identifier qualified by an import prefix.
Exactly the same compile-time errors that would be caused by
v = e
are also generated in the case ofa.
The static type ofais
the least upper bound of the static type ofvand the static type ofe.


Evaluation of a compound assignmentaof the form v ??= e
proceeds as follows:
Evaluatevto an objecto.
Ifois not the null object (<ref>),aevaluates too.
Otherwise evaluate v = e to an objectr,
and thenaevaluates tor.

C.v ??= e
Consider a compound assignmentaof the form C.v ??= e
whereCis a type literal
that may or may not be qualified by an import prefix.
Exactly the same compile-time errors that would be caused by
C.v = e
are also generated in the case ofa.
The static type ofais the least upper bound of
the static type of C.v and the static type ofe.


Evaluation of a compound assignmentaof the form C.v ??= e
whereCis a type literal proceeds as follow:
Evaluate C.v to an objecto.
Ifois not the null object (<ref>),aevaluates too.
Otherwise evaluate C.v = e to an objectr,
and thenaevaluates tor.

e_1.v ??= e_2
Consider a compound assignmentaof the form e_1.v ??= e_2.
LetTbe the static type ofe_1and letxbe a fresh variable of typeT.
Except for errors insidee_1and references to the namex,
exactly the same compile-time errors that would be caused by
x.v = e_2
are also generated in the case ofa.
Moreover, it is a compile-time error ifTdoes not have a getter namedv.
The static type ofais the least upper bound of
the static type of e_1.v and the static type ofe_2.


Evaluation of a compound assignmentaof the form e_1.v ??= e_2
proceeds as follows:
Evaluatee_1to an objectu.
Letxbe a fresh variable bound tou.
Evaluate x.v to an objecto.
Ifois not the null object (<ref>),aevaluates too.
Otherwise evaluate x.v = e_2 to an objectr,
and thenaevaluates tor.

e_1[e_2] ??= e_3
Consider a compound assignmentaof the form e_1[e_2] ??= e_3.
Exactly the same compile-time errors that would be caused by
e_1[e_2] = e_3
are also generated in the case ofa.
Moreover, it is a compile-time error
if the static type ofe_1does not have an `operator []'.
The static type ofais the least upper bound of
the static type of e_1[e_2] and the static type ofe_3.


Evaluation of a compound assignmentaof the form
e_1[e_2] ??= e_3
proceeds as follows:
Evaluatee_1to an objectuand then evaluatee_2to an objecti.
Call the [] method onuwith argumenti,
and letobe the returned object.
Ifois not the null object (<ref>),aevaluates too.
Otherwise evaluatee_3to an objectvand then call the []= method onuwithias first argument andvas second argument.
Thenaevaluates tov.

.v ??= e
Consider a compound assignmentaof the form .v ??= e.
Exactly the same compile-time errors that would be caused by
.v = e
are also generated in the case ofa.
Moreover, exactly the same compile-time errors that would be caused by
evaluation of the expression .v
are also generated in the case ofa.
The static type ofais the least upper bound of
the static type of .v and the static type ofe.


Evaluation of a compound assignmentaof the form .v ??= e
proceeds as follows:
Evaluate .v to an objecto.
Ifois not the null object (<ref>) thenaevaluates too.
Otherwise evaluate .v = e to an objectr,
and thenaevaluates tor.

e_1?.v ??= e_2
Consider a compound assignmentaof the form e_1?.v ??= e_2.
Exactly the same compile-time errors that would be caused by
e_1.v ??= e_2
are also generated in the case ofa.




The static type ofais the least upper bound of
the static type of e_1?.v and the static type ofe_2.


Evaluation of a compound assignmentaof the form e_1?.v ??= e_2
proceeds as follows:
Evaluatee_1to an objectu.
Ifuis the null object (<ref>) thenaevaluates to the null object.
Otherwise, letxbe a fresh variable bound tou.
Evaluate x.v to an objecto.
Ifois not the null object (<ref>) thenaevaluates too.
Otherwise evaluate x.v = e_2 to an objectr,
and thenaevaluates tor.

C?.v ??= e_2
A compound assignment of the form C?.v ??= e_2
whereCis a type literal
that may or may not be qualified by an import prefix
is equivalent to the expression C.v ??= e.

vop= e
For any other valid operatorop,
a compound assignment of the form vop= e
is equivalent to v = vope,
wherevis an identifier or an identifier qualified by an import prefix.

C.vop= e
A compound assignment of the form C.vop= e
whereCis a type literal
that may or may not be qualified by an import prefix
is equivalent to C.v = C.vope.

e_1.vop= e_2
Consider a compound assignmentaof the form e_1.vop= e_2.
Letxbe a fresh variable whose static type is the static type ofe_1.
Except for errors insidee_1and references to the namex,
exactly the same compile-time errors that would be caused by
x.v = x.vope_2
are also generated in the case ofa.
The static type ofais the static type of e_1.vope_2.


Evaluation of a compound assignmentaof the form e_1.vop= e_2
proceeds as follows:
Evaluatee_1to an objectuand letxbe a fresh variable bound tou.
Evaluate x.v = x.vope_2 to an objectrand thenaevaluates tor.

e_1[e_2] op= e_3
Consider a compound assignmentaof the form e_1[e_2] op= e_3.
Letxandibe fresh variables
where the static type of the former is the static type ofe_1and the static type of the latter is the static type ofe_2.
Except for errors insidee_1ande_2and references to
the namesxandi,
exactly the same compile-time errors that would be caused by
x[i] = x[i] ope_3
are also generated in the case ofa.
The static type ofais the static type of x[i] ope_3.


Evaluation of s compound assignmentaof the form
e_1[e_2] op= e_3
proceeds as follows:
Evaluatee_1to an objectuand evaluatee_2to an objectv.
Letxandibe fresh variables bound touandvrespectively.
Evaluate x[i] = x[i] ope_3 to an objectr,
and thenaevaluates tor.

e_1?.vop= e_2
Consider a compound assignmentaof the form e_1?.vop= e_2.
Exactly the same compile-time errors that would be caused by
e_1.vop= e_2
are also generated in the case ofa.
The static type ofais the static type of e_1.vop= e_2.


Evaluation of a compound assignmentaof the form
e_1?.vop= e_2
proceeds as follows:
Evaluatee_1to an objectu.
Ifuis the null object, thenaevaluates to the null object (<ref>).
Otherwise letxbe a fresh variable bound tou.
Evaluate x.vop= e_2 to an objectr.
Thenaevaluates tor.

C?.vop = e_2
A compound assignment of the form C?.vop = e_2
whereCis a type literal
is equivalent to the expression C.vop = e_2.


 ¬ß.¬ß Conditional
conditional
A conditional expression evaluates one of two expressions
based on a boolean condition.


<conditionalExpression> ::= <ifNullExpression>
   (`?' <expressionWithoutCascade> `:' <expressionWithoutCascade>)?

Evaluation of a conditional expressioncof the forme_1 ? e_2 : e_3proceeds as follows:


First,e_1is evaluated to an objecto_1.

It is a dynamic error if the run-time type ofo_1is not bool.
Ifris , then the value ofcis
the result of evaluating the expressione_2.
Otherwise the value ofcis the result of evaluating the expressione_3.


Ife_1shows that a local variablevhas typeT,
then the type ofvis known to beTine_2,
unless any of the following are true:

  * v is potentially mutated in e_2,

  * v is potentially mutated within a function other
  than the one where v is declared, or

  * v is accessed by a function defined in e_2 and
  v is potentially mutated anywhere in the scope of v.

It is a compile-time error if
the static type ofe_1may not be assigned to bool.
The static type ofcis the least upper bound (<ref>) of
the static type ofe_2and the static type ofe_3.




 ¬ß.¬ß If-null Expressions
ifNull
An if-null expression evaluates an expression and
if the result is the null object (<ref>), evaluates another.


<ifNullExpression> ::= <logicalOrExpression> (`??' <logicalOrExpression>)*

Evaluation of an if-null expressioneof the form e_1 ?? e_2
proceeds as follows:


Evaluatee_1to an objecto.
Ifois not the null object (<ref>), theneevaluates too.
Otherwise evaluatee_2to an objectr,
and theneevaluates tor.


The static type ofeis the least upper bound (<ref>) of
the static type ofe_1and the static type ofe_2.




 ¬ß.¬ß Logical Boolean Expressions
logicalBooleanExpressions
The logical boolean expressions combine boolean objects using
the boolean conjunction and disjunction operators.


<logicalOrExpression> ::= 
  <logicalAndExpression> (`||' <logicalAndExpression>)*

<logicalAndExpression> ::= <equalityExpression> (`&&' <equalityExpression>)*

A logical boolean expression is either an equality expression
(<ref>),
or an invocation of a logical boolean operator on
an expressione_1with argumente_2.


Evaluation of a logical boolean expressionbof the forme_1 || e_2causes
the evaluation ofe_1to an objecto_1.

It is a dynamic error if the run-time type ofo_1is not bool.
Ifo_1is , the result of evaluatingbis ,
otherwisee_2is evaluated to an objecto_2.

It is a dynamic error if the run-time type ofo_2is not bool.
Otherwise the result of evaluatingbiso_2.


Evaluation of a logical boolean expressionbof the forme_1 && e_2causes the evaluation ofe_1producing an objecto_1.

It is a dynamic error if the run-time type ofo_1is not bool.
Ifo_1is , the result of evaluatingbis ,
otherwisee_2is evaluated to an objecto_2.

It is a dynamic error if the run-time type ofo_2is not bool.
Otherwise the result of evaluatingbiso_2.


A logical boolean expressionbof the forme_1 && e_2shows that a local variablevhas typeTif both of the following conditions hold:

  *  Either e_1 shows that v has type T
  or e_2 shows that v has type T.

  * v is not mutated in e_2 or within a function
  other than the one where v is declared.

Ife_1shows that a local variablevhas typeT,
then the type ofvis known to beTine_2,
unless any of the following are true:










  * v is potentially mutated in e_1,

  * v is potentially mutated in e_2,

  * v is potentially mutated within a function other
  than the one where v is declared, or

  * v is accessed by a function defined in e_2 and
  v is potentially mutated anywhere in the scope of v.

It is a compile-time error if
the static type ofe_1may not be assigned to bool
or if the static type ofe_2may not be assigned to bool.
The static type of a logical boolean expression is bool.




 ¬ß.¬ß Equality
equality
Equality expressions test objects for equality.


<equalityExpression> ::= 
  <relationalExpression> (<equalityOperator> <relationalExpression>)?
   <equalityOperator> <relationalExpression>

<equalityOperator> ::= `=='
   `!='

An equality expression is either a relational expression
(<ref>),
or an invocation of an equality operator on either 
or an expressione_1, with argumente_2.


Evaluation of an equality expressioneeof the form e_1 == e_2
proceeds as follows:

  *  The expression e_1 is evaluated to an object o_1.

  *  The expression e_2 is evaluated to an object o_2.

  *  If either o_1 or o_2 is the null object (<ref>),
  then ee evaluates to  if both o_1 and o_2 are the null object
  and to  otherwise.
Otherwise,

  *  evaluation of ee is equivalent to the method invocation
  o_1.==(o_2).

Evaluation of an equality expressioneeof the form
 == e
proceeds as follows:

  *  The expression e is evaluated to an object o.

  *  If either  or o is the null object (<ref>),
  then ee evaluates to evaluates to 
  if both  and o are the null object
  and to  otherwise.
Otherwise,

  *  evaluation of ee is equivalent to the method invocation
  .==(o).

As a result of the above definition,
user defined == methods can assume that their argument is non-null,
and avoid the standard boiler-plate prelude:

if (identical(, arg)) return ;

Another implication is that there is never a need
to use identical() to test against ,
nor should anyone ever worry about whether to write
 == e or e == .

An equality expression of the form e_1 != e_2 is equivalent to
the expression !(e_1 == e_2).
An equality expression of the form  != e is equivalent to
the expression !( == e).





The static type of an equality expression is bool.




 ¬ß.¬ß Relational Expressions
relationalExpressions
Relational expressions invoke the relational operators on objects.


<relationalExpression> ::= <bitwiseOrExpression> 
  (<typeTest> | <typeCast> | <relationalOperator> <bitwiseOrExpression>)?
   <relationalOperator> <bitwiseOrExpression>

<relationalOperator> ::= `>='
   `>'
   `<='
   `<'

A relational expression is either a bitwise expression
(<ref>),
or an invocation of a relational operator on either 
or an expressione_1, with argumente_2.


A relational expression of the forme_1ope_2is equivalent to
the method invocation e_1.op(e_2).
A relational expression of the formope_2is equivalent to
the method invocation .op(e_2).




 ¬ß.¬ß Bitwise Expressions
bitwiseExpressions
Bitwise expressions invoke the bitwise operators on objects.


<bitwiseOrExpression> ::= 
  <bitwiseXorExpression> (`|' <bitwiseXorExpression>)*
   (`|' <bitwiseXorExpression>)+

<bitwiseXorExpression> ::= 
  <bitwiseAndExpression> (`^' <bitwiseAndExpression>)*
   (`^' <bitwiseAndExpression>)+

<bitwiseAndExpression> ::= <shiftExpression> (`&' <shiftExpression>)*
   (`&' <shiftExpression>)+

<bitwiseOperator> ::= `&'
   `^'
   `|'

A bitwise expression is either a shift expression (<ref>),
or an invocation of a bitwise operator
on either  or an expressione_1,
with argumente_2.


A bitwise expression of the form e_1ope_2 is equivalent to
the method invocatione_1.op(e_2).
A bitwise expression of the form ope_2 is equivalent to
the method invocation .op(e_2).


It should be obvious that the static type rules for these expressions
are defined by the equivalence above‚Äîergo,
by the type rules for method invocation and
the signatures of the operators on the type e_1.
The same holds in similar situations throughout this specification.


 ¬ß.¬ß Shift
shift
Shift expressions invoke the shift operators on objects.


<shiftExpression> ::= 
  <additiveExpression> (<shiftOperator> <additiveExpression>)*
   (<shiftOperator> <additiveExpression>)+

<shiftOperator> ::= `'
   `'
   `'

A shift expression is either an additive expression
(<ref>),
or an invocation of a shift operator
on either  or an expressione_1,
with argumente_2.


A shift expression of the forme_1ope_2is equivalent to
the method invocation e_1.op(e_2).
A shift expression of the formope_2is equivalent to
the method invocation .op(e_2).


Note that this definition implies left-to-right evaluation order
among shift expressions:
e_1 < e_2 < e_3
is evaluated as
(e_1 < e_2).< (e_3) which is equivalent to
(e_1 < e_2) < e_3.
The same holds for additive and multiplicative expressions.


 ¬ß.¬ß Additive Expressions
additiveExpressions
Additive expressions invoke the addition operators on objects.


<additiveExpression> ::= <multiplicativeExpression>
   (<additiveOperator> <multiplicativeExpression>)*
   (<additiveOperator> <multiplicativeExpression>)+

<additiveOperator> ::= `+'
   `-'

An additive expression is either a multiplicative expression
(<ref>),
or an invocation of an additive operator
on either  or an expressione_1,
with argumente_2.


An additive expression of the forme_1ope_2is equivalent to
the method invocation e_1.op(e_2).
An additive expression of the formope_2is equivalent to
the method invocation .op(e_2).


The static type of an additive expression is usually determined
by the signature given in the declaration of the operator used.
However, invocations of the operators + and - of
class int, double and num
are treated specially by the typechecker.


Letebe an additive expression of the form e_1ope_2,
letTbe the static type ofe_1,
and letCbe the context type ofe.

If Tnum and not TNever, then
the context type ofe_2is determined as follows:

  *  If intC and not numC,
      and Tint
      then the context type of e_2 is int.
  
  *  If doubleC and not numC,
      and not Tdouble
     then the context type of e_2 is double.
  
  *  Otherwise the context type of e_2 is num.

Let furtherSbe the static type ofe_2.
If Tnum and not TNever
andSis assignable to num,
then the static type ofeis determined as follows:

  *  If Tdouble
    then the static type of e is T.
  
  *  Otherwise, if Sdouble
    and not SNever,
    then the static type of e is double.
  
  *  Otherwise, if Tint,
    Sint and not SNever,
    then the static type of e is int.
  
  *  Otherwise the static type of e is num.


 ¬ß.¬ß Multiplicative Expressions
multiplicativeExpressions
Multiplicative expressions invoke the multiplication operators on objects.


<multiplicativeExpression> ::= 
  <unaryExpression> (<multiplicativeOperator> <unaryExpression>)*
   (<multiplicativeOperator> <unaryExpression>)+

<multiplicativeOperator> ::= `*'
   `/'
   `%'
   `¬†/'

A multiplicative expression is either a unary expression
(<ref>),
or an invocation of a multiplicative operator
on either  or an expressione_1,
with argumente_2.


A multiplicative expression of the forme_1ope_2is equivalent to
the method invocation e_1.op(e_2).
A multiplicative expression of the formope_2is equivalent to
the method invocation .op(e_2).


The static type of an multiplicative expression is usually determined
by the signature given in the declaration of the operator used.
However, invocations of the operators * and % of
class int, double and num
are treated specially by the typechecker.


Letebe a multiplicative expression of the form e_1ope_2
whereopis one of * or %,
letTbe the static type ofe_1,
and letCbe the context type ofe.

If Tnum and not TNever, then
the context type ofe_2is determined as follows:

  *  If intC and not numC,
      and Tint
      then the context type of e_2 is int.
  
  *  If doubleC and not numC,
      and not Tdouble
     then the context type of e_2 is double.
  
  *  Otherwise the context type of e_2 is num.

Let furtherSbe the static type ofe_2.
If Tnum and not TNever
andSis assignable to num,
then the static type ofeis determined as follows:

  *  If Tdouble
    then the static type of e is T.
  
  *  Otherwise, if Sdouble
    and not SNever,
    then the static type of e is double.
  
  *  Otherwise, if Tint,
    Sint and not SNever,
    then the static type of e is int.
  
  *  Otherwise the static type of e is num.


 ¬ß.¬ß Unary Expressions
unaryExpressions
Unary expressions invoke unary operators on objects.


<unaryExpression> ::= <prefixOperator> <unaryExpression>
   <awaitExpression>
   <postfixExpression>
   (<minusOperator> | <tildeOperator>)  <incrementOperator> <assignableExpression>

<prefixOperator> ::= <minusOperator>
   <negationOperator>
   <tildeOperator>

<minusOperator> ::= `-'

<negationOperator> ::= `!'

<tildeOperator> ::= `¬†'

A unary expression is either a postfix expression
(<ref>),
an await expression (<ref>)
or an invocation of a prefix operator on an expression
or an invocation of a unary operator on either  or an expressione.


The expression!eis treated as
(<ref>)
(e ?  : ).


An expression of the form ++e is treated as
(e += 1).
An expression of the form --e is treated as
(e -= 1).


Letebe an expression of the form -l
wherelis an integer literal (<ref>) with numeric integer valuei,
and with static context typeT.
If double is assignable toTand int is not assignable toT,
then the static type ofeis double;
otherwise the static type ofeis int.


If the static type ofeis int theneevaluates to
an instance of the int class representing the numeric value-i.
Ifiis zero and the int class can represent a negative zero value,
then the resulting instance instead represents that negative zero value.
It is a compile-time error if the integer-icannot be represented
exactly by an instance of int.


If the static type ofeis double theneevaluates to
to an instance of the double class representing the numeric value-i.
Ifiis zero, the resulting instance instead represents the
negative zero double value, -0.0.
It is a compile-time error if the integer-icannot be represented
exactly by an instance of double.

We treat -las if it is a single integer literal
with a negative numeric value.
We do not evaluate l individually as an expression,
or concern ourselves with its static type.

Any other expression of the form ope is equivalent to
the method invocation e.op().
An expression of the form op is equivalent to
the method invocation (<ref>) .op().




 ¬ß.¬ß Await Expressions
awaitExpressions
An await expression allows code to
yield control until an asynchronous operation
(<ref>)
completes.


<awaitExpression> ::=  <unaryExpression>

a, e, S
Letabe an expression of the form   e.
LetSbe the static type ofe.
The static type ofais then S
(<ref>).


Evaluation ofaproceeds as follows:
First, the expressioneis evaluated to an objecto.
Let T be S.
If the run-time type ofois a subtype of Future<T>,
then let f beo;
otherwise letfbe the result of creating
a new object using the constructor Future<T>.value()
withoas its argument.


Next, the stream associated with
the innermost enclosing asynchronous  loop
(<ref>),
if any, is paused.
The current invocation of the function body immediately enclosingais suspended until afterfcompletes.
At some time afterfis completed, control returns to the current invocation.
Iffhas completed with an errorxand stack tracet,athrowsxandt(<ref>).
Iffcompletes with an objectv,aevaluates tov.


The use of  to find T and hence determine the dynamic type test
implies that we await a future in every case where this choice is sound.

An interesting case on the edge of this trade-off is when e
has the static type FutureOr<Object>?.
You could say that the intention behind this type is that
the value of e is a Future<Object>,
or it is an Object which is not a future,
or it is .
So, presumably, we should await the first kind,
and we should pass on the second and third kind unchanged.
However, the second kind could be a Future<Object?>.
This object isn't a Future<Object>, and it isn't ,
so it must be considered to be in the second group.
Nevertheless, FutureOr<Object>? is Object?,
so we will await a Future<Object?>.
We have chosen this semantics because it was the smallest breaking change
relative to the semantics in earlier versions of Dart,
and also because it allows for a simple rule:
The type of   e is used to decide whether or not
the future (if any) is awaited, and there are no exceptions‚Äîeven
in cases like this example, where the type seems to imply that
a Future<Object?> should not be awaited.
In summary, we await every future that we can soundly await.

An await expression can only occur in a function which is declared
asynchronous. The  identifier has has no special meaning
in the context of a normal function, so occurrences of 
in those functions does not introduce an await expression.
However,  (e) can be a valid function invocation in
non-asynchronous functions.

An await expression could not meaningfully occur in a synchronous function.
If such a function were to suspend waiting for a future,
it would no longer be synchronous.

It is not a compile-time error if the type of e is not
a supertype or subtype of Future.
Tools may choose to give a hint in such cases.


 ¬ß.¬ß Postfix Expressions
postfixExpressions
Postfix expressions invoke the postfix operators on objects.


<postfixExpression> ::= <assignableExpression> <postfixOperator>
   <primary> <selector>*

<postfixOperator> ::= <incrementOperator>

<constructorInvocation> ::= 
  <typeName> <typeArguments> `.' <identifier> <arguments>

<selector> ::= `!'
   <assignableSelector>
   <argumentPart>

<argumentPart> ::=
  <typeArguments>? <arguments>

<incrementOperator> ::= `++'
   `-'

A postfix expression is either a primary expression;
a function, method or getter invocation;
an invocation of a named constructor;
or an invocation of a postfix operator on an expressione.
All but the latter two are specified elsewhere.


Constructor Invocations
Consider a constructorInvocationeof the form
n<typeArguments>.ùïÄ(arguments).
Ifndoes not denote a classCthat declares a constructor named C.ùïÄ,
a compile-time error occurs.


Otherwise, ifeoccurs in a constant context
(<ref>)
theneis treated as   e,
and ifedoes not occur in a constant context
theneis treated as   e.




Note that e cannot be anything other than an instance creation
(constant or not)
because e provides actual type arguments to n,
which is not supported if n denotes a library prefix,
nor if e is a static method invocation.

v++, v--
Consider a postfix expressioneof the form v ,
wherevis an identifier and  is either ++ or --.
A compile-time error occurs unlessvdenotes a variable,
orvdenotes a getter and there is an associated setter v=.
LetTbe the static type of the variablevor the return type of the getter.
A compile-time error occurs ifTis not 
andTdoes not have an operator + (when  is ++)
or operator - (when  is --),
or if the return type of this operator is not assignable to
the variable respectively the argument type of the setter.
A compile-time error occurs if int is not assignable to
the parameter type of said operator.
The static type ofeisT.


Evaluation of a postfix expressioneof the form v++ respectively v--,
wherevis an identifier, proceeds as follows:
Evaluatevto an objectrand letybe a fresh variable bound tor.



Evaluate v = y + 1 respectively v = y - 1.
Theneevaluates tor.


The above ensures that if the evaluation involves a getter,
it gets called exactly once.
Likewise in the cases below.

C.v++, C.v--
Consider a postfix expressioneof the form C.v ,
whereCis a type literal and  is either ++ or --.
A compile-time error occurs unless C.v denotes a static getter
and there is an associated static setter v=
(possibly implicitly induced by a static variable).
LetTbe the return type of said getter.
A compile-time error occurs ifTis not 
andTdoes not have an operator + (when  is ++)
or operator - (when  is --),
or if the return type of this operator is not assignable to
the argument type of the setter.
A compile-time error occurs if int is not assignable to
the parameter type of said operator.
The static type ofeisT.


Evaluation of a postfix expressioneof the form C.v++ respectively C.v--
whereCis a type literal proceeds as follows:
Evaluate C.v to an objectrand letybe a fresh variable bound tor.
Evaluate C.v = y + 1 respectively C.v = y - 1.
Theneevaluates tor.

e_1.v++, e_1.v--
Consider a postfix expressioneof the form e_1.v 
where  is either ++ or --.
LetSbe the static type ofe_1.
A compile-time error occurs unlessShas
a getter namedvand a setter named v=
(possibly implicitly induced by an instance variable).
LetTbe the return type of said getter.
A compile-time error occurs ifTis not 
andTdoes not have an operator + (when  is ++)
or operator - (when  is --),
or if the return type of this operator is not assignable to
the argument type of the setter.
A compile-time error occurs if int is not assignable to
the parameter type of said operator.
The static type ofeisT.


Evaluation of a postfix expressioneof the form e_1.v++ respectively e_1.v--
proceeds as follows:
Evaluatee_1to an objectuand letxbe a fresh variable bound tou.
Evaluate x.v to an objectrand letybe a fresh variable bound tor.
Evaluate x.v = y + 1 respectively x.v = y - 1.
Theneevaluates tor.

e_1[e_2]++, e_1[e_2]--
Consider a postfix expressioneof the form e_1[e_2] 
where  is either ++ or --.
LetS_1be the static type ofe_1andS_2be the static type ofe_2.
A compile-time error occurs unlessS_1has
an operator [] and an operator []=.
LetTbe the return type of the former.
A compile-time error occurs unlessS_2is assignable to
the first parameter type of said operator []=.
A compile-time error occurs ifTis not 
andTdoes not have an operator + (when  is ++)
or operator - (when  is --),
or if the return type of this operator is not assignable to
the second argument type of said operator []=.


A compile-time error occurs if passing the integer literal 1
as an argument to said operator + or - would be an error.
The static type ofeisT.


Evaluation of a postfix expressioneof the form e_1[e_2]++ respectively e_1[e_2]--
proceeds as follows:
Evaluatee_1to an objectuande_2to an objectv.
Letaandibe fresh variables bound touandvrespectively.
Evaluate a[i] to an objectrand letybe a fresh variable bound tor.
Evaluate a[i] = y + 1 respectively a[i] = y - 1.
Theneevaluates tor.

e_1?.v++, e_1?.v--
Consider a postfix expressioneof the form e_1?.v 
where  is either ++ or --.
Exactly the same compile-time errors that would be caused by
e_1.v 
are also generated in the case of e_1?.v .
The static type ofeis the static type of e_1.v.


Evaluation of a postfix expressioneof the form e_1?.v++ respectively e_1?.v--
proceeds as follows:
Ife_1is a type literal, evaluation ofeis equivalent to
evaluation of e_1.v++ respectively e_1.v--.
Otherwise evaluatee_1to an objectu.
ifuis the null object,eevaluates to the null object (<ref>).
Otherwise letxbe a fresh variable bound tou.
Evaluate x.v++ respectively x.v-- to an objecto.
Theneevaluates too.


 ¬ß.¬ß Assignable Expressions
assignableExpressions
Assignable expressionsassignable expression are terms
that can appear on the left hand side of an assignment.
This section describes how to evaluate subterms of these terms when needed.
The semantics of an assignment as a whole is described elsewhere
(<ref>).


The grammar of assignable expressions includes very general forms
like an identifier ùïÄ or a qualified identifier ùïÄ_1.ùïÄ_2.
Hence, an assignable expression can have many different meanings,
depending on the binding of those identifiers in the context.

For example, the term x.y.z is an assignable expression.
x.y may refer to a getter y on
an object referenced by a variable x,
in which case x.y will be evaluated to an object
before accessing the z member of that object.
The term x.y could also denote a class y referenced through
an import prefix x,
with z denoting a static variable of that class.
In this case x.y will not be evaluated to a value.

<assignableExpression> ::= <primary> <assignableSelectorPart>
   <unconditionalAssignableSelector>
   <identifier>

<assignableSelectorPart> ::= <selector>* <assignableSelector>

<unconditionalAssignableSelector> ::= `[' <expression> `]'
   `.' <identifier>

<assignableSelector> ::= <unconditionalAssignableSelector>
   `?.' <identifier>
   `?' `[' <expression> `]'


The section about assignments
(<ref>)
specifies the static analysis and dynamic semantics of
various forms of assignment.
Each of those cases is applicable when the specified subterms satisfy
the given side conditions
(
e.g., one case of the form e_1.v  ??=  e_2 requires e_1
to be an expression, whereas C.v  ??=  e
requires C to be a type literal
).
The cases requiring subterms to be expressions are considered least specific,
that is, they are only used if no other case matches
(
so the case containing C is used if the corresponding term is a type literal
).


Syntactically, these expressions are not derived from expression,
but they are derivable from expression, e.g., because
an assignableExpression may contain a primary
which is derivable from expression.
We use the following rule to find such expressions:

e, t
Letebe an assignableExpression.
Assume thattis a term such thatecan be derived from
t <assignableSelector>.
In this case we say thattis the
receiver termassignable expression!receiver term
ofe.
Whentis an expression, we say thattis the
receiver expressionassignable expression!receiver expression
ofe.


In short, we obtain t by cutting off an assignable selector
from the end of e.
It is easy to see that only some assignableExpressions
have a receiver term.
For instance, a plain identifier does not.


Letebe an assignable expression.
Assume thatehas a receiver expressiont.
Evaluation oftproceeds in the same way as
evaluation of any other expression.




 ¬ß.¬ß Lexical Lookup
lexicalLookup
This section specifies how to look up a name
based on the enclosing lexical scopes.
This is known as a lexical lookup.
When ùïÄ is an identifier,
it may look up a namenof the form ùïÄ as well as of the form ùïÄ=.


A lexical lookup can yield a declaration or an import prefix,
and it can yield nothing.


It is not a compile-time error when the lexical lookup yields nothing.
In this situation the given name n will be transformed into
.n,
and the static analysis of the resulting expression
may or may not have any compile-time errors.

A lexical lookup may incur a compile-time error,
as specified below.
However, that is different from a result yielded by the lexical lookup,
because this specification never specifies the propagation of errors.


In other words, when other parts of this specification indicate that
a lexical lookup is performed,
they need to consider the further steps taken
when the lookup yields a declaration,
when it yields an import prefix,
and when it yields nothing.
But they do not mention that, e.g., ùïÄ.m is an error
because the lexical lookup for ùïÄ incurred an error.

A lexical lookup differs from a lookup of an instance member
(<ref>)
because that operation searches through a sequence of superclasses,
whereas a lexical lookup searches through a sequence of enclosing scopes.
A lexical lookup differs from a straightforward lookup in the enclosing scopes
because the lexical lookup ‚Äúbundles‚Äù getters and setters,
as detailed below.

n, id
Consider the situation where a namenhas basename ùïÄ
(<ref>)
where ùïÄ is an identifier,
and a lexical lookup ofnis performed from a given location
‚Ñì.


We specify a name and a location from where a lexical lookup is performed.
The location is not always redundant:
In some situations we perform a lookup for a setter named ùïÄ=,
but the token ùïÄ= does not occur in the program.
To handle such situations we must specify both
the name which is being looked up,
and the location that determines which scopes are the enclosing ones.

When we say that a lexical lookup of the identifier ùïÄ is performed,
it is understood that the lookup is performed from
the location of the given occurrence of ùïÄ.


LetSbe the innermost lexical scope containing‚Ñìwhich has a declaration with basename ùïÄ.
In the case whereShas
a declaration named ùïÄ as well as a declaration named ùïÄ=,
let D be the declaration namedn.
In the situation whereShas
exactly one declaration with basename ùïÄ,
letDbe that declaration.


A non-local variable declaration named ùïÄ will implicitly induce
a getter ùïÄ and possibly a setter ùïÄ= into the current scope.
This means that D may denote an implicitly induced getter or setter
rather than the underlying variable declaration.
That is significant in the case where an error must arise
because the lookup was for one kind, but only the other kind exists.

If we are looking up a name n with basename ùïÄ,
we stop searching if we find any declaration named ùïÄ or ùïÄ=.
If, in that scope, there are declarations for both ùïÄ and ùïÄ=,
we return the one which has the requested name n.
In the case where only one declaration is present, we return it,
even though it may have the name ùïÄ when n is ùïÄ=, or vice versa.
That situation may cause an error, as specified below.

In the first step, we check for several potential errors.



D exists
In this case, at least one declaration with basename ùïÄ
is in scope at the location‚Ñì.
It is a compile-time error if the name ofDis notn,
unlessDis an instance member or a local variable
(which may be a formal parameter).


That is, it is an error if we look for a setter and find a getter,
or vice versa,
but not an error if we look for a setter and find a local variable.
If we look for a setter and find an instance getter, or vice versa,
it is not an error,
because the setter could be inherited.
That is checked after yielding nothing
(which implies that  will be prepended).

IfDis an instance member,
it is a compile-time error if‚Ñìdoes not have access to .

D does not exist
It is a compile-time error if‚Ñìdoes not have access to 
(<ref>).

We are always looking up bothùïÄ and ùïÄ=,
no matter whether n is ùïÄ or ùïÄ=.
This approach creates a tighter connection between a pair of declarations
where one is a getter named ùïÄ
and the other is a setter named ùïÄ=.
This allows developers to think about
a getter and setter that are declared together as a single entity,
rather than two independent declarations.

For example, if a term refers to ùïÄ and needs a setter,
and the innermost declaration named ùïÄ or ùïÄ= is a getter g
and there is no corresponding setter,
it is a compile-time error.
This error occurs even in the case where a more remote enclosing scope has
a declaration of a setter s named ùïÄ=,
because we already committed to using g
(so that's actually ‚Äúa setter/getter pair where the setter is missing‚Äù),
and we could say that this ‚Äúpair‚Äù shadows s:
 id(int value) {} // This is s
 A {
  int  id => 42; // This is g
  user() {
    id = 0; // Compile-time error}}
In the second and last step, if no error occurred,
proceed as described in the first applicable case from the following list:


  * 
  When D does not exist,
  the lexical lookup yields nothing.
  
    In this case it is guaranteed that ‚Ñì has access to ,
    and n will be treated as .n.
    But errors may still occur, e.g.,
    because there is no member of the interface of  named n,
    and also no accessible and applicable extension method.
  
  * 
  Consider the case where D is a formal type parameter declaration
  of a class or a mixin.
  It is a compile-time error if ‚Ñì occurs inside
  a static method, static getter, or static setter,
  or inside a static variable initializer.
  
  
  
  Otherwise, the lexical lookup yields D.

  * 
  Consider the case where D is an instance member declaration in
  a class or mixin A.
  The lexical lookup then yields nothing.
  
    In this case it is guaranteed that ‚Ñì has access to .
  
  * 
  
  
  
  
  
  
  
  Otherwise, the lexical lookup yields D.

Note that a lexical lookup will never yield a declaration of
an instance member.
In each case where it is determined that there is no error,
and an instance member is the result of the lookup,
the lexical lookup yields nothing.

The reason for this is that there may not be a declaration in scope,
but the interface of the class could have the required member,
or an extension method could be applicable.
So, for uniformity,
in these situations we always report that nothing was found,
which implies that  should be added.


 ¬ß.¬ß Identifier Reference
identifierReference
An identifier expression consists of a single identifier;
it provides access to an object via an unqualified name.
A typeIdentifier is an identifier which can be used
as the name of a type declaration.


A qualifiedName is not an identifier expression,
but we specify its syntax here because it is used in several different contexts,
and it is more closely related to the plain identifier
than it is to any single one of those grammar rules where it is used.

<identifier> ::= <IDENTIFIER>
   <BUILT_IN_IDENTIFIER>
   <OTHER_IDENTIFIER>

<typeIdentifierNotType> ::= <IDENTIFIER>
   <OTHER_IDENTIFIER_NOT_TYPE>
  

<typeIdentifier> ::= <typeIdentifierNotType>
  

<qualifiedName> ::= <typeIdentifier> `.' <identifier>
   <typeIdentifier> `.' <typeIdentifier> `.' <identifier>

<BUILT_IN_IDENTIFIER> ::=  |  |  |  |  |  |  |
     |  |  |  |  |  |
     |  |  |  |  |  | 

<OTHER_IDENTIFIER_NOT_TYPE> ::=  |  |  |  |  |  |
   | 

<OTHER_IDENTIFIER> ::= 
  <OTHER_IDENTIFIER_NOT_TYPE> | 

<IDENTIFIER_NO_DOLLAR> ::= <IDENTIFIER_START_NO_DOLLAR>
   <IDENTIFIER_PART_NO_DOLLAR>*

<IDENTIFIER_START_NO_DOLLAR> ::= <LETTER> | `_'

<IDENTIFIER_PART_NO_DOLLAR> ::= 
  <IDENTIFIER_START_NO_DOLLAR> | <DIGIT>

<IDENTIFIER> ::= <IDENTIFIER_START> <IDENTIFIER_PART>*

<IDENTIFIER_START> ::= <IDENTIFIER_START_NO_DOLLAR> | `'

<IDENTIFIER_PART> ::= <IDENTIFIER_START> | <DIGIT>

<LETTER> ::= `a' .. `z' | `A' .. `Z'

<DIGIT> ::= `0' .. `9'

<WHITESPACE> ::= (`
t' | ` ' | <LINE_BREAK>)+

The ordering of the lexical rules above ensure that IDENTIFIER
and IDENTIFIER_NO_DOLLAR do not derive any built-in identifiers.
Similarly, the lexical rule for reserved words (<ref>)
must be considered to come before the rule for BUILT_IN_IDENTIFIER,
such that IDENTIFIER and IDENTIFIER_NO_DOLLAR
also do not derive any reserved words.


A built-in identifier is one of
the identifiers produced by the production BUILT_IN_IDENTIFIER.


Note that it is a syntax error if a built-in identifier
is used as the declared name of

a prefix, class, mixin, enum, type parameter, type alias, or extension.
Similarly, it is a syntax error to use a built-in identifier
other than  or 
as an identifier in a type annotation or a type parameter bound.

Built-in identifiers are identifiers that are used as keywords in Dart,
but are not reserved words.
A built-in identifier may not be used to name a class or type.
In other words, they are treated as reserved words when used as types.
This eliminates many confusing situations,
both for human readers and during parsing.

It is a compile-time error if either of the identifiers  or 
is used as an identifier in a function body
marked with either , *, or *.


This makes the identifiers  and  behave like reserved words
in a limited context.
This approach was chosen because it was less breaking than it would have been
to make  and  reserved words or built-in identifiers,
at the time where these features were added to the language.

A qualified name is two or three identifiers separated by ..
All but the last one must be a typeIdentifier.
It is used to denote a declaration which is imported with a prefix,
or a  declaration in a class, mixin, enum, or extension, or both.


The static type of an identifier expressionewhich is an identifier ùïÄ
is determined as follows.
Perform a lexical lookup of ùïÄ
(<ref>)
from the location ofe.


Lexical lookup yields a declaration
LetDbe the declaration yielded by the lexical lookup of ùïÄ.


  * 
  If D declares a class, mixin, enum, type alias, an enumerated type,
  or a type parameter,
  the static type of e is Type.

  * 
  If D is the declaration of a library getter
  (which may be implicitly induced by a library variable),
  the static type of e is the static type of the
  library getter invocation ùïÄ
  (<ref>).

  * 
  If D is a static method, library function, or local function,
  the static type of e is the function type of D.

  
    Note that e may subsequently be subjected to
    generic function instantiation
    (<ref>).
  
  * 
  If D is the declaration of a static getter
  (which may be implicitly induced by a static variable)
  and D occurs in the class C,
  the static type of e is the return type of the getter
  C.ùïÄ.

  * 
  If D is a local variable declaration
  (which can be a formal parameter)
  the static type of e is the type of the variable v declared by D,
  unless v is known to have some type T,
  where T is a subtype of any other type S
  such that v is known to have type S,
  in which case the static type of e is T.

  * 
  If D is a declaration of an instance getter
  in an extension declaration E,
  then the static type of e is the return type of D.

  * 
  If D is a declaration of an instance method
  in an extension declaration E,
  then the static type of e is the function type of D.

  * 
    A lexical lookup will never yield a declaration
    which is an instance member of a class.
  

Lexical lookup yields an import prefix
In this case the lexical lookup
(<ref>)
for ùïÄ yields an import prefixp.

In this case a compile-time error occurs,
unless the token immediately followingeis ..
No static type is associated withein this case.






No such type is needed, because every construct where
an import prefix p is used and followed by . is specified
in such a way that the type of p is not used.

Lexical lookup yields nothing
When the lexical lookup
(<ref>)
for ùïÄ yields nothing,eis treated as
(<ref>)
.ùïÄ.


In this case it is known that e has access to 
(<ref>).
Both the static analysis and evaluation proceeds with
.ùïÄ,
so there is no need to further specify the treatment of e.

Evaluation of an identifier expressioneof the form ùïÄ
proceeds as follows:


Lexical lookup yields a declaration
In this case the lexical lookup
(<ref>)
for ùïÄ yields a declarationD.
The evaluation ofeproceeds as follows:


  * 
  If D is a class, mixin, enum, or type alias,
  the value of e is an object implementing the class Type
  which reifies the corresponding type.

  * 
  If D is a type parameter X then the value of e is
  the value of the actual type argument corresponding to X
  that was passed to the generative constructor that created
  the current binding of .

  * 
  If D is the declaration of a library getter
  (which may be implicitly induced by a library variable),
  evaluation of e is equivalent to evaluation of an invocation of
  the library getter ùïÄ
  (<ref>).

  * 
  
  
  If D is a library, class, or local constant variable of one of the forms
  v = e'; or Tv = e';
  then the value of e is the value of the constant expression e'.

  * 
  If D is a declaration of
  a top-level function, static method, or local function,
  then e evaluates to the function object obtained by closurization
  (<ref>)
  of D.

  * 
  If D is an instance getter declaration in an extension declaration E,
  then e evaluates to the result of invoking said getter
  with the current binding of , and
  the current bindings of the type parameters declared by D.

  * 
  If D is an instance method declaration in an extension declaration E
  with type parameters X1s,
  then e evaluates to the result of the extension method closurization
  E<X1s>().ùïÄ
  (<ref>).

  * 
  If D is a local variable v
  (which can be a formal parameter)
  then e evaluates to the current binding of v.

Note that D cannot be the declaration of
a static variable, static getter or static setter declared in a class C,
because in that case e is treated as
(<ref>)
the property extraction
(<ref>)
C.ùïÄ,
which also determines the evaluation of e.

Lexical lookup yields an import prefix
This situation cannot arise,
because it is a compile-time error
to evaluate an import prefix as an expression,
and no constructs involving an import prefix
(e.g., such as a property extraction p.m)
will evaluate the import prefix.

Lexical lookup yields nothing
This situation cannot arise,
because this only occurs wheneis treated as
.ùïÄ,
whose evaluation is specified elsewhere
(<ref>).


 ¬ß.¬ß Type Test
typeTest
The is-expression tests if an object is a member of a type.


<typeTest> ::= <isOperator> <typeNotVoid>

<isOperator> ::=  `!'?

Evaluation of the is-expression eT proceeds as follows:


The expressioneis evaluated to an objectv.
If the dynamic type ofvis a subtype ofT,
the is-expression evaluates to .
Otherwise it evaluates to .


It follows that e Object is always true.
This makes sense in a language where everything is an object.

Also note that T is false
unless T = Object, T = or T = Null.
The former two are useless, as is anything
of the form e Object or e.
Users should test for the null object (<ref>) directly
rather than via type tests.

The is-expression e! T is equivalent to
!(eT).


Letvbe a local variable (which can be a formal parameter).
An is-expression of the form vT
shows thatvhas typeTifTis a subtype of the type of the expressionv.

Otherwise,
if the declared type ofvis the type variableX,
andTis a subtype of the bound ofX,
andX & Tis a subtype of the type of the expressionv,
theneshows thatvhas typeX & T.

Otherwiseedoes not show thatvhas typeTfor anyT.


The motivation for the ‚Äúshows that v has type T" relation is
to reduce spurious errors thereby enabling a more natural coding style.
The rules in the current specification are deliberately kept simple.
It would be upwardly compatible to refine these rules in the future;
such a refinement would accept more code without errors,
but not reject any code now error-free.

The rule only applies to locals and parameters,
as non-local variables could be modified
via side-effecting functions or methods that are not accessible
to a local analysis.

It is pointless to deduce a weaker type than what is already known.
Furthermore, this would lead to a situation where multiple types are
associated with a variable at a given point,
which complicates the specification.
Hence the requirement that the promoted type is a subtype of the current type.

In any case, it is not an error when a type test does not show
that a given variable does not have a ‚Äúbetter‚Äù type than previously known,
but tools may choose to give a hint in such cases,
if suitable heuristics indicate that a promotion is likely to be intended.

The static type of an is-expression is bool.




 ¬ß.¬ß Type Cast
typeCast
The cast expression ensures that an object is a member of a type.


<typeCast> ::= <asOperator> <typeNotVoid>

<asOperator> ::= 
 Evaluation of the cast expression eT proceeds as follows:


The expressioneis evaluated to an objectv.

It is a dynamic type error ifois not the null object (<ref>),
and the dynamic type ofois not a subtype ofT.
Otherwiseeevaluates tov.


The static type of a cast expression eT isT.




¬ß STATEMENTS
statements
A statement is a fragment of Dart code that can be executed at run time.
Statements, unlike expressions, do not evaluate to an object,
but are instead executed for their effect on the program state and control flow.


<statements> ::= <statement>*

<statement> ::= <label>* <nonLabelledStatement>

<nonLabelledStatement> ::= <block>
   <localVariableDeclaration>
   <forStatement>
   <whileStatement>
   <doStatement>
   <switchStatement>
   <ifStatement>
   <rethrowStatement>
   <tryStatement>
   <breakStatement>
   <continueStatement>
   <returnStatement>
   <yieldStatement>
   <yieldEachStatement>
   <expressionStatement>
   <assertStatement>
   <localFunctionDeclaration>


  ¬ß.¬ß.¬ß Statement Completion
statementCompletion
Execution of a statement completescompletion
in one of five ways:
either it
completes normallycompletion!normally,
it breakscompletion!breaks
or it continuescompletion!continues
(either to a label or without a label),
it returnscompletion!returns (with or without an object),
or it throwscompletion!throws
an exception object and an associated stack trace.


In descriptions of statement execution the default is that
the execution completes normally unless otherwise stated.


If the execution of a statement,s,
is defined in terms of executing another statement,
and the execution of that other statement does not complete normally,
then, unless otherwise stated, the execution ofsstops
at that point and completes in the same way.

For example, if execution of the body of a  loop returns an object,
so does execution of the  loop statement itself.

If the execution of a statement is defined in terms of evaluating an expression
and the evaluation of that expression throws,
then, unless otherwise stated, the execution of the statement stops
at that point and throws the same exception object and stack trace.

For example,
if evaluation of the condition expression of an  statement throws,
then so does execution of the  statement.
Likewise, if evaluation of the expression of a  statement throws,
so does execution of the  statement.





 ¬ß.¬ß Blocks
blocks
A block statement supports sequencing of code.


Execution of a block statement{s_1, ‚Ä¶, s_n}proceeds as follows:


Fori ‚àà 1 .. n, s_iis executed.


A block statement introduces a new scope,
whose enclosing scope is the current scope of the block statement.




 ¬ß.¬ß Expression Statements
expressionStatements
An expression statement consists of an expression that does not
begin with a { character.


<expressionStatement> ::= <expression>? `;'

The expression of an expression statement is not allowed
to begin with a {.

This means that if some source text could otherwise be parsed as an expression
followed by a ;, then this grammar production does not apply
when the expression starts with a {.

The restriction resolves an ambiguity while parsing where a
{ can start either a block (<ref>) or
a map literal (<ref>).
By disallowing the latter from starting an expression statement,
the parser does not need to look further ahead
before deciding that it is parsing a block statement.

Execution of an expression statement e; proceeds by evaluatinge.
If the expression evaluates to an object,
then the object is ignored and the execution completes normally.




 ¬ß.¬ß Local Variable Declaration
localVariableDeclaration
A variable declaration statement,
also known as a local variable declaration,
has the following form:


<localVariableDeclaration> ::= <metadata> <initializedVariableDeclaration> `;'

Each local variable declaration introduces
a local variablevariable!local
into the current scope.


Local variables do not induce getters and setters.
Note that a formal parameter declaration also introduces
a local variable into the associated formal parameter scope
(<ref>).

The properties of being
initializedvariable!initialized or
constantvariable!constant
apply to local variables with the same definitions as for other variables
(<ref>).



We say that a local variablevis potentially mutated
in some scopesifvis not final, and an assignment tovoccurs ins.


A local variable declaration of the form v; is equivalent to
v = ;.
IfTis a nullable type
(<ref>)
then a local variable declaration of the form Tv;
is equivalent to Tv = ;.



If T is a potentially non-nullable type
then a local variable declaration of the form Tv; is allowed,
but an expression that gives rise to evaluation of v
is a compile-time error unless flow analysis
(<ref>)
shows that the variable is guaranteed to have been initialized.

A local variable has an associated
declared typelocal variable!declared type
which is determined from its declaration.
A local variable also has an associated
typelocal variable!type
which is determined by flow analysis
(<ref>)
via a process known as type promotion
(<ref>).


The declared type of a local variable with a declaration of one of the forms
?  T  v = e;?    T  v = e;  T  v = e;
isT.


The declared type of a local variable with a declaration of one of the forms
?    v = e;?    v = e;  v = e;
is determined as follows:


  * 
  If the static type of e is Null then
  the declared type of v is .

  * 
  If the static type of e is of the form X & T
  where X is a type variable
  (<ref>),
  the declared type of v is X.
  
    In this case v is immediately promoted to X & T
    (<ref>).
  
  * 
  Otherwise, the declared type of v is the static type of e.

Letvbe a local variable declared by an initializing variable declaration,
and letebe the associated initializing expression.
It is a
compile-time error if the static type ofeis not assignable to
the declared type ofv.



If a local variable v is  and not ,
it is not a compile-time error if the declaration of v is
not an initializing variable declaration,
but an expression that gives rise to evaluation of v
is a compile-time error unless flow analysis shows that
the variable is guaranteed to have been initialized.
Similarly, an expression that gives rise to an assignment to v
is a compile-time error unless flow analysis shows that
it is guaranteed that the variable has not been initialized.

In every situation which is not covered by the previous paragraph,
it is a compile-time error to assign to a local variable
which is  and not 
(<ref>).

Assume thatDis a local variable declaration with the modifier 
that declares a variablev,
which has an initializing expressione.
It is a compile-time error ifecontains an  expressiona(<ref>),
unless there is a functionfwhich is
the immediately enclosing function fora,
andfis not the immediately enclosing function forD.


In other words,
the initializing expression cannot await an expression directly,
any await expressions must be syntactically nested inside some other function,
that is, a function literal.

It is a compile-time error if
a local variable is referenced at a source code location that is before
the end of its initializing expression, if any,
and otherwise before the declaring occurrence of
the identifier which names the variable.


The example below illustrates the expected behavior.
A variable `x' is declared at the library level,
and another `x' is declared inside the function `f'.
 x = 0;


f(y) { z = x; // compile-time error
  if (y) {
    x = x + 1; // two compile-time errors
    print(x); // compile-time error} x = x++; // compile-time error
  print(x);
}
The declaration inside `f' hides the enclosing one.
So all references to `x' inside `f'
refer to the inner declaration of `x'.
However, many of these references are illegal,
because they appear before the declaration.
The assignment to `z' is one such case.
The assignment to `x' in the  statement
suffers from multiple problems.
The right hand side reads `x' before its declaration,
and the left hand side assigns to `x' before its declaration.
Each of these are, independently, compile-time errors.
The print statement inside the  is also illegal.

The inner declaration of `x' is itself erroneous
because its right hand side attempts to
read `x' before the declaration has terminated.
The occurrence of `x' that declares and names the variable
(that is, the one to the left of `=' in the inner declaration)
is not a reference, and so is legal.
The last print statement is perfectly legal as well.

As another example  x = 3, y = x; is legal,
because x is referenced after its initializer.

A particularly perverse example involves
a local variable name shadowing a type.
This is possible because Dart has a
single namespace for types, functions and variables.
 C {}
perverse() { v =  C(); // compile-time error
  C aC; // compile-time error C = 10;
}
Inside perverse(), `C' denotes a local variable.
The type `C' is hidden by the variable of the same name.
The attempt to instantiate `C' causes a compile-time error
because it references a local variable prior to its declaration.
Similarly, for the declaration of `aC'.

Execution of a variable declaration statement of one of the forms
v = e;Tv = e;v = e;Tv = e;v = e; or
Tv = e;
proceeds as follows:


The expressioneis evaluated to an objecto.

A dynamic type error occurs
if the dynamic type ofois not a subtype of the actual declared type
(<ref>)
ofv.
Otherwise, the variablevis bound too.


Note that e could have been transformed due to implicit coercions.
For example, myFunction could be transformed into
myFunction<int> due to generic function instantiation
(<ref>).
Such transformations are assumed to have taken place already
in the declarations above.

LetDbe a  and  local variable declaration
that declares a variablev.
If an objectois assigned tovin a situation wherevis unbound
thenvis bound too.
If an objectois assigned tovin a situation wherevis bound to an objecto'then a dynamic error occurs
(it does not matter whether o is the same object as o').




 ¬ß.¬ß Local Function Declaration
localFunctionDeclaration
A function declaration statement declares a new local function
(<ref>).


<localFunctionDeclaration> ::= <metadata> <functionSignature> <functionBody>

A function declaration statement of one of the forms
ùïÄsignature{statements}
or
TùïÄsignature{statements}
causes a new function named ùïÄ to be added to the current scope.
It is a compile-time error to reference a local function before its declaration.


This implies that local functions can be directly recursive,
but not mutually recursive.
Consider these examples:

f(x) => x++; // a top level function

top() { // another top level function
  f(3); // illegal
  f(x) => x > 0? x*f(x-1): 1; // recursion is legal
  g1(x) => h(x, 1); // error: h is not declared yet
  h(x, n) => x > 1? h(x-1, n*x): n; // again, recursion is fine
  g2(x) => h(x, 1); // legal

  p1(x) => q(x,x); // illegal
  q1(a, b)=> a > 0 ? p1(a-1): b; // fine

  q2(a, b) => a > 0 ? p2(a-1): b; // illegal
  p1(x) => q2(x,x); // fine}
There is no way to write a pair of mutually recursive local functions,
because one always has to come before the other is declared.
These cases are quite rare,
and can always be managed by defining a pair of variables first,
then assigning them appropriate function literals:

top2() { // a top level function p, q;
  p = (x) => q(x,x);
  q = (a, b) => a > 0 ? p(a-1): b;
}
The rules for local functions differ slightly from those for local variables
in that a function can be accessed within its declaration
but a variable can only be accessed after its declaration.
This is because recursive functions are useful
whereas recursively defined variables are almost always errors.
It therefore makes sense to harmonize the rules for local functions
with those for functions in general rather than
with the rules for local variables.


 ¬ß.¬ß If
if
The if statement allows for conditional execution of statements.


<ifStatement> ::=  `(' <expression> `)' <statement> ( <statement>)?

An if statement of the form
 (e) s_1s_2
wheres_1is not a block statement is equivalent to the statement
 (e) {s_1}s_2.
An if statement of the form
 (e) s_1s_2
wheres_2is not a block statement is equivalent to the statement
 (e) s_1{s_2}.


The reason for this equivalence is to catch errors such as
 main() { (somePredicate)
     v = 2;
  print(v);
}
Under reasonable scope rules such code is problematic.
If we assume that v is declared
in the scope of the method main(),
then when somePredicate is false,
v will be uninitialized when accessed.
The cleanest approach would be to require a block following the test,
rather than an arbitrary statement.
However, this goes against long standing custom,
undermining Dart's goal of familiarity.
Instead, we choose to insert a block, introducing a scope,
around the statement following the predicate
(and similarly for  and loops).
This will cause a compile-time error in the case above.
Of course, if there is a declaration of v in the surrounding scope,
programmers might still be surprised.
We expect tools to highlight cases of shadowing
to help avoid such situations.

Execution of an if statement of the form
 (b) s_1s_2
wheres_1ands_2are block statements,
proceeds as follows:


First, the expressionbis evaluated to an objecto.

It is a dynamic error if the run-time type ofois not bool.
Ifois , then the block statements_1is executed,
otherwise the block statements_2is executed.


It is a compile-time error if the type of the expressionbmay not be assigned to bool.


Ifbshows that a local variablevhas typeT,
then the type ofvis known to beTins_1,
unless any of the following are true

  * v is potentially mutated in s_1,

  * v is potentially mutated within a function other
  than the one where v is declared, or

  * v is accessed by a function defined in s_1 and
  v is potentially mutated anywhere in the scope of v.

An if statement of the form  (e) s is equivalent to
the if statement  (e) s{}.




 ¬ß.¬ß For
for
The for statement supports iteration.


<forStatement> ::= ?  `(' <forLoopParts> `)' <statement>

<forLoopParts> ::= <forInitializerStatement> <expression>? `;' <expressionList>?
   <forInLoopPrefix>  <expression>

<forInLoopPrefix> ::= <metadata> <declaredIdentifier>
   <identifier>

<forInitializerStatement> ::= <localVariableDeclaration>
   <expression>? `;'

The for statement has three forms - the traditional for loop
and two forms of the for-in statement - synchronous and asynchronous.




  ¬ß.¬ß.¬ß For Loop
forLoop
Execution of a for statement of the form
 (v = e_0; c; e) s proceeds as follows:


Ifcis empty then letc'be  otherwise letc'bec.


First the variable declaration statementv = e_0is executed.
Then:

  * 
  If this is the first iteration of the for loop, let v' be v.
  Otherwise, let v' be the variable v‚Äù created in
  the previous execution of step <ref>.

  * 
  The expression [v'/v]c is evaluated to an object o.
  
  It is a dynamic error if the run-time type of o is not bool.
  If o is , the for loop completes normally.
  Otherwise, execution continues at step <ref>.

  * 
  The statement [v'/v]{s} is executed.

  If this execution completes normally, continues without a label,
  or continues to a label (<ref>)
  that prefixes this  statement (<ref>),
  then execution of the statement is treated as if it had completed normally.

  
  Let v‚Äù be a fresh variable.
  v‚Äù is bound to the value of v'.

  * 
  The expression [v‚Äù/v]e is evaluated, and
  the process recurses at step <ref>.

The definition above is intended to prevent the common error
where users create a function object inside a for loop,
intending to close over the current binding of the loop variable, and find
(usually after a painful process of debugging and learning)
that all the created function objects have captured
the same value‚Äîthe one current in the last iteration executed.

Instead, each iteration has its own distinct variable.
The first iteration uses the variable created by the initial declaration.
The expression executed at the end of each iteration uses
a fresh variable v‚Äù,
bound to the value of the current iteration variable,
and then modifies v‚Äù as required for the next iteration.

It is a compile-time error if the static type ofcmay not be assigned to bool.










  ¬ß.¬ß.¬ß For-in
for-in
LetDbe derived from <finalConstVarOrType>?.
A for statement of the form  (DùïÄe)  S
is then treated as the following code,
whereùïÄ_1andùïÄ_2are fresh identifiers:

TùïÄ_1 = e;
ùïÄ_2 = id_1.iterator;
 (ùïÄ_2.moveNext()) {  DùïÄ = ùïÄ_2.current;
  {S}}
If the static type ofeis a top type
(<ref>)
thenTis Iterable<>,
otherwiseTis the static type ofe.
It is a compile-time error ifTis not assignable to
Iterable<>.


It follows that it is a compile-time error


if D is empty and ùïÄ is a final variable.
Also, it is a dynamic error if e has type ,
but e evaluates to an instance of a type
which is not a subtype of Iterable<>.


  ¬ß.¬ß.¬ß Asynchronous For-in
asynchronousFor-in
A for-in statement may be asynchronous.
The asynchronous form is designed to iterate over streams.
An asynchronous for loop is distinguished by
the keyword  immediately preceding the keyword .


LetDbe derived from <finalConstVarOrType>?.
Execution of a for-in statement,f, of the form
 (DùïÄe) s
proceeds as follows:


The expressioneis evaluated to an objecto.

It is a dynamic type error ifois not an instance of
a class that implements Stream.
It is a compile-time error ifDis empty
and ùïÄ is a final or constant variable.


The stream associated with the innermost enclosing asynchronous for loop,
if any, is paused.
The streamois listened to, producing a stream subscriptionu,
and execution of the asynchronous for-in loop is suspended
until a stream event is available.

This allows other asynchronous events to execute
while this loop is waiting for stream events.


Pausing an asynchronous for loop means pausing
the associated stream subscription.
A stream subscription is paused by calling its pause method.
If the subscription is already paused, an implementation may omit
further calls to pause.


The pause call can throw, although that should never happen
for a correctly implemented stream.

For each data event fromu,
the statementsis executed with ùïÄ bound to
the value of the current data event.


Either execution of s is completely synchronous, or it contains an
asynchronous construct (,   , , or *)
which will pause the stream subscription of its surrounding asynchronous loop.
This ensures that no other event of u occurs
before execution of s is complete,
if o is a correctly implemented stream.
If o doesn't act as a valid stream,
for example by not respecting pause requests,
the behavior of the asynchronous loop may become unpredictable.

If execution ofscontinues without a label,
or to a label (<ref>)
that prefixes the asynchronous for statement (<ref>),
then the execution ofsis treated as if it had completed normally.


If execution ofsotherwise does not complete normally,
the subscriptionuis canceled by evaluating v.cancel()
wherevis a fresh variable referencing the stream subscriptionu.
If that evaluation throws,
execution offthrows the same exception and stack trace.
Otherwise execution offcompletes in the same way as the execution ofs.



Otherwise the execution offis suspended again, waiting for
the next stream subscription event,
anduis resumed if it has been paused.

The resume call can throw, in which case the asynchronous for
loop also throws.
That should never happen for a correctly implemented stream.

On an error event fromu,
with error objecteand stack tracest,
the subscriptionuis canceled by evaluating  v.cancel()
wherevis a fresh variable referencing the stream subscriptionu.
If that evaluation throws,
execution offthrows the same exception object and stack trace.
Otherwise execution offthrows
witheas exception object andstas stack trace.


Whenuis done, execution offcompletes normally.


It is a compile-time error if an asynchronous for-in statement appears
inside a synchronous function (<ref>).
It is a compile-time error if a traditional for loop (<ref>) is
prefixed by the  keyword.


An asynchronous loop would make no sense within a synchronous function,
for the same reasons that an await expression makes no sense
in a synchronous function.


 ¬ß.¬ß While
while
The while statement supports conditional iteration,
where the condition is evaluated prior to the loop.


<whileStatement> ::=  `(' <expression> `)' <statement>

Execution of a while statement of the form  (e) s;
proceeds as follows:


The expressioneis evaluated to an objecto.

It is a dynamic error if the run-time type ofois not bool.


Ifois , then execution of the while statement completes normally
(<ref>).


Otherwiseois  and then the statement{s}is executed.
If that execution completes normally or it continues with no label
or to a label (<ref>) that prefixes the  statement
(<ref>),
then the while statement is re-executed.
If the execution breaks without a label,
execution of the while statement completes normally.

If the execution breaks with a label that prefixes the  statement,
it does end execution of the loop,
but the break itself is handled by
the surrounding labeled statement (<ref>).

It is a compile-time error if
the static type ofemay not be assigned to bool.




 ¬ß.¬ß Do
do
The do statement supports conditional iteration,
where the condition is evaluated after the loop.


<doStatement> ::=  <statement>  `(' <expression> `)' `;'

Execution of a do statement of the form s (e);
proceeds as follows:


The statement{s}is executed.
If that execution continues with no label,
or to a label (<ref>) that prefixes the do statement
(<ref>),
then the execution ofsis treated as if it had completed normally.


Then, the expressioneis evaluated to an objecto.

It is a dynamic error if the run-time type ofois not bool.
Ifois , execution of the do statement completes normally
(<ref>).
Ifois , then the do statement is re-executed.


It is a compile-time error if the static type ofemay not be assigned to bool.




 ¬ß.¬ß Switch
switch
The switch statement supports dispatching control among
a large number of cases.


<switchStatement> ::=  `(' <expression> `)' `' <switchCase>* <defaultCase>? `'

<switchCase> ::= <label>*  <expression> `:' <statements>

<defaultCase> ::= <label>*  `:' <statements>

Consider a switch statement of the form

 (e) {  label_11‚Ä¶ label_1j_1e_1: s_1  ‚Ä¶  label_n1‚Ä¶ label_nj_ne_n: s_n  label_(n+1)1‚Ä¶ label_(n+1)j_n+1: s_n+1}
or the form

 (e) {  label_11‚Ä¶ label_1j_1e_1: s_1  ‚Ä¶  label_n1‚Ä¶ label_nj_ne_n: s_n}
Note that each expression e_j, j ‚àà 1 .. n occurs in a constant context
(<ref>),
which means that  modifiers need not be specified explicitly.

It is a compile-time error unless each expressione_j, j ‚àà 1 .. nis constant.
It is a compile-time error if the value of the expressionse_j, j ‚àà 1 .. nare not either:

  *  instances of the same class C, for all j ‚àà 1 .. n, or

  *  instances of a class that implements int,
  for all j ‚àà 1 .. n, or

  *  instances of a class that implements String,
  for all j ‚àà 1 .. n.

In other words, all the expressions in the cases evaluate to constants of
the exact same user defined class or are of certain known types.




Note that the values of the expressions are known at compile time,
and are independent of any type annotations.

It is a compile-time error if the classCdoes not have primitive equality
(<ref>).


The prohibition on user defined equality allows us to
implement the switch efficiently for user defined types.
We could formulate matching in terms of identity instead,
with the same efficiency.
However, if a type defines an equality operator,
programmers would presumably find it quite surprising
if equal objects did not match.

The  statement should only be used in
very limited situations (e.g., interpreters or scanners).

Execution of a switch statement of the form

 (e) {  label_11‚Ä¶ label_1j_1e_1: s_1  ‚Ä¶  label_n1‚Ä¶ label_nj_ne_n: s_n  label_(n+1)1‚Ä¶ label_(n+1)j_n+1: s_n+1}

or the form

 (e) {  label_11‚Ä¶ label_1j_1e_1: s_1  ‚Ä¶  label_n1‚Ä¶ label_nj_ne_n: s_n}

proceeds as follows:


The statement ùïÄ = e; is evaluated,
where ùïÄ is a fresh variable.


It is a dynamic error if the value ofeis
not an instance of the same class as the constantse_1, ‚Ä¶, e_n.


Note that if there are no case clauses (n = 0),
the type of e does not matter.

Next, the case clausee_1:s_1is matched against ùïÄ,
ifn > 0.
Otherwise if there is a  clause,
the case statementss_n+1are executed (<ref>).


Matching of a  clausee_k: s_kof a switch statement

 (e) {  label_11‚Ä¶ label_1j_1e_1: s_1  ‚Ä¶  label_n1‚Ä¶ label_nj_ne_n: s_n  label_(n+1)1‚Ä¶ label_(n+1)j_n+1: s_n+1}

against the value of a variable ùïÄ proceeds as follows:


The expression e_k == ùïÄ is evaluated to an objecto.

It is a dynamic error if the run-time type ofois not bool.
Ifois  the following case,e_k+1: s_k+1is matched against ùïÄ ifk < n,
and ifk = n, then the  clause's statements are executed
(<ref>).
Ifois , lethbe the smallest number
such thath ‚â• kands_his non-empty.
If no suchhexists, leth = n + 1.
The case statementss_hare then executed (<ref>).


Matching of a  clausee_k: s_kof a switch statement

 (e) {  label_11‚Ä¶ label_1j_1e_1: s_1  ‚Ä¶  label_n1‚Ä¶ label_nj_ne_n: s_n}

against the value of a variable ùïÄ proceeds as follows:


The expression e_k == ùïÄ is evaluated to an objecto.

It is a dynamic error if the run-time type ofois not bool.
Ifois  the following case,e_k+1: s_k+1is matched against ùïÄ ifk < n.
Ifois , lethbe the smallest integer
such thath ‚â• kands_his non-empty.
If such ahexists, the case statementss_hare executed
(<ref>).
Otherwise the switch statement completes normally
(<ref>).


It is a compile-time error if the type ofemay not be assigned to the type ofe_k.
Letsbe the last statement of the statement sequences_k.
Ifsis a non-empty block statement, letsinstead be
the last statement of the block statement.
It is a compile-time error ifsis not
a , , , or  statement,
or an expression statement where the expression is a  expression.


The behavior of switch cases intentionally differs from the C tradition.
Implicit fall through is a known cause of programming errors
and therefore disallowed.
Why not simply break the flow implicitly at the end of every case,
rather than requiring explicit code to do so?
This would indeed be cleaner.
It would also be cleaner to insist that each case have
a single (possibly compound) statement.
We have chosen not to do so in order to
facilitate porting of switch statements from other languages.
Implicitly breaking the control flow at the end of a case would silently alter
the meaning of ported code that relied on fall-through,
potentially forcing the programmer to deal with subtle bugs.
Our design ensures that the difference is immediately brought to
the coder's attention.
The programmer will be notified at compile time if they forget to end a case
with a statement that terminates the straight-line control flow.

The sophistication of the analysis of fall-through is another issue.
For now, we have opted for a very straightforward syntactic requirement.
There are obviously situations where code does not fall through,
and yet does not conform to these simple rules, e.g.:
 (x) { 1: {‚Ä¶; }{‚Ä¶; }}
Very elaborate code in a case clause is probably bad style in any case,
and such code can always be refactored.

It is a static warning if all of the following conditions hold:

  *  The switch statement does not have a default clause.

  *  The static type of e is an enumerated
  type with elements ùïÄ_1, ‚Ä¶, ùïÄ_n.

  *  The sets {e_1, ‚Ä¶, e_k} and {ùïÄ_1, ‚Ä¶, ùïÄ_n}
  are not the same.

In other words, a static warning will be emitted
if a switch statement over an enum is not exhaustive.


  ¬ß.¬ß.¬ß Switch case statements
case-execute
Execution of the case statementss_hof a switch statement

 (e) {  label_11‚Ä¶ label_1j_1e_1: s_1  ‚Ä¶  label_n1‚Ä¶ label_nj_ne_n: s_n}

or a switch statement

 (e) {  label_11‚Ä¶ label_1j_1e_1: s_1  ‚Ä¶  label_n1‚Ä¶ label_nj_ne_n: s_n  label_(n+1)1‚Ä¶ label_(n+1)j_n+1: s_n+1}

proceeds as follows:


Execute{s_h}.
If this execution completes normally,
and ifs_his not the statements of the last case of the switch
(h = nif there is no  clause,h = n+1if there is a  clause),
then the execution of the switch case throws an error.
Otherwises_hare the last statements of the switch case,
and execution of the switch case completes normally.


In other words, there is no implicit fall-through between non-empty cases.
The last case in a switch (default or otherwise) can `fall-through'
to the end of the statement.


If execution of{s_h}breaks with no label (<ref>),
then the execution of the switch statement completes normally.

If execution of{s_h}continues to a label
(<ref>),
and the label islabel_ij,
where1 ‚â§ i ‚â§ n+1if the  statement has a ,
or1 ‚â§ i ‚â§ nif there is no ,
and where1 ‚â§ j ‚â§ j_i,
then lethbe the smallest number such thath ‚â• iands_his non-empty.
If no suchhexists,
leth = n + 1if the  statement has a ,
otherwise leth = n.
The case statementss_hare then executed (<ref>).

If execution of{s_h}completes in any other way,
execution of the  statement completes in the same way.




 ¬ß.¬ß Rethrow
rethrow
The rethrow statement is used to
re-throw an exception and its associated stack trace.


<rethrowStatement> ::=  `;'

Consider a  statementS.





Letfbe the immediately enclosing function ofS.
A compile-time error occurs unlessSis located in an - clause
whose immediately enclosing function isf.


Execution of a  statement proceeds as follows:


Letfbe the immediately enclosing function,
and let   T    (p_1,  p_2)
be the immediately enclosing catch clause (<ref>).


A  statement always appears inside a  clause,
and every  clause is treated as some  clause of the form
  T    (p1,  p2).
So we can consider the  statement to be enclosed in
a  clause of that form.

The  statement then throws (<ref>)
with the value ofp_1as the exception object,
and the value ofp_2as the stack trace.




 ¬ß.¬ß Try
try
The try statement supports the definition of exception handling code
in a structured way.


<tryStatement> ::=  <block> (<onPart>+ <finallyPart>? | <finallyPart>)

<onPart> ::= <catchPart> <block>
   <typeNotVoid> <catchPart>? <block>

<catchPart> ::=  `(' <identifier> (`,' <identifier>)? `)'

<finallyPart> ::=  <block>

A try statement consists of a block statement, followed by at least one of:

  * 
  A set of - clauses, each of which specifies
  (either explicitly or implicitly)
  the type of exception object to be handled,
  one or two exception parameters,
  and a block statement.

  * 
A  clause, which consists of a block statement.

The syntax is designed to be upward compatible with
existing Javascript programs.
The  clause can be omitted,
leaving what looks like a Javascript catch clause.

A try statement of the form
s_1on-catch_1 ‚Ä¶ on-catch_n;
is equivalent to the statement
s_1on-catch_1 ‚Ä¶ on-catch_n{}.


An - clause of the form
T (p_1) s
is equivalent to an - clause
T (p_1, p_2) s
wherep_2is a fresh identifier.


An - clause of the form
Ts
is equivalent to an - clause
T (p_1, p_2) s
wherep_1andp_2are fresh identifiers.


An - clause of the form
 (p) s
is equivalent to an - clause
 (p, p_2) s
wherep_2is a fresh identifier.

An - clause of the form
 (p_1, p_2) s
is equivalent to an - clause
 (p_1, p_2) s.


An - clause of the form
T (p_1, p_2) s
introduces a new scopeCSin which final local variables
specified byp_1andp_2are defined.
The statementsis enclosed withinCS.
The static type ofp_1isTand the static type ofp_2is StackTrace.


Execution of a  statementsof the form:

bT_1 (e_1, t_1) c_1‚Ä¶T_n (e_n, t_n) c_nf
proceeds as follows:


Firstbis executed.
If execution ofbthrows (<ref>)
with exception objecteand stack tracet,
theneandtare matched against the - clauses
to yield a new completion (<ref>).

Then, even if execution ofbdid not complete normally
or matching against the - clauses did not complete normally,
thefblock is executed.

If execution offdoes not complete normally,
execution of the  statement completes in the same way.
Otherwise if execution ofbthrew (<ref>),
the  statement completes in the same way as
the matching against the - clauses.
Otherwise the  statement completes in the same way as
the execution ofb.


It is a compile-time error ifT_i,1 ‚â§ i ‚â§ nis a deferred type.




  ¬ß.¬ß.¬ß - clauses
on-catch
Matching an exception objecteand stack tracetagainst
a (potentially empty) sequence of - clauses of the form

T_1 (e_1, st_1) {s_1}‚Ä¶T_n (e_n, st_n) {s_n}
proceeds as follows:


If there are no - clauses (n = 0), matching throws
the exception objecteand stack tracet(<ref>).


Otherwise the exception is matched against the first clause.


Otherwise, if the type ofeis a subtype ofT_1,
then the first clause matches,
and thene_1is bound to the exception objecteandt_1is bound to the stack tracet,
ands_1is executed in this scope.
The matching completes in the same way as this execution.


Otherwise, if the first clause did not matche,eandtare recursively matched against
the remaining - clauses:

T_2 (e_2, t_2) {s_2}‚Ä¶T_n (e_n, t_n) {s_n}

 ¬ß.¬ß Return
return
The return statement
returns a result to the caller of a synchronous function,
completes the future associated with an asynchronous function,
or terminates the stream or iterable associated with a generator
(<ref>).


<returnStatement> ::=  <expression>? `;'

Consider a return statementsof the form e?;.
LetSbe the static type ofe, ifeis present,
letfbe the immediately enclosing function,
and letTbe the declared return type off.


Synchronous non-generator functions
Consider the case wherefis a synchronous non-generator function
(<ref>).


It is a compile-time error ifsis ;,
unlessTis , , or Null.



It is a compile-time error ifsis e;,Tis ,
andSis neither , , nor Null.


It is a compile-time error ifsis e;,Tis neither , , nor Null,
andSis .


It is a compile-time error ifsis e;,Sis not ,
andSis not assignable toT.


Note that T cannot be , , or Null in the last case,
because all types are assignable to those types.
An error will not be raised if f has no declared return type,
since the return type would be , to which every type is assignable.
However, a synchronous non-generator function
that declares a return type which is not ‚Äúvoidy‚Äù
must return an expression explicitly.

This helps catch situations where users forget
to return an object in a return statement.

Asynchronous non-generator functions
Consider the case wherefis an asynchronous non-generator function
(<ref>).


It is a compile-time error ifsis ;,
unless T
(<ref>)
is , , or Null.


An asynchronous non-generator always returns a future of some sort.
If no expression is given, the future will be completed with the null object
(<ref>)
which motivates this rule.


It is a compile-time error ifsis e;,
T is ,
and S is neither , , nor Null.


It is a compile-time error ifsis e;,
T is neither , , nor Null,
and S is .


It is a compile-time error ifsis e;,
S is not ,
and Future<S> is not assignable toT.


Note that T cannot be , , or Null
in the last case,
because then Future<U> is assignable to T for allU.
In particular, when T is FutureOr<Null>
(which is equivalent to Future<Null>),
Future<S> is assignable to T for all S.
This means that no compile-time error is raised,
but only the null object (<ref>)
or an instance of Future<Null> can successfully be returned at run time.
This is not an anomaly,
it corresponds to the treatment of a synchronous function
with return type Null;
but tools may choose to give a hint that a downcast is unlikely to succeed.

An error will not be raised if f has no declared return type,
since the return type would be ,
and Future<S> is assignable to  for all S.
However, an asynchronous non-generator function
that declares a return type which is not ‚Äúvoidy‚Äù
must return an expression explicitly.

This helps catch situations where users forget
to return an object in a return statement of an asynchronous function.

Generator functions
It is a compile-time error if a return statement of
the form e; appears in a generator function.


In the case of a generator function, the object returned by the function is
the iterable or stream associated with it,
and individual elements are added to that iterable using yield statements,
and so returning an object makes no sense.

Generative constructors
It is a compile-time error if a return statement of
the form e; appears in a generative constructor
(<ref>).


It is quite easy to forget to add the  modifier for a constructor,
accidentally converting a factory into a generative constructor.
The static checker may detect a type mismatch
in some, but not all, of these cases.
The rule above helps catch such errors,
which can otherwise be very hard to recognize.
There is no real downside to it,
as returning an object from a generative constructor is meaningless.

Executing a return statement e; proceeds as follows:


First the expressioneis evaluated, producing an objecto.
LetSbe the run-time type ofoand
letTbe the actual return type off(<ref>).
If the body offis marked  (<ref>)
andSis a subtype of Future<T>
then letrbe the result of evaluating await v
wherevis a fresh variable bound too.
Otherwise letrbeo.
Then the return statement returns the objectr(<ref>).




























LetUbe the run-time type ofr.

  * 
  If the body of f is marked  (<ref>)
  
  it is a dynamic type error if Future<U> is not a subtype of T.

  * 
  Otherwise, it is a dynamic type error if U is not a subtype of T.

Executing a return statement with no expression,
;
returns without an object
(<ref>).




 ¬ß.¬ß Labels
labels
A label is an identifier followed by a colon.
A labeled statement is a statement prefixed by a labelL.
A labeled case clause is a case clause within a switch statement
(<ref>)
prefixed by a labelL.


The sole role of labels is to provide targets for
the break (<ref>) and continue (<ref>) statements.

<label> ::= <identifier> `:'

Execution a labeled statements,label: s_l, consists of executings_l.
If execution ofs_lbreaks to the labellabel(<ref>),
then execution ofscompletes normally,
otherwise execution ofscompletes in the same ways as the execution ofs_l.


The namespace of labels is distinct from the one used for
types, functions and variables.


The scope of a label that labels a statementsiss.
The scope of a label that labels a case clause of a switch statementsiss.


Labels should be avoided by programmers at all costs.
The motivation for including labels in the language
is primarily making Dart a better target for code generation.


 ¬ß.¬ß Break
break
The break statement consists of
the reserved word  and an optional label (<ref>).


<breakStatement> ::=  <identifier>? `;'

Lets_bbe a  statement.
Ifs_bis of the form L;,
then it is a compile-time error ifs_bis not enclosed in a labeled statement
with the labelLwithin the innermost function in whichs_boccurs.
Ifs_bis of the form ;,
then it is a compile-time error ifs_bis not enclosed in an
 (<ref>),
 (<ref>),  (<ref>),  (<ref>)
or  (<ref>) statement within
the innermost function in whichs_boccurs.


Execution of a  statement L; breaks to the labelL(<ref>).
Execution of a  statement ; breaks without a label
(<ref>).




 ¬ß.¬ß Continue
continue
The continue statement consists of the reserved word 
and an optional label (<ref>).


<continueStatement> ::=  <identifier>? `;'

Lets_cbe a  statement.
Ifs_cis of the form L;,
then it is a compile-time error ifs_cis not enclosed in either an
 (<ref>),
 (<ref>),  (<ref>), or  (<ref>)
statement labeled withL, or in a  statement with a case clause
labeled withL, within the innermost function in whichs_coccurs.
Ifs_cis of the form ;
then it is a compile-time error ifs_cis not enclosed in an
 (<ref>)
 (<ref>),  (<ref>), or  (<ref>) statement
within the innermost function in whichs_coccurs.


Execution of a  statement L; continues
to the labelL(<ref>).
Execution of a  statement ; continues
without a label (<ref>).




 ¬ß.¬ß Yield
yield
The yield statement adds an object to
the result of a generator function
(<ref>).


<yieldStatement> ::=  <expression> `;'

Letsbe a yield statement of the form   e;.
Letfbe the immediately enclosing function ofs.
It is a compile-time error if there is no such function,
or it is not a generator.
It is a compile-time error if the static type ofemay not be assigned to the element type off(<ref>).


Execution of a statementsof the form   e;
proceeds as follows:


First, the expressioneis evaluated to an objecto.
If the enclosing functionmis marked *
(<ref>)
and the streamuassociated withmhas been paused,
then the nearest enclosing asynchronous for loop
(<ref>),
if any, is paused and execution ofmis suspended
untiluis resumed or canceled.


Next,ois added to the iterable or stream associated
with the immediately enclosing function.


Note that a dynamic error occurs if the dynamic type of o
is not a subtype of the element type of said iterable or stream.

If the enclosing functionmis marked *
and the streamuassociated withmhas been canceled,
then the  statement returns without an object
(<ref>),
otherwise it completes normally.


The stream associated with an asynchronous generator could be canceled
by any code with a reference to that stream at any point
where the generator was passivated.
Such a cancellation constitutes an irretrievable error for the generator.
At this point, the only plausible action for the generator is
to clean up after itself via its  clauses.

Otherwise, if the enclosing functionmis marked *
(<ref>)
then the enclosing function may suspend,
in which case the nearest enclosing asynchronous for loop
(<ref>),
if any, is paused first.


If a  occurred inside an infinite loop
and the enclosing function never suspended,
there might not be an opportunity for consumers of the enclosing stream
to run and access the data in the stream.
The stream might then accumulate an unbounded number of elements.
Such a situation is untenable.
Therefore, we allow the enclosing function to be suspended
when a new object is added to its associated stream.
However, it is not essential (and in fact, can be quite costly)
to suspend the function on every .
The implementation is free to decide
how often to suspend the enclosing function.
The only requirement is that consumers are not blocked indefinitely.

If the enclosing functionmis marked * (<ref>) then:

  * 
  Execution of the function m immediately enclosing s is suspended
  until the nullary method moveNext() is invoked upon
  the iterator used to initiate the current invocation of m.

  * 
  The current call to moveNext() returns .


 ¬ß.¬ß Yield-Each
yieldEach
The yield-each statement adds a series of objects to
the result of a generator function
(<ref>).


<yieldEachStatement> ::=  `*' <expression> `;'

Letsbe a yield-each statement of the form `*  e;'.
Letfbe the immediately enclosing function ofs.
It is a compile-time error if there is no such function,
or it is not a generator.


LetT_fbe the element type off(<ref>),
and letTbe the static type ofe.
Iffis a synchronous generator,
it is a compile-time error ifTmay not be assigned to
Iterable<T_f>.
Otherwisefis an asynchronous generator,
and it is a compile-time error ifTmay not be assigned to
Stream<T_f>.


Execution of a statementsof the form `*  e;'
proceeds as follows:


First, the expressioneis evaluated to an objecto.


If the immediately enclosing functionmis marked *
(<ref>),
then:

  * 
  It is a dynamic type error
  if the class of o is not a subtype of Iterable<T_f>.
  Otherwise

  * 
  The method iterator is invoked upon o returning an object i.

  *  The moveNext method of i is invoked on it
  with no arguments.
  If moveNext returns  execution of s is complete.
  Otherwise

  * 
  The getter current is invoked on i.
  If the invocation throws
  (<ref>),
  execution of s throws the same exception object and stack trace
  (<ref>).
  Otherwise, the result x of the getter invocation is added to
  the iterable associated with m.
  
    Note that a dynamic error occurs if the dynamic type of x is
    not a subtype of the element type of said iterable.
  
  Execution of the function m immediately enclosing s is suspended
  until the nullary method moveNext() is invoked
  upon the iterator used to initiate the current invocation of m,
  at which point execution of s continues at <ref>.

  * 
The current call to moveNext() returns .

Ifmis marked * (<ref>), then:

  * 
  It is a dynamic type error if the class of o
  is not a subtype of Stream<T_f>.
  Otherwise

  * 
  The nearest enclosing asynchronous for loop (<ref>),
  if any, is paused.

  * 
  The o stream is listened to, creating a subscription s,
  and for each event x, or error e with stack trace t, of s:
  
  * 
    If the stream u associated with m has been paused,
    then execution of m is suspended until u is resumed or canceled.
  
  * 
    If the stream u associated with m has been canceled,
    then s is canceled by evaluating  v.cancel()
    where v is a fresh variable referencing the stream subscription s.
    Then, if the cancel completed normally,
    the stream execution of s returns without an object
    (<ref>).
  
  * 
    Otherwise, x, or e with t, are added to
    the stream associated with m in the order they appear in o.
    
      Note that a dynamic error occurs if x is added
      and the dynamic type of x is not a subtype of
      the element type of said stream.
    
    The function m may suspend.
  
  * 
  If the stream o is done, execution of s completes normally.


 ¬ß.¬ß Assert
assert
An assert statement is used to disrupt normal execution
if a given boolean condition does not hold.


<assertStatement> ::= <assertion> `;'

<assertion> ::=  `(' <expression> (`,' <expression> )? `,'? `)'

The grammar allows a trailing comma before the closing parenthesis,
similarly to an argument list.
That comma, if present, has no effect.
An assertion with a trailing comma is equivalent to one with that comma removed.


An assertion of the form (e) is equivalent to
an assertion of the form (e, ).


Execution of an assert statement executes the assertion as described below
and completes in the same way as the assertion.


When assertions are not enabled,
execution of an assertion immediately completes normally
(<ref>).
That is, no subexpressions of the assertion are evaluated.
When assertions are enabled,
execution of an assertion (c, e) proceeds as follows:


The expressioncis evaluated to an objectr.

It is a dynamic type error ifris not of type bool.

Hence it is a compile-time error if that situation arises
during evaluation of an assertion in a  constructor invocation.

Ifris  then execution of the assert statement completes normally
(<ref>).
Otherwise,eis evaluated to an objectmand then the execution of the assert statement throws
(<ref>)
an AssertionError containingmand with
a stack trace corresponding to the current execution state at the assertion.


It is a compile-time error if the type ofcmay not be assigned to bool.


Why is this a statement, not a built in function call?
Because it is handled magically
so it has no effect and no overhead when assertions are disabled.
Also, in the absence of final methods,
one could not prevent it being overridden
(though there is no real harm in that).
It cannot be viewed as a function call that is being optimized away
because the arguments might have side effects.


¬ß LIBRARIES AND SCRIPTS
librariesAndScripts
A Dart program consists of one or more libraries,
and may be built out of one or more compilation units.
A compilation unit may be a library or a part (<ref>).


A library consists of (a possibly empty) set of imports, a set of exports,
and a set of top-level declarations.
A top-level declaration is either a class (<ref>),
a type alias declaration (<ref>),
a function (<ref>)
or a variable declaration (<ref>).
The members of a libraryLare those top level declarations given withinL.


<topLevelDeclaration> ::= <classDeclaration>
   <mixinDeclaration>
   <extensionDeclaration>
   <enumType>
   <typeAlias>
   <functionSignature> `;'
   <getterSignature> `;'
   <setterSignature> `;'
   <functionSignature> <functionBody>
   <getterSignature> <functionBody>
   <setterSignature> <functionBody>
   ( | ) <type>? <staticFinalDeclarationList> `;'
   <type>? <initializedIdentifierList> `;'
  ? <varOrType> <initializedIdentifierList> `;'

<libraryDeclaration> ::= 
  <scriptTag>? <libraryName>? <importOrExport>* <partDirective>*
   (<metadata> <topLevelDeclaration>)* <EOF>

<scriptTag> ::= `#!' ((`
r' | `
n'))* <LINE_BREAK>

<libraryName> ::= <metadata>  <dottedIdentifierList> `;'

<importOrExport> ::= <libraryImport>
   <libraryExport>

<dottedIdentifierList> ::= <identifier> (`.' <identifier>)*

A library contains a string which is derived from libraryDeclaration.


We could say that libraryDeclaration is a
start symbol
of the grammar,
because the syntactic derivation of any library starts from there.
Unlike a traditional context free grammar,
the Dart grammar does not have exactly one start symbol.
In particular, partDeclaration
(<ref>)
is used in the same manner to derive the contents of a part.
There could be more, e.g.,
a hypothetical Dart REPL (read-eval-print loop) could use
expression or statement as a start symbol.
So there is no grammar for Dart programs as such,
only for some building blocks that are used to construct Dart programs.

Libraries may be explicitly named or implicitly named.
An explicitly named library begins with the word 
(possibly prefaced with any applicable metadata annotations),
followed by a qualified identifier that gives the name of the library.


Technically, each dot and identifier is a separate token
and so spaces between them are acceptable.
However, the actual library name is the concatenation of
the simple identifiers and dots and contains no spaces.

An implicitly named library has the empty string as its name.


The name of a library is used to tie it to
separately compiled parts of the library (called parts) and
can be used for printing and, more generally, reflection.
The name may be relevant for further language evolution.

Libraries intended for widespread use should avoid name collisions.
Dart's pub package management system provides a mechanism for doing so.
Each pub package is guaranteed a unique name,
effectively enforcing a global namespace.

A library may optionally begin with a script tag.
Script tags are intended for use with scripts (<ref>).
A script tag can be used to identify the interpreter of the script to
whatever computing environment the script is embedded in.
The script tag must appear before any whitespace or comments.
A script tag begins with #! and ends at the end of the line.
Any characters that follow #! in the script tag are ignored by
the Dart implementation.


Libraries are units of privacy.
A private declaration declared within a libraryLcan only be accessed by code withinL.


Since top level privates are not imported,
using the top level privates of another library is never possible.

The public namespace of libraryLis the namespace that maps
the name of each public top-level member declarationmofLtom.
The local namespace of libraryLis the namespace that maps
the names introduced by each top-level declaration ofLto the corresponding declaration.
The library scope of libraryLis the outermost scope inL,
and its namespace is the library namespace ofL(<ref>).



It is a compile-time error if the local namespace of libraryLhas two declarations with the same basename,
except when they are a getter and a setter.


Two distinct names n_1 and n_2 can only have the same basename
when they are of the form ùïÄ and ùïÄ=,
so this kind of conflict always involves a setter.
But the other declaration could be a function, a class, etc.


 ¬ß.¬ß Imports
imports
An import specifies a library whose exported namespace
(or a subset of its mappings) is made available in the current library.


<libraryImport> ::= <metadata> <importSpecification>

<importSpecification> ::=  <configurableUri>
  (?  <typeIdentifier>)?
  <combinator>* `;'

The interpretation of configurable URIs is described elsewhere
(<ref>).
An import specifies a URIswhere the declaration of an imported library is to be found.
It is a compile-time error if the specified URI of an import
does not refer to a library declaration.


The current library is the library currently being compiled.
The import modifies the namespace of the current library
in a manner that is determined by the imported library and
by the optional elements of the import.


Imports may be deferred or immediate.
A
deferred importimport!deferred
is distinguished by the occurrence of
the built-in identifier  after the URI.
An
immediate importimport!immediate
is an import that is not deferred.


An immediate import directiveImay optionally include
a prefix clause of the form `  ùïÄ' used to prefix
names imported byI.
In this case we say that ùïÄ is an import prefix,
or simply a prefix.


Note that the grammar enforces that a deferred import
includes a prefix clause,
so we can refer to the prefix clause of a deferred import.

It is a compile-time error if the prefix used in a deferred import
is also used as the prefix of another import clause.
It is a compile-time error if ùïÄ is an import prefix,
and the current library declares a top-level member with basename ùïÄ.


An import directiveImay optionally include namespace combinator clauses
used to restrict the set of names imported byI.
Their syntax, usage, and effect on namespaces is described elsewhere
(<ref>, <ref>,
<ref>).


The dart core library dart:core
is implicitly imported into every dart library other than itself
via an import clause of the form
 'dart:core';
unless the importing library explicitly imports dart:core.
Any import of dart:core,
even if restricted via , , or ,
preempts the automatic import.


It would be nice if there was nothing special about dart:core.
However, its use is pervasive,
which leads to the decision to import it automatically.
On the other hand, some library L may wish to define entities
with names used by dart:core
(which it can easily do, as the names declared by a library take precedence).
Other libraries may wish to use L,
and may want to use members of L that conflict with the core library
without having to use a prefix and without encountering errors.
The above rule makes this possible,
essentially canceling dart:core's special treatment
by means of yet another special rule.


  ¬ß.¬ß.¬ß The Imported Namespace
theImportedNamespace
In the following, we specify the imported namespace of a libraryL,
import,
and use that to define the namespace that defines the library scope ofL.


We need to introduce system libraries because they have special rules.
A system library is a library that is part of the Dart implementation.
Any other library is a non-system library.


A system library can generally be recognized by having
a URI that starts with `dart:'.

The special rules for system libraries exist for the following reason.
Normal conflicts are resolved at deployment time,
but the functionality of a system library is
injected into an application at run time,
and may vary over time as the platform is upgraded.
Thus, conflicts with a system library can arise
outside the developer's control.
To avoid breaking deployed applications in this way,
conflicts with the system libraries are treated specially.

LetIbe an import directive and letLbe the library imported byI.
The
namespace provided by
  namespace!provided by an import directive
by the import directiveIis the namespace obtained from applying
the namespace combinators ofIto the exported namespace ofL(<ref>).


Note that the namespace provided by an import directive I is not
the same as the namespace imported from I.
The latter includes conflict resolution,
and is defined later in this section.

Let local be the local namespace ofL(<ref>).
Let I1m be the import directives ofL,
and let L1m be libraries
such thatI_irefers toL_ifor alli ‚àà 1 .. m.

It is not an error to have multiple imports of the same library.

Leti ‚àà 1 .. m.


 Step one.
In the first step we compute the namespace obtained from each imported library,
respectively by each group of libraries imported with the same prefix,
one,i.


Step one for imports without a prefix
WhenI_ihas no prefix, one,i is obtained
from the namespace provided by the import directiveI_iby eliminating every binding for a name whose basename is
the same as the basename of a top-level declaration inL,
or whose basename is the prefix of an import directive inL.


This step ensures that  and  directives are taken into account,
and that an import prefix as well as a local declaration
will shadow an imported name.

Step one for prefixed imports
In this step we resolve name conflicts
among names imported with the same prefix.
WhenI_ihas prefixp_i,
let I'1k be the sublist of I1m that have prefixp_i,
and let L'1k be the corresponding libraries
(which is a sublist of L1m).
Let exported,j,j ‚àà 1 .. k,
be the namespace provided by the import directiveI'_j(which takes  and  into account).


WhenI_iis a non-deferred import:
Let prefix,i be the namespace obtained from applying
conflict merging to
NSexported,1exported,k
(<ref>).


WhenI_iis a deferred import:
In this casekis 1
(otherwise a compile-time error would occur),
and prefix,i is the namespace obtained by
adding a binding of the name loadLibrary
to an implicitly induced declaration of a function with signature
Future<> loadLibrary()
to exported,1.


Then one,i is a namespace that has
a single binding that mapsp_ito prefix,i.


In this situation we say that one,i is a
prefix namespace,
because it maps a library prefix to a namespace.


A prefix namespace is not a Dart object,
it is merely a device which is used to manage
expressions of the form qualifiedName and what they refer to
during static analysis.
Consequently, any attempt to use a prefix namespace as an object
is a compile-time error, e.g.,
it cannot be the result of an expression evaluation.

Note that if l and q are such that
I_l and I_q both have the same prefix p
then
one,l = one,q =
one,l‚à™one,q.

 Step two.
In the second step we resolve top level conflicts
among the namespaces obtained in the first step.


The imported namespace ofL, import,
is then the result of applying conflict merging to the namespaces
NSone,1one,m.


Let Ebe a set of extension declarations
(<ref>)
with the following members:
An extension declarationEis a member of Eif there is ani ‚àà 1 .. msuch thatEis in the namespace provided by the import directiveI_i(
note that this takes  and  into account,
and it includes extensions imported both without and with a prefix
),
andEis not declared in the current library
(which could be the case if it imports itself).
Let extensions be a namespace that
for each extensionEin Emaps a fresh name toE.


extensions provides a fresh name
allowing implicit access to each extension exported by an imported library
and not removed by  or ,
even the ones that cannot be accessed using their declared name,
because of a name clash.

The library namespace ofLis thenlocal‚à™import‚à™extensions.


Leti ‚àà 1 .. m.
IfL_iis imported without a prefix, the
namespace imported fromlibrary!namespace imported fromL_iis the conflict narrowed namespace
(<ref>)
of one,i.

OtherwiseL_iis imported with a prefixp,
in which case the namespace imported fromL_iis the conflict narrowed namespace
of exported,i.


So the namespace imported by L_i contains the bindings exported by L_i,
except the ones removed by namespace combinators,
and except the ones removed by conflict merging.

LetLbe a library with imported namespace .
We say that a name is
imported by Limported!name
if the name is a key of .
We say that a declaration is
imported by Limported!declaration
if the declaration is a value of .
We say that a name is
imported by L with prefix pimported!name, with prefix
if the name is a key of p.
We say that a declaration is
imported by L with prefix p
  imported!declaration, with prefix
if the declaration is a value of p.




  ¬ß.¬ß.¬ß Semantics of Imports
semanticsOfImports
LetI_ibe an import directive that refers to a URI via the strings_i.
The semantics ofI_iis specified as follows:


Semantics of deferred imports
IfI_iis a deferred import with prefixp, a binding ofpto a
deferred prefix run-time namespacedeferred is
present in the library namespace of the current libraryL.
Let import,i be
the namespace imported from the library specified byI_i,
as defined previously
(<ref>).
deferred then has the following bindings:


  *  The name loadLibrary is bound to
  a function with signature Future<> loadLibrary().
  This function returns a future f.
  When called, the function causes
  an immediate import I' to be executed at some future time,
  where I' is derived from I_i by eliding the word 
  and adding a loadLibrary combinator clause.
  The execution of the immediate import may fail
  for implementation specific reasons.
  
    For instance, I' imports a different library than the one
    that the specified URI referred to at compile-time;
    or an OS level file read error occurs; etc.
  
  We say that the invocation of loadLibrarysucceedsloadLibrary!succeeds if f completes with a value,
  and that the invocation
  failsloadLibrary!fails if f completes with an error.

  * 
  For every top level function f named ùïÄ in
  import,i,
  a corresponding function named ùïÄ with the same signature as f.
  
  Calling the function results in a dynamic error that occurs before
  any actual arguments are evaluated.
  Closurizing the function
  (<ref>)
  also results in a dynamic error.

  * 
  For every top level getter g named ùïÄ in
  import,i,
  a corresponding getter named ùïÄ with the same signature as g.
  
  Calling the getter results in a dynamic error.

  * 
  For every top level setter s named ùïÄ= in
  import,i,
  a corresponding setter named ùïÄ= with the same signature as s.
  
  Calling the setter results in a dynamic error that occurs before
  the actual argument is evaluated.

  * 
  For every class, mixin, enum, and type alias declaration named ùïÄ in
  import,i,
  a corresponding getter named ùïÄ with return type Type.
  
  Calling the getter results in a dynamic error.

The purpose of having members of the imported library in
deferred
is to ensure that usages of members that have not yet been loaded
can be resolved normally and has a well-defined behavior,
which will raise errors.

When an invocation of p.loadLibrary() succeeds,
the namepis mapped to a non-deferred prefix run-time namespace
loaded,
with bindings as described below for immediate imports.
In addition, loaded
maps loadLibrary to a function with the same signature as before,
and so it is possible to invoke p.loadLibrary() again,
which will always succeed.
If a call fails, the library has not been loaded,
and one has the option to invoke p.loadLibrary() again.
Whether a repeated call to p.loadLibrary() succeeds will vary,
as described below.


Note that it is a compile-time error for a deferred prefix
to be used in more than one import,
which means that the update of the binding of p
does not interfere with other imports.

The effect of a repeated invocation of p.loadLibrary() is as follows:

  * 
  If another invocation of p.loadLibrary() has already succeeded,
  the repeated invocation also succeeds.
  Otherwise,

  * 
  If another invocation of p.loadLibrary() has failed:
  
  * 
    If the failure is due to a compilation error,
    the repeated invocation fails for the same reason.
  
  * 
    If the failure is due to other causes,
    the repeated invocation behaves as if no previous call had been made.
  
In other words, a successful loadLibrary() guarantees that
the import can be successfully accessed through the import prefix.
If an invocation of loadLibrary() is initiated after
another invocation has completed successfully,
it is guaranteed to also complete successfully (success is idempotent).
We do not specify which object the returned future resolves to.

Semantics of immediate imports
WhenI_iis an immediate import with a library URI,u_i,
represented by the strings_i:
LetL_ibe the library obtained from the source code denoted bys_i.
We then say that the URIu_idenotes the libraryL_i.
All imports and exports of the same URI in a Dart program denotes
the same library,
and imports or exports of different URIs denote distinct libraries.


Let import, i be the namespace imported fromL_i.
The run-time namespace i will then have the following bindings:


  * 
  For every top level function, getter, or setter m named n in
  import, i,
  a binding from n to said function, getter, or setter.

  * 
  For every name ùïÄ in import, i
  that is bound to a class, mixin, enum, or type alias declaration
  introducing a type T,
  a binding from ùïÄ to the compiled representation of T.

IfI_ihas prefixp,
the run-time namespace of the current library
mapspto a non-deferred prefix run-time namespace p
containing the mappings of i.


p may have additional mappings
because there can be several imports with the same prefix
as long as they are all immediate.

Otherwise, whenI_idoes not have a prefix,
the run-time library namespace of the current library
contains each mapping in i.


 ¬ß.¬ß Exports
exports
A libraryLexports a namespace (<ref>), meaning that
the declarations in the namespace are made available to other libraries
if they choose to importL(<ref>).
The namespace thatLexports is known as its
exported namespacelibrary!exported namespace of.


A library always exports all names and all declarations in its public namespace.
In addition, a library may choose to re-export additional libraries
via export directives, often referred to simply as exports:


<libraryExport> ::= <metadata>  <configurableUri> <combinator>* `;'

The interpretation of configurable URIs is described elsewhere
(<ref>).
An export specifies a URIswhere the declaration of an exported library is to be found.
It is a compile-time error if the specified URI
does not refer to a library declaration.


The
exported namespace
of a library is determined as follows, in two steps.
LetLbe a library,
let E1m be the export directives ofL,
and let L1m be libraries
such thatE_irefers toL_ifor alli ‚àà 1 .. m.
Let public be the public namespace ofL(<ref>).


Note that private names and import prefixes are not present
in public.

In the first step we compute the namespace provided by each exported library:
For eachi ‚àà 1 .. m,
exported,i is
the namespace obtained from applying
the namespace combinators ofE_ito
the exported namespace ofL_i(<ref>),
and removing each binding of a namensuch that
public is defined atn',
andnandn'have the same basename.
Because local declarations will shadow re-exported ones.
The
namespace re-exported fromlibrary!namespace re-exported fromL_iis exported,i.


In the second step we compute the exported namespace ofL.
Let merged be the result of applying
conflict merging
(<ref>)
to NSexported,1exported,m.
A compile-time error occurs if any name in
merged
is conflicted
(<ref>).


This rule is more strict than the corresponding rule for imports:
When two imported declarations have a name clash, it is only an error to
use the conflicted name, it is not an error that the name clash exists.
With exported names, it is an error that the name clash exists.
The reason for this difference is that
the conflict could silently break importers of the current library L,
if we were to use the same approach for exports as for imports:
If a library L' imports L
and uses a name n which is re-exported by L from L_n
then the addition of a declaration named n to some other re-exported library
will make the use of n in L' an error,
and the maintainers of L' may not be in a position to change L.

The
exported namespacelibrary!exported namespace of
ofLispublic‚à™merged.


We say that a name is exported by a library
if the name is in the library's exported namespace.
We say that a declaration is exported by a library
if the declaration is in the library's exported namespace.


For a giveni,
we say thatLre-exports libraryL_i, and also thatLre-exports namespaceexported,i.
When no confusion can arise, we may simply state
thatLre-exportsL_i, or
thatLre-exportsexported,i.




 ¬ß.¬ß Namespace Combinators
namespaceCombinators
Imports (<ref>) and exports (<ref>) rely on
namespace combinators
in order to adjust namespaces
(<ref>)
and manage name clashes.
The supported namespace combinators are  and .


<combinator> ::=  <identifierList> |  <identifierList>

<identifierList> ::= <identifier> (`,' <identifier>)*

We define several operations that compute namespaces.
The
union of two namespacesnamespace!union,
a‚à™b
  ‚à™@a‚à™b,
is defined when every key where both are defined is mapped to the same value.
This union is the namespace that maps
each keynof a
to the corresponding value an,
and each keynof b
to bn.


Note that this is a namespace because the union is only defined
when the mapping of any given key is unambiguous.

The function
la
  hide(l,NSa)@l
takes a list of identifiersland a namespace a,
and produces a namespace b that is
identical to a except that for each identifier ùïÄ inl,
b is undefined at ùïÄ and at ùïÄ=.


The function
la
  show(l,NSa)@l
takes a list of identifiersland a namespace a,
and produces a namespace b that
maps each identifier ùïÄ inlwhere a is defined
to an.
Furthermore, for each identifier ùïÄ inlwhere a is defined at ùïÄ=,
b maps ùïÄ= to aùïÄ=.
Finally, b is undefined at all other names.


Let C1n be a sequence of combinator clauses.
They would come from an import or export directive.
The result of
applying the combinator clauses
  combinator clauses!application to namespace
to a given namespace start
is a namespace end,
which is computed as follows.


Let 0 be start.
For each combinator clauseC_j,j ‚àà 1 .. n:
IfC_jis of the form ùïÄ_1, ‚Ä¶, ùïÄ_k then letj = [ùïÄ1k]j-1.
IfC_iis of the form ùïÄ_1, ‚Ä¶, ùïÄ_k then letj = [id1k]j-1.
Then end is n.


end will always agree with
start wherever both are defined,
and the set of names where end is defined
is always a subset of that of start.
In that sense, this is a narrowing procedure.

Note that it is possible to use  or  on an identifier
which is not in the given namespace.

Allowing this prevents situations where, e.g.,
removing a declaration from a library L would cause
breakage in a library that imports L.


 ¬ß.¬ß Conflict Merging of Namespaces
conflictMergingOfNamespaces
In this section we define an operation on namespaces
which eliminates certain bindings of names in case of name clashes,
and keeps track of such name clashes using a special value,
.


When a namenis mapped to  by a namespace,
we say thatnis
conflictedconflicted name.
A lookup for a conflicted name will succeed according to
the normal rules for namespaces and lexical scoping,
but it is a compile-time error at the location where the name is used
that this name is conflicted.


Let NS1m be a list of namespaces
(the list may or may not contain duplicates).
The
conflict mergingnamespace!conflict merging
of NS1m is thenconflict‚à™narrowed,1‚à™ ‚Ä¶ narrowed,m,
where the namespaces conflict and
narrowed,i,i ‚àà 1 .. m,
are specified as follows:


conflict is empty except for the
bindings mentioned below.
For eachi ‚àà 1 .. m,
narrowed,i is identical to i,
except that the former is undefined at each namenwhere
the latter is defined,
and one of the following conditions holds:


  *  There exists a j ‚àà 1 .. m and name n' such that
  j is defined at n',
  n and n' have the same basename,
  in is a declaration in a system library,
  and jn' is a declaration in a non-system library.
  
    So a declaration from a non-system library shadows
    declarations from system libraries.
  
  *  Otherwise, there exists a j ‚àà 1 .. m and name n' such that
  j is defined at n',
  n and n' have the same basename,
  in and jn' are not the same declaration
  and not the same namespace
  and not a getter and a setter declared in the same library,
  and either none or both of
  in and jn'
  are declarations in a system library.
  
  
    So with two distinct declarations with the same basename,
    both are eliminated,
    except when it is a getter and a setter from the same library.
    Note that in and jn'
    must both be declarations or must both be namespaces,
    because conflict merging is applied to namespaces where
    imported declarations that conflict with an import prefix
    have already been eliminated.
    When they are both namespaces there is no conflict,
    because it is then the same namespace.
  

  In this situation n is mapped to 
  by conflict.
  
    We can swap all names and use the rule again,
    so n' is also conflicted.
  
In short, conflict merging takes a list of namespaces and produces
a namespace that is the union of several disjoint namespaces
(because all name clashes have been eliminated):
A conflict namespace that records all unresolved name clashes,
and a list of namespaces where clashing names have been removed.
Some name clashes have been resolved by preferring
declarations from non-system libraries
over declarations from system libraries.

It is useful to be able to refer to the result of narrowing.
Let NS1m be a list of namespaces,i ‚àà 1 .. m,
and consider the conflict merging as specified above.
The
conflict narrowed namespacenamespace!conflict narrowed
of i is then narrowed,i.




 ¬ß.¬ß Parts
parts
A library may be divided into parts,
each of which can be stored in a separate location.
A library identifies its parts by listing them via  directives.


A part directive specifies a URI where
a Dart compilation unit that should be incorporated into the current library
may be found.


<partDirective> ::= <metadata>  <uri> `;'

<partHeader> ::= <metadata>  (<dottedIdentifierList> | <uri>) `;'

<partDeclaration> ::=
  <partHeader> (<metadata> <topLevelDeclaration>)* <EOF>

A part contains a string which is derived from partDeclaration.


So we could say that partDeclaration is a start symbol of the grammar,
as discussed in Sect.¬†<ref>.

A part header begins with  followed by
the name of the library the part belongs to,
or a uri denoting said library.
A part declaration consists of a part header followed by
a sequence of top-level declarations.


Compiling a part directive of the form s;
causes the Dart system to attempt to compile the contents of
the URI that is the value ofs.
The top-level declarations at that URI are then compiled by the Dart compiler
in the scope of the current library.
It is a compile-time error if the contents of the URI are not
a valid part declaration.
It is a compile-time error if the referenced part declarationpnames
a library other than the current library as the library to whichpbelongs.


It is a compile-time error if a library contains
two part directives with the same URI.


We say that a libraryL_1is reachable from a libraryLif
any of the following is true (<ref>, <ref>):

  * L and L_1 is the same library.

  * L imports or exports a library L_2, and L_1 is reachable from L_2.

LetLbe a library, letube a URI,
and letL_1andL_2be distinct libraries which are reachable fromL.
It is a compile-time error ifL_1andL_2both contain
a part directive with URIu.


In particular, it is an error to use the same part twice
in the same program
(<ref>).
Note that a relative URI is interpreted as relative to the location of the
enclosing library (<ref>), which means that L_1 and L_2 may both
have a part identified by 'myPart.dart', but they are not the same
URI unless L_1 and L_2 have the same location.


 ¬ß.¬ß Scripts
scripts
A script is a library whose exported namespace (<ref>) includes
a top-level function declaration named main
that has either zero, one or two required arguments.

A scriptSis executed as follows:


First,Sis compiled as a library as specified above.
Then, the top-level function defined by main
in the exported namespace ofSis invoked (<ref>)
as follows:
If main can be called with with two positional arguments,
it is invoked with the following two actual arguments:

  *  An object whose run-time type implements List<String>.

  *  An object specified when the current isolate i was created,
for example through the invocation of Isolate.spawnUri that spawned i,
or the null object (<ref>) if no such object was supplied.

If main cannot be called with two positional arguments,
but it can be called with one positional argument,
it is invoked with an object whose run-time type implements List<String>
as the only argument.
If main cannot be called with one or two positional arguments,
it is invoked with no arguments.


Note that if main requires more than two positional arguments,
the library is not considered a script.

A Dart program will typically be executed by executing a script.

It is a compile-time error if a library's export scope contains a declaration
named main, and the library is not a script.
This restriction ensures that all top-level main declarations
introduce a script main-function, so there cannot be a top-level getter or field
named main, nor can it be a function that requires more than two
arguments. The restriction allows tools to fail early on invalid main
methods, without needing to know whether a library will be used as the entry
point of a Dart program. It is possible that this restriction will be removed
in the future.

 ¬ß.¬ß URIs
uris
URIs are specified by means of string literals:


<uri> ::= <stringLiteral>

<configurableUri> ::= <uri> <configurationUri>*

<configurationUri> ::=  `(' <uriTest> `)' <uri>

<uriTest> ::= <dottedIdentifierList> (`==' <stringLiteral>)?

It is a compile-time error if a string literal that describes a URI
or a string literal that is used in a uriTest
contains a string interpolation.


A configurable URIcof the form
uriconfigurationUri_1‚Ä¶configurationUri_nspecifies a URIspecify a URI as follows:

  * 
  Let u be uri.

  * 
  For each of the following configuration URIs of the form
   (test_i) uri_i,
  in source order, do the following.
  
  * 
    If test_i is ids
    with no == clause, it is
    equivalent to ids == "true".
  
  * 
    If test_i is ids == string,
    then create a string, key, from ids
    by concatenating the identfiers and dots,
    omitting any spaces between them that may occur in the source.
  
  * 
    Look up key in the available
    compilation environment.
    
      The compilation environment is provided by the platform.
      It maps some string keys to string values,
      and can be accessed programmatically using the
      const String.fromEnvironment constructor.
      Tools may choose to only make some parts of the compilation environment
      available for choosing configuration URIs.
    
  * 
    If the environment contains an entry for key and the
    associated value is equal, as a constant string value, to the value of
    the string literal string,
    then let u be uri_i and stop iterating the configuration URIs.
  
  * 
    Otherwise proceed to the next configuration URI.
  
  * 
  The URI specified by c is u.

This specification does not discuss the interpretation of URIs,
with the following exceptions.


The interpretation of URIs is mostly left to
the surrounding computing environment.
For example, if Dart is running in a web browser,
that browser will likely interpret some URIs.
While it might seem attractive to specify, say, that
URIs are interpreted with respect to a standard such as IETF RFC 3986,
in practice this will usually depend on the browser and cannot be relied upon.

A URI of the form dart:s is interpreted as
a reference to a system library (<ref>)s.


A URI of the form package:s is interpreted in
an implementation specific manner.


The intent is that, during development, Dart programmers can rely on
a package manager to find elements of their program.

Otherwise, any relative URI is interpreted as relative to
the location of the current library.
All further interpretation of URIs is implementation dependent.


This means it is dependent on the runtime.


¬ß TYPES
types
Dart supports static typing based on interface types.


The type system is sound in the sense that
if a variable of type T refers to an object of type S at run time,
then S is a subtype of T.
In other words, the contents of the heap satisfies the expectations
expressed by static typing.

However, type parameters are covariant
(e.g., List<int>List<num>)
and this implies that certain operations are subject to dynamic type checks
(such as myList.add(1.5), which will throw at run time
if myList has declared type List<num>,
but it is actually a List<int>).
Hence, a program can be free of compile-time errors,
and it may still incur a type error at run time.

This choice was made deliberately during the early days of Dart
(and it is undoubtedly controversial).
It represents a trade-off where
the potential for run-time type errors is the cost,
and the benefit is simpler programs.
In recent years, Dart has evolved to have more and more static type safety,
e.g., null safety, and this trend is likely to continue.


 ¬ß.¬ß Static Types
staticTypes
Type annotations can occur in variable declarations (<ref>),
including formal parameters (<ref>),
in the return types of functions (<ref>),
and in the bounds of type variables (<ref>).
Type annotations are used during static checking and when running programs.
Types are specified using the following grammar rules.


A typeIdentifier is an identifier which can be the name of a type,
that is,
it denotes an IDENTIFIER which is not a BUILT_IN_IDENTIFIER
(<ref>).

Non-terminals with names of the form ‚Ä¶NotFunction
derive terms which are types that are not function types.
Note that it does derive the type ,
which is not itself a function type,
but it is the least upper bound of all function types.


<type> ::= <functionType> `?'?
   <typeNotFunction>

<typeNotVoid> ::= <functionType> `?'?
   <typeNotVoidNotFunction> `?'?

<typeNotFunction> ::=  <typeNotVoidNotFunction> `?'?

<typeNotVoidNotFunction> ::= <typeName> <typeArguments>?
   (<typeIdentifier> '.')? 

<typeName> ::= <typeIdentifier> (`.' <typeIdentifier>)?

<typeArguments> ::= `<' <typeList> `>'

<typeList> ::= <type> (`,' <type>)*

<typeNotVoidNotFunctionList> ::= 
  <typeNotVoidNotFunction> (`,' <typeNotVoidNotFunction>)*

<functionType> ::= <functionTypeTails>
   <typeNotFunction> <functionTypeTails>

<functionTypeTails> ::= <functionTypeTail> `?'? <functionTypeTails>
   <functionTypeTail>

<functionTypeTail> ::=  <typeParameters>? <parameterTypeList>

<parameterTypeList> ::= `(' `)'
   `(' <normalParameterTypes> `,' <optionalParameterTypes> `)'
   `(' <normalParameterTypes> `,'? `)'
   `(' <optionalParameterTypes> `)'

<normalParameterTypes> ::= 
  <normalParameterType> (`,' <normalParameterType>)*

<normalParameterType> ::= <metadata> <typedIdentifier>
   <metadata> <type>

<optionalParameterTypes> ::= <optionalPositionalParameterTypes>
   <namedParameterTypes>

<optionalPositionalParameterTypes> ::= `[' <normalParameterTypes> `,'? `]'

<namedParameterTypes> ::=
  `{' <namedParameterType> (`,' <namedParameterType>)* `,'? `}'

<namedParameterType> ::=
  <metadata> ? <typedIdentifier>

<typedIdentifier> ::= <type> <identifier>

A Dart implementation must provide a static checker that detects and reports
exactly those situations this specification identifies as compile-time errors,
and only those situations.
Similarly, the static checker must emit static warnings
for at least the situations specified as such in this specification.


Nothing precludes additional tools that implement alternative static analyses
(e.g., interpreting the existing type annotations in a sound manner
such as either non-variant generics, or inferring declaration based variance
from the actual declarations).
However, using these tools must not preclude
successful compilation and execution of Dart code.

A typeTis malformed iff:

  * T has the form ùïÄ or the form prefix.ùïÄ,
  and it does not denote a declaration of a type.

  * T denotes a type variable,
  but it occurs in the signature or body of a static member.

  * T is a parameterized type of the form G<S_1, ‚Ä¶, S_n>,
  and G is malformed,
  or G is not a generic type,
  or G is a generic type,
  but it declares n' type parameters and n' ‚â† n,
  or S_j is malformed for some j ‚àà 1 .. n.

  * T is a function type of the form

  T_0<X_1  B_1, ‚Ä¶, X_m  B_m>  (T_1 x_1, ‚Ä¶, T_k x_k,[T_k+1 x_k+1, ‚Ä¶, T_n x_n])
  or of the form

  T_0<X_1  B_1, ‚Ä¶, X_m  B_m>  (T_1 x_1, ‚Ä¶, T_k x_k,{T_k+1 x_k+1, ‚Ä¶, T_n x_n})
  where each x_j which is not a named parameter may be omitted,
  and T_j is malformed for some j ‚àà 0 .. n,
  or B_j is malformed for some j ‚àà 1 .. m.

  * T denotes declarations that were imported from multiple imports clauses.

Any occurrence of a malformed type in a library is a compile-time error.


A typeTis deferredtype!deferred
iff it is of the formp.Twherepis a deferred prefix.
It is a compile-time error to use a deferred type
in a type annotation, type test, type cast or as a type parameter.
However, all other compile-time errors must be issued
under the assumption that all deferred libraries have successfully been loaded.








  ¬ß.¬ß.¬ß Type Promotion
typePromotion
The static type system ascribes a static type to every expression.
In some cases, the type of a local variable
(which can be a formal parameter)
may be promoted from the declared type, based on control flow.


We say that a variablevis known to have typeTwhenever we allow the type ofvto be promoted.
The exact circumstances when type promotion is allowed are given in
the relevant sections of the specification
(<ref>, <ref> and <ref>).


Type promotion for a variablevis allowed only when we can deduce that
such promotion is valid based on an analysis of certain boolean expressions.
In such cases, we say that
the boolean expressionbshows thatvhas typeT.
As a rule, for all variablesvand typesT, a boolean expression
does not show thatvhas typeT.
Those situations where an expression does show that a variable has a type are
mentioned explicitly in the relevant sections of this specification
(<ref> and <ref>).




 ¬ß.¬ß Dynamic Type System
dynamicTypeSystem



Letobe an instance.
The dynamic type ofois the class which is specified
for the situation whereowas obtained as a fresh instance
(<ref>,
<ref>, <ref>, <ref>, <ref>).


In particular, the dynamic type of an instance never changes.
It is at times only specified that the given class implements
a certain type, e.g., for a list literal.
In these cases the dynamic type is implementation dependent,
except of course that said superinterface constraint must be satisfied.

The dynamic types of a running Dart program are equivalent to
the static types with regard to subtyping.


Certain dynamic type checks are performed during execution
(<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>,
<ref>).
As specified in those locations,
these dynamic checks are based on the dynamic types of instances,
and the actual types of declarations
(<ref>).

When types are reified as instances of the built-in class Type,
those objects override the == operator
inherited from the Object class, so that
two Type objects are equal according to operator ==
iff the corresponding types are subtypes of each other.


For example, the Type objects for the types
 and Object are equal to each other
and hence dynamic == Object must evaluate to .
No constraints are imposed on the built-in function identical,
so identical(dynamic, Object) may be  or .

Similarly, Type instances for distinct type alias declarations
declaring a name for the same function type are equal:
 F = <X>(X);
 G = <Y>(Y);

 main() {
  assert(F == G);
}

Instances of Type can be obtained in various ways,
for example by using reflection,
by reading the runtimeType of an object,
or by evaluating a type literal expression.

An expression is a type literal if it is an identifier,
or a qualified identifier,
which denotes a class, mixin, enum, or type alias declaration, or it is
an identifier denoting a type parameter of a generic class or function.
It is a constant type literal if it does not denote a type parameter,
and it is not qualified by a deferred prefix.

A constant type literal is a constant expression (<ref>).


 ¬ß.¬ß Type Aliases
typedef
A type alias declares a name for a type,
or for a mapping from type arguments to types.


It is common to use the phrase ‚Äúa typedef‚Äù for such a declaration,
because of the prominent occurrence of the token .

<typeAlias> ::=  <typeIdentifier> <typeParameters>? `=' <type> `;'
   <functionTypeAlias>

<functionTypeAlias> ::= <functionPrefix> <formalParameterPart> `;'

<functionPrefix> ::= <type>? <identifier>

Consider a type alias declarationDof the form

ùïÄ<> = T;
declared in a libraryL.
The effect ofDis to introduce ùïÄ into the library scope ofL.
Whens = 0(where the type alias is non-generic)
ùïÄ is bound toT.
Whens > 0(where the type alias is generic)
ùïÄ is bound to a mapping from a type argument list
U1s
to the type[U_1/X_1, ‚Ä¶, U_s/X_s]T.


Under the assumption that X1s are types such thatX_j <: B_j, for allj ‚àà 1 .. s,
it is a compile-time error ifTis not regular-bounded,
and it is a compile-time error if any type occurring inTis not well-bounded.


This means that the bounds declared for
the formal type parameters of a generic type alias
must be such that when they are satisfied,
the bounds that pertain to the body are also satisfied,
and a type occurring as a subterm of the body can violate its bounds,
but only if it is a correct super-bounded type.

Moreover,
letT_1, ‚Ä¶, T_lbe types
and letUbe the parameterized type ùïÄ<T_1, ‚Ä¶, T_l>
in a location where ùïÄ denotesD.
It is a compile-time error ifl ‚â† s.
It is a compile-time error ifUis not well-bounded
(<ref>).


For historic reasons, a type alias can have two more forms,
derived using functionTypeAlias.
Let S? be a term which is empty or derived from type,
and similarly for T_j? for anyj.
The two older forms are then defined as follows:


A type alias of the form

S?ùïÄ<>(  T_1? p_1, ‚Ä¶, T_n? p_n, [T_n+1? p_n+1, ‚Ä¶, T_n+k? p_n+k]);
is treated as

ùïÄ<> =  S?(T_1 p_1, ‚Ä¶, T_n p_n, [T_n+1 p_n+1, ‚Ä¶, T_n+k p_n+k]);
A type alias of the form

S?ùïÄ<>(  T_1? p_1, ‚Ä¶, T_n? p_n, {T_n+1? p_n+1, ‚Ä¶, T_n+k? p_n+k});
is treated as

ùïÄ<> =  S?(T_1 p_1, ‚Ä¶, T_n p_n, {T_n+1 p_n+1, ‚Ä¶, T_n+k p_n+k});
In these rules, for eachj, ifT_j?is empty
then T_j is ,
otherwiseT_jisT_j?.


This means that the older forms allow for a parameter type to be omitted,
in which case it is taken to be ,
but the parameter name cannot be omitted.
This behavior is error prone,
and hence the newer form (with =) is recommended.
For instance, the declaration F(int);
specifies that F denotes the type
(),
and it is documented, but technically ignored,
that the parameter has the name int.
It is extremely likely that a reader will misread this,
and assume that int is the parameter type.

It is a compile-time error if a default value is specified for
a formal parameter in these older forms,
or if a formal parameter has the modifier .


Note that the old forms can only define function types,
and they cannot denote the type of a generic function.
When such a type alias has type parameters,
it always expresses a family of non-generic function types.
These restrictions exist because that syntax was defined
before generic functions were added to Dart.

LetD_Fbe a type alias declaration of the form

F<> = T;
IfTorB_jfor somej ‚àà 1 .. sis or contains
a typeNameGdenoting a type alias declarationD_G,
then we say that
D_F depends on D_Gtype alias!dependency.






LetDbe a type alias declaration,
and letMbe the transitive closure of
the type alias declarations thatDdepends on.
A compile-time error occurs ifD ‚àà M.


In other words, it is an error for a type alias declaration
to depend on itself, directly or indirectly.

This kind of error may also arise when type arguments have been
omitted in the program, but are added during static analysis
via instantiation to bound
(<ref>)
or via type inference,
which will be specified later
(<ref>).

WhenDis a type alias declaration of the form

F<> = T;
we say that the parameterized typeUof the form
F<U1s>
in a scope whereFresolves toDalias expands in one step to
  type alias!alias expands in one step[U_1/X_1, ‚Ä¶, U_s/X_s]T.


Note that s can be zero, in which case F is non-generic,
and we are just replacing the type alias name by its body.

IfUis a type we may repeatedly replace each subterm ofUwhich is a parameterized type applying a type alias to some type arguments
by its alias expansion in one step
(including the non-generic case where there are no type arguments).
When no further steps are possible we say that the resulting type is the
transitive alias expansion
  type alias!transitive alias expansion
ofU.


Note that the transitive alias expansion exists,
because it is an error for a type alias declaration
to depend on itself.
However, it may be large.
For instance, F<X> = Map<X, X>; yields
an exponential size increase for F<F<‚Ä¶F<int>‚Ä¶>>.

D, F, T
LetDbe a type alias declaration of the form

F<> = T;
and let U be a type of the formFor p.F
in a scope where this term denotesD.
Assume that the transitive alias expansion of F<X1s> is
C, q
a type of the formCor q.C,
optionally followed by typeArguments,
whereqis an identifier denoting an import prefix,
andCrespectively q.C denotes a class or mixin
(in particular, C can not be a type variable).
Assume thatUoccurs in an expressioneof the form
`U.ùïÄ args'
where args is derived from <argumentPart>?,
such that ùïÄ is the name of
a static member ofCrespectively q.C.
The expressioneis then treated as
`C.ùïÄ args'
respectively
`q.C.ùïÄ args'.


This means that it is possible to use a type alias
to invoke a static member of a class or a mixin.
For example:
 C<X> {
  static void staticMethod() {}}
 F = C<int>;

 main() {
  F.staticMethod(); // OK.}
Note that the type arguments passed to C respectively p.C
are erased,
such that the resulting expression can be a correct static member invocation.
If a future version of Dart allows type arguments to be passed via the class
in an invocation of a static member,
it may be preferable to preserve these type arguments.
At that time,
existing invocations where type arguments are passed in this manner
will not break,
because it is currently an error for a static member to depend on the value
of a formal type parameter of the enclosing class.

D, F, X_j, B_j
LetDbe a type alias declaration of the form

F<> = T;
wheres > 0.
Y_j
Let Y1s be fresh type variables,
assumed to satisfy the bounds ofD.
We say thatDexpands to a type variable
if the transitive alias expansion of
F<Y1s>
isY_jfor somej ‚àà 1 .. s.


T, F, D
LetTbe a parameterized type F<T1s>
(wherescan be zero)
in a scope whereFdenotes a type alias declarationD.
We say thatTuses D as a classtype alias!used as a class
whenToccurs in one of the following ways:


  * T occurs in an instance creation expression of the form
  ncT(‚Ä¶) or the form ncT.ùïÄ(‚Ä¶),
  where nc is either  or 
  (<ref>).
  
    Note that, e.g., T(42) may be an instance creation,
    but it is then treated as T(42) or T(42),
    which means that it is included here
    (<ref>).
  
  * T or T.ùïÄ is the redirectee in a redirecting factory constructor,
  (<ref>).

  * T is used as a superclass, a mixin, or a superinterface
  in a class declaration
  (<ref>, <ref>, <ref>),
  or as an  type or a superinterface in a mixin declaration
  (<ref>).
  
  

  * T is used to invoke a static member of a class or mixin,
  as described above.

A compile-time error occurs ifDexpands to a type variable,
andTusesDas a class.
A compile-time error occurs ifTusesDas a class,
andTis not regular-bounded.
For example: C<X extends num> {} F<Y extends int> = C<Y>;
 G<Z> = Z;

 main() {
  F<int>(); // OK.
  C<num>(); // OK.
  F<num>(); // Error.
  G<C<int>>(); // Error.}
When we use phrases like `letSbe a class' or `assume thatSis a mixin',
it is understood that this includes the case whereSis a typeName denoting a type alias, orSis a parameterized type of the form
<typeName> <typeArguments>
where the type name denotes a type alias,
and the transitive alias expansion ofSdenotes a class respectively a mixin.




 ¬ß.¬ß Subtypes
subtypes
This section defines when a type is a subtype of another type.
The core of this section is the set of rules defined in
Figure¬†<ref>,
but we will need to introduce a few concepts first,
in order to clarify what those rules mean.


A reader who has read many research papers about object-oriented type systems
may find the meaning of the given notation obvious,
but we still need to clarify a few details about how to handle
syntactically different denotations of the same type,
and how to choose the right initial environment, Œî.

For a reader who is not familiar with the notation used in this section,
the explanations given here should suffice to clarify what it means,
with reference to the natural language explanations given at the end of
the section for obtaining an intuition about the meaning.

This section is concerned with subtype relationships between types
during static analysis
as well as subtype relationships as queried in dynamic checks,
type tests
(<ref>),
and type casts
(<ref>).


A variant of the rules described here is shown in an appendix
(<ref>),
demonstrating that Dart subtyping can be decided efficiently.



Types of the form
X & Stype!of the form X & S
&@X & S
arise during static analysis due to type promotion
(<ref>).
They never occur during execution,
they are never a type argument of another type,
nor a return type or a formal parameter type,
and it is always the case thatSis a subtype of the bound ofX.

The motivation for X & S is that it represents
the type of a local variable v
whose type is declared to be the type variable X,
and which is known to have type S due to promotion.
Similarly, X & S may be seen as an intersection type,
which is a subtype of X and also a subtype of S.
Intersection types are not supported in general,
only in this special case.

Every other form of type may occur during static analysis
as well as during execution,
and the subtype relationship is always determined in the same way.




#1#2#3#4[#1]#3#4#1#2#3#4#5#6[#1]#3#4#5#6#1#2#3#4#5#6#7#8
    [#1]#3#4   #5#6#7#8#1#2#3#4#5
    [#1]#3#4#5#1#2#3#4[#1]#3#4
  [c]0.49ReflexivitySSLeft BottomT[c]0.49Right TopT ‚àà{Object, , }STLeft NullT ‚â†NullTType Alias Left
    F<Xs> = U   [S_1/X_1,‚Ä¶,S_s/X_s]UTF<S1s>TType Alias Right
    F<Xs> = U   S[T_1/X_1,‚Ä¶,T_s/X_s]USF<T1s>[c]0.49Left FutureOrST
      Future<S>TFutureOr<S>TRight Promoted VariableSXST
      SX & TRight FutureOr BSTSFutureOr<T>Left Variable BoundŒî(X)TXT[c]0.49Left Promoted Variable AX & SXRight FutureOr ASFuture<T>
      SFutureOr<T>Left Promoted Variable BSTX & STRight FunctionT
      T
  Positional Function Types
    Œî' = Œî‚äé{X_i‚Ü¶B_i | 1 ‚â§ i ‚â§ s}   Œî'S_0T_0

    n_1 ‚â§ n_2    
    n_1 + k_1 ‚â• n_2 + k_2    ‚àÄ j ‚àà 1 .. n_2 + k_2: Œî'T_jS_j
    [ Œî‚ä¢S_0XBsSn_1k_1 <:;      T_0XBsTn_2k_2 ]Named Function Types
    Œî' = Œî‚äé{X_i‚Ü¶B_i | 1 ‚â§ i ‚â§ s}   Œî'S_0T_0   ‚àÄ j ‚àà 1 .. n: Œî'T_jS_j
{ yn+1n+k_2 }‚äÜ{ xn+1n+k_1 }
‚àÄ p ‚àà 1 .. k_2, q ‚àà 1 .. k_1:  
    y_n+p = x_n+q  ‚áí  Œî'T_n+pS_n+q
    [ Œî‚ä¢S_0XBsSnxk_1r <:;      T_0XBsTnyk_2r ]
  Covariance
    C<Xs> ‚Ä¶ {}   ‚àÄ j ‚àà 1 .. s: S_jT_j
    C<S1s>C<T1s>Superinterface
    C<Xs> ‚Ä¶ {}
D<T1m>C   [S_1/X_1,‚Ä¶,S_s/X_s]D<T1m>T
    C<S1s>  T
  Subtype rules.

  ¬ß.¬ß.¬ß Meta-Variables
metaVariables
A meta-variable is a symbol which stands for a syntactic construct
that satisfies some static semantic requirements.


For instance, X is a meta-variable standing for
an identifier W,
but only if W denotes a type variable declared in an enclosing scope.
In the definitions below, we specify this by saying that
`X ranges over type variables'.
Similarly, C is a meta-variable standing for
a typeName, for instance, p.D,
but only if p.D denotes a class in the given scope.
We specify this as `C ranges over classes'.

In this section we use the following meta-variables:


  * X ranges over type variables.

  * C ranges over classes,

  * F ranges over type aliases.

  * T and S range over types, possibly with an index like T_1 or S_j.

  * B ranges over types, again possibly with an index;
  it is only used as a type variable bound.


  ¬ß.¬ß.¬ß Subtype Rules
subtypeRules
We define several rules about subtyping in this section.
Whenever a rule contains one or more meta-variables,
that rule can be used by
instantiatinginstantiation!subtype rule
it, that is, by consistently replacing
each occurrence of a given meta-variable by
concrete syntax denoting the same type.


In general, this means that two or more occurrences of
a given meta-variable in a rule
stands for identical pieces of syntax,
and the instantiation of the rule proceeds as
a simple search-and-replace operation.
For instance,
rule¬† in Figure¬†<ref>
can be used to conclude
‚àÖintint,
where ‚àÖ denotes the empty environment
(any environment would suffice because no type variables occur).

However, the wording `denoting the same type' above covers
additional situations as well:
For instance, we may use rule¬†
to show that p1.C is a subtype of
p2.C when C is a class declared in a
library L which is imported by libraries L_1 and L_2 and
used in declarations there,
when L_1 and L_2 are imported with prefixes
p1 respectively p2 by the current library.
The important point is that all occurrences of the same meta-variable
in a given rule instantiation stands for the same type,
even in the case where that type is not denoted by
the same syntax in both cases.

Conversely, we can not use the same rule to conclude
that C is a subtype of C
in the case where the former denotes a class declared in library L_1
and the latter denotes a class declared in L_2, with L_1 ‚â† L_2.
This situation can arise without compile-time errors, e.g.,
if L_1 and L_2 are imported indirectly into the current library
and the two ‚Äúmeanings‚Äù of C are used
as type annotations on variables or formal parameters of functions
declared in intermediate libraries importing L_1 respectively L_2.
The failure to prove
‚Äú‚àÖCC‚Äù
will then occur, e.g., in a situation where we check whether
such a variable can be passed as an actual argument to such a function,
because the two occurrences of C do not denote the same type.

Every typeName used in a type mentioned in this section is assumed to
have no compile-time error and denote a type.


That is, no subtyping relationship can be proven for
a type that is or contains an undefined name
or a name that denotes something other than a type.
Note that it is not necessary in order to determine a subtyping relationship
that every type satisfies the declared bounds,
the subtyping relation does not depend on bounds.
However, if an attempt is made to prove a subtype relationship
and one or more typeNames receives an actual type argument list
whose length does not match the declaration
(including the case where some type arguments are given to a non-generic class,
and the case where a generic class occurs, but no type arguments are given)
then the attempt to prove the relationship simply fails.

The rules in Figure¬†<ref> use
the symbol Œî to denote the given knowledge about the
bounds of type variables.Œîis a partial function that maps type variables to types.
At a given location where the type variables in scope are

(as declared by enclosing classes and/or functions),
we define the environment as follows:Œî = { X_1 ‚Ü¶ B_1, ‚Ä¶ X_s ‚Ü¶ B_s }.

That is, Œî(X_1) = B_1, and so on,
and Œî is undefined when applied to a type variable Y
which is not in { X1s }.

When the rules are used to show that a given subtype relationship exists,
this is the initial value ofŒî.


If a generic function type is encountered, an extension ofŒîis used,
as shown in the rules¬†
and¬†
of Figure¬†<ref>.
Extension of environments uses the operator ‚äé,
which is the operator that produces the union of disjoint sets,
and gives priority to the right hand operand in case of conflicts.


So
{X‚Ü¶int, Y‚Ü¶double}‚äé{Z‚Ü¶Object} =
{X‚Ü¶int, Y‚Ü¶double, Z‚Ü¶Object}
and
{X‚Ü¶int, Y‚Ü¶FutureOr<List<double>>}‚äé{Y‚Ü¶int} =
{X‚Ü¶int, Y‚Ü¶int}.
Note that operator ‚äé is concerned with scopes and shadowing,
with no connection to, e.g., subtypes or instance method overriding.

In this specification we frequently refer to
subtype relationships and assignability
without mentioning the environment explicitly,
as in ST.
This is only done when a specific location in code is in focus,
and it means that the environment is that which is obtained
by mapping each type variable in scope at that location
to its declared bound.


Each rule in Figure¬†<ref> has a horizontal line,
to the left of which the rule number is indicated;
under the horizontal line there is a judgment which is the
conclusionrule!conclusion
of the rule,
and above the horizontal line there are zero or more
premisesrule!premise
of the rule,
which are typically also subtype judgments.
When that is not the case for a given premise,
we specify the meaning explicitly.


Instantiation of a rule, mentioned above,
denotes the consistent replacement of meta-variables
by actual syntactic terms denoting types everywhere in the rule,
that is, in the premises as well as in the conclusion, simultaneously.


  ¬ß.¬ß.¬ß Being a subtype
beingASubtype
A typeSis shown to be a subtype of another typeTin an environmentŒîby providing
an instantiation of a ruleRwhose conclusion is
STŒî@ST,
along with rule instantiations showing
each of the premises ofR,
continuing until a rule with no premises is reached.


For rule , note that the Null type
is a subtype of all non- types,
even though it doesn't actually extend or implement those types.
The other types are effectively treated as if they were nullable,
which makes the null object (<ref>) assignable to them.

The first premise in the
rules¬† and¬†
is a type alias declaration.
This premise is satisfied in each of the following situations:


  *  A non-generic type alias named F is declared.
  In this case s is zero,
  no assumptions are made about the existence
  of any formal type parameters,
  and actual type argument lists are omitted everywhere in the rule.

  *  We may choose s and X1s such that the following holds:
  A generic type alias named F is declared,
  with formal type parameters X1s.
  
    Each formal type parameter X_j may have a bound,
    but the bounds are never used in this context,
    so we do not introduce metavariables for them.
  
Rule¬† has as a premise that `Tis a function type'.
This means thatTis a type of one of the forms introduced in
section¬†<ref>.

This is the same as the forms of type that occur at top level
in the conclusions of
rule¬† and
rule¬†.

In rules¬† and¬†,
the first premise is a class declaration.
This premise is satisfied in each of the following situations:


  *  A non-generic class named C is declared.
  In this case s is zero,
  no assumptions are made about the existence
  of any formal type parameters,
  and actual type argument lists are omitted everywhere in the rule.

  *  We may choose s and X1s such that the following holds:
  A generic class named C is declared,
  with formal type parameters X1s.
  
    Each formal type parameter X_j may have a bound,
    but the bounds are never used in this context,
    so we do not introduce metavariables for them.
  
The second premise of rule¬† specifies that
a parameterized type D<‚Ä¶> belongs to
Csuperinterfaces(C)@C.
The semantic function _ applied to a generic classCyields
the set of direct superinterfaces ofC(<ref>).


Note that one of the direct superinterfaces of C is
the interface of the superclass of C,
and that may be a mixin application
(<ref>),
in which case D in the rule is
the synthetic class which specifies
the semantics of that mixin application.

The last premise of rule¬†
substitutes the actual type arguments S1s for the
formal type parameters X1s,
because T1m may contain those formal type parameters.

The rules¬† and¬†
are applicable to interfaces,
but they can be used with classes as well,
because a non-generic class C which is used as a type
denotes the interface of C,
and similarly for a parameterized type
C<T1k>
where C denotes a generic class.


  ¬ß.¬ß.¬ß Informal Subtype Rule Descriptions
informalSubtypeRuleDescriptions
This section gives an informal and non-normative natural language description
of each rule in Figure¬†<ref>.

The descriptions use the rule numbers to make the connection explicit,
and also adds names to the rules that may be helpful in order to understand
the role played by each rule.

In the following, many rules contain meta-variables
(<ref>)
like S and T,
and it is always the case that they can stand for arbitrary types.
For example, rule¬† says that
‚ÄúThe type S is a ‚Ä¶ of FutureOr<T>‚Ä¶‚Äù,
and this is taken to mean that for any arbitrary types S and T,
showing that S is a subtype of T is sufficient to show that S is
a subtype of FutureOr<T>.

Another example is the wording in rule¬†:
‚Äú‚Ä¶ in any environment Œî‚Äù,
which indicates that the rule can be applied no matter which bindings
of type variables to bounds there exist in the environment.
It should be noted that the environment matters even with rules
where it is simply stated as a plain Œî in the conclusion
and in one or more premises,
because the proof of those premises could, directly or indirectly,
include the application of a rule where the environment is used.

#1#2
  #1#2:Reflexivity
  Every type is a subtype of itself, in any environment Œî.
  In the following rules except for a few,
  the rule is also valid in any environment
  and the environment is never used explicitly,
  so we will not repeat that.
Top
  Every type is a subtype of Object,
  every type is a subtype of ,
  and every type is a subtype of .
  Note that this implies that these types are equivalent
  according to the subtype relation.
  We denote these types,
  and others with the same property (such as FutureOr<Object>),
  as top types
  (<ref>).
Bottom
  Every type is a supertype of .
Null
  Every type other than  is a supertype of Null.
Type Alias Left
  An application of a type alias to some actual type arguments is
  a subtype of another type T
  if the expansion of the type alias to the type that it denotes
  is a subtype of T.
  Note that a non-generic type alias is handled by letting s = 0.
Type Alias Right
  A type S is a subtype of an application of a type alias
  if S is a subtype of
  the expansion of the type alias to the type that it denotes.
  Note that a non-generic type alias is handled by letting s = 0.
Left FutureOr
  The type FutureOr<S> is a subtype of a given type T
  if S is a subtype of T and Future<S> is a subtype of T,
  for every type S and T.
Left Promoted Variable
  The type X & S is a subtype of X.
Right Promoted Variable A
  The type S is a subtype of X & T if
  S is a subtype of both X and T.
Right FutureOr A
  The type S is a subtype of FutureOr<T> if
  S is a subtype of Future<T>.
Right FutureOr B
  The type S is a subtype of FutureOr<T> if
  S is a subtype of T.
Left Promoted Variable B
  The type X & S is a subtype of T if
  S is a subtype of T.
Left Variable Bound
  The type variable X is a subtype of a type T if
  the bound of X
  (as specified in the current environment Œî)
  is a subtype of T.
Right Function
  Every function type is a subtype of the type .
Positional Function Type
  A function type F_1 with positional optional parameters
  is a subtype of
  another function type F_2 with positional optional parameters
  if the former has at most
  the same number of required parameters as the latter,
  and the latter has at least
  the same total number of parameters as the former;
  the return type of F_1 is a subtype of that of F_2;
  and each parameter type of F_1 is a supertype of
  the corresponding parameter type of F_2, if any.
  Note that the relationship to function types with no optional parameters,
  and the relationship between function types with no optional parameters,
  is covered by letting k_2 = 0 respectively k_1 = k_2 = 0.
  For every subtype relation considered in this rule,
  the formal type parameters of F_1 and F_2 must be taken into account
  (as reflected in the use of the extended environment Œî').
  We can assume without loss of generality
  that the names of type variables are pairwise identical,
  because we consider types of generic functions to be equivalent under
  consistent renaming
  (<ref>).
  In short, ‚Äúduring the proof, we will rename them as needed‚Äù.
  Finally, note that the relationship between non-generic function types
  is covered by letting s = 0.
Named Function Type
  A function type F_1 with named optional parameters is a subtype of
  another function type F_2 with named optional parameters
  if they have the same number of required parameters,
  and the set of names of named parameters for the latter is a subset
  of that for the former;
  the return type of F_1 is a subtype of that of F_2;
  and each parameter type of F_1 is a supertype of
  the corresponding parameter type of F_2, if any.
  Note that the relationship to function types with no optional parameters,
  and the relationship between function types with no optional parameters,
  is covered by letting k_2 = 0 respectively k_1 = k_2 = 0,
  and also that the latter case is identical to the rule obtained from
  rule¬†
  concerning subtyping among function types with no optional parameters.
  As in rule¬†,
  we can assume without loss of generality
  that the names of type variables are pairwise identical.
  Similarly, non-generic functions are covered by letting s = 0.
Class Covariance
  A parameterized type based on a generic class C is a subtype of
  a parameterized type based on the same class C if
  each actual type argument of the former is a subtype of
  the corresponding actual type argument of the latter.
  This rule may have s = 0 and cover a non-generic class as well,
  but that is redundant because this is already covered by
  rule¬†.
Superinterface
  Considering the case where s = 0 and m = 0 first,
  a parameterized type based on a non-generic class C is a subtype of
  a parameterized type based on a different non-generic class D if
  D is a direct superinterface of C.
  When s > 0 or m > 0, this rule describes a subtype relationship
  which includes one or more generic classes,
  in which case we need to give names to the formal type parameters of C,
  and specify how they are used in the specification of the superinterface
  based on D.
  With those pieces in place, we can specify the subtype relationship
  that exists between two parameterized types based on C and D.
  
  
  
  
  The case where the superclass is a mixin application is covered via
  the equivalence with a declaration of a regular (possibly generic) superclass
  (<ref>),
  and this means that there may be multiple subtype steps from
  a given class declaration to the class specified in an  clause.



  ¬ß.¬ß.¬ß Additional Subtyping Concepts
additionalSubtypingConceptsSis a supertype ofTin a given environmentŒî,
written ST,
iff TS.


A typeTmay be assigned
to a typeSin an environmentŒî,
written ST,
iff either ST or TS.
In this case we say that the typesSandTare
assignable.


This rule may surprise readers accustomed to conventional typechecking.
The intent of the  relation
is not to ensure that an assignment is guaranteed to succeed dynamically.
Instead, it aims to only flag assignments
that are almost certain to be erroneous,
without precluding assignments that may work.

For example, assigning an object of static type Object
to a variable with static type String,
while not guaranteed to be correct,
might be fine if the run-time value happens to be a string.

A static analyzer or compiler
may support more strict static checks as an option.


 ¬ß.¬ß Function Types
functionTypes
Function typestype!function
come in two variants:

  * 
  The types of functions that only have positional parameters.
  These have the general form
  T.

  * 
  The types of functions with named parameters.
  These have the general form
  T.

Note that the non-generic case is covered by having s = 0,
in which case the type parameter declarations are omitted
(<ref>).
The case with no optional parameters is covered by having k = 0;
note that all rules involving function types of the two kinds
coincide in this case.

Two function types are considered equal if consistent renaming of type
parameters can make them identical.


A common way to say this is that we do not distinguish
function types which are alpha-equivalent.
For the subtyping rule below this means we can assume that
a suitable renaming has already taken place.
In cases where this is not possible
because the number of type parameters in the two types differ
or the bounds are different,
no subtype relationship exists.

A function object is always an instance of some classCthat implements
the class  (<ref>),
and which has a method named ,
whose signature is the function typeCitself.

Consequently, all function types are subtypes of 
(<ref>).


 ¬ß.¬ß Type 
functionType
The built-in class  is a supertype of all function types
(<ref>).
It is impossible to extend, implement, or mix in the class .


If a class declaration or mixin application has  as superclass,
it instead uses Object as superclass.


If a class or mixin declaration implements , it has no effect.
It is as if the  was removed from the implements clause
(and if it's the only implemented interface, the entire clause is removed).
The resulting class or mixin interface
does not have  as a superinterface.


If a mixin application mixes  onto a superclass, it follows the
normal rules for mixin-application, but since the result of that mixin
application is equivalent to a class with implements Function, and
that clause has no effect, the resulting class also does not
implement . The  class declares no
concrete instance members, so the mixin application creates a sub-class
of the superclass with no new members and no new interfaces.
Since using  in these ways has no effect, it would be
reasonable to disallow it completely, like we do extending, implementing or
mixing in types like int or String.
For backwards compatibility with Dart 1 programs,
the syntax is allowed to remain, even if it has no effect.
Tools may choose to warn users that their code has no effect.


 ¬ß.¬ß Type 
typeDynamic
The type  is a static type which is a supertype of all other types,
just like Object,
but it differs from other types in that the static analysis
assumes that every member access has a corresponding member
with a signature that admits the given access.


For instance,
when the receiver in an ordinary method invocation has type ,
any method name can be invoked,
with any number of type arguments or none,
with any number of positional arguments,
and any set of named arguments,
of any type,
without error.
Note that the invocation will still cause a compile-time error
if there is an error in one or more arguments or other subterms.


If no static type annotation has been provided,
the type system considers declarations to have type .

If a generic type is used but type arguments are not provided,
the type arguments default to type .



This means that given a generic declaration
G<P_1, ‚Ä¶, P_n>‚Ä¶,
where P_i is a formal type parameter declaration, i ‚àà 1 .. n,
the type G is equivalent to

G<, ‚Ä¶,>.

The built-in type declaration dynamic,
which is declared in the library dart:core,
denotes the  type.
When the name  exported by dart:core is evaluated
as an expression,
it evaluates to a Type object representing the  type,
even though  is not a class.


This Type object must compare equal to the corresponding Type
objects for Object and  according to operator ==
(<ref>).

To improve the precision of static types,
member accesses on a receiver of type  that refer to
declarations of the built-in class Object
are given the static type corresponding to those declarations
whenever doing so is sound.


  * 
  Let e be an expression of the form d.ùïÄ,
  which is not followed by an argument part,
  where the static type of d is ,
  and ùïÄ is the name of a getter declared in Object;
  if the return type of Object.ùïÄ is T then
  the static type of e is T.
  
    For instance, d.hashCode has type int
    and d.runtimeType has type Type.
  
  * 
  Let e be an expression of the form d.ùïÄ,
  which is not followed by an argument part,
  where the static type of d is ,
  and ùïÄ is the name of a method declared in Object
  whose method signature has type F
  (which is a function type).
  The static type of e is then F.
  
    For instance, d.toString has type String ().
  
  * 
  Let e be an expression which is of the form
  d.ùïÄ(arguments)
  or the form d.ùïÄ<typeArguments>(arguments),
  where the static type of d is ,
  ùïÄ is the name of a getter declared in Object with return type F,
  arguments are derived from arguments, and
  typeArguments are derived from typeArguments, if present.
  Static analysis will then process e as a function expression invocation
  where an object of static type F is applied to the given argument part.
  
  So this is always a compile-time error.
  For instance, d.runtimeType(42) is a compile-time error,
  because it is checked as a
  function expression invocation where an entity of static type Type is
  invoked. Note that it could actually succeed: An overriding implementation
  of runtimeType could return an instance whose dynamic type is a subtype
  of Type that has a  method.
  We decided to make it an error because it is likely to be a mistake,
  especially in cases like d.hashCode()
  where a developer might have forgotten that hashCode is a getter.
  
  * 
  Let e be an expression of the form d.ùïÄ(arguments)
  where the static type of d is , arguments is
  an actual argument list derived from arguments,
  and ùïÄ is the name of a method declared in Object
  whose method signature has type F.
  If the number of positional actual arguments in arguments
  is less than the number of required positional arguments of F
  or greater than the number of positional arguments in F,
  or if arguments includes any named arguments
  with a name that is not declared in F,
  the type of e is .
  Otherwise, the type of e is the return type in F.
  
    So d.toString(bazzle: 42) has type  whereas
    d.toString() has type String.
    Note that invocations which "do not fit" the statically
    known declaration are not errors, they just get return type .
  
  * 
  Let e be an expression of the form
  d.ùïÄ<typeArguments>(arguments) where
  the static type of d is ,
  typeArguments is a list of actual
  type arguments derived from typeArguments, and
  arguments is an actual argument list derived from arguments.
  It is a compile-time error if ùïÄ is the name of
  a non-generic method declared in Object.
  
    No generic methods are declared in Object.
    Hence, we do not specify that there must be
    the statically required number of actual type arguments, and
    they must satisfy the bounds.
    That would otherwise be the consistent approach,
    because the invocation is guaranteed to fail when any of those
    requirements are violated,
    but generalizations of this mechanism would need to include such rules.
  
  * 
  For an instance method invocation e (including invocations of getters,
  setters, and operators) where the receiver has static type  and
  e does not match any of the above cases, the static type of e is
  .
  When an expression derived from cascadeSection performs
  a getter or method invocation that corresponds to one of the cases above,
  the corresponding static analysis and compile-time errors apply.
  
    For instance, d..foobar(16)..hashCode() is an error.
  
Note that only very few forms of instance method invocation with a
receiver of type  can be a compile-time error.
Of course, some expressions like x[1, 2] are syntax errors
even though they could also be considered "invocations",
and subexpressions are checked separately so
any given actual argument could be a compile-time error.
But almost any given argument list shape could be handled via
noSuchMethod,
and an argument of any type could be accepted because any
formal parameter in an overriding declaration could have its type
annotation contravariantly changed to Object.
So it is a natural consequence of the principle of
that
a  receiver admits almost all instance method invocations.
The few cases where an instance method invocation with
a receiver of type  is an error
are either guaranteed to fail at run time,
or they are very, very likely to be developer mistakes.


 ¬ß.¬ß Type FutureOr
typeFutureOr
The built-in type declaration FutureOr,
which is exported by the library dart:async,
defines a generic type with one type parameter (<ref>).
The type FutureOr<T> is a non-class type
which is regular-bounded for allT.


The subtype relations involving FutureOr are specified elsewhere
(<ref>).
Note, however, that they entail certain useful properties:

  ‚àôT <: FutureOr<T>.

  ‚àôFuture<T> <: FutureOr<T>.

  ‚àô
  If T <: S and Future<T> <: S, then FutureOr<T> <: S.


That is, FutureOr is in a sense
the union of T and the corresponding future type.
The last point guarantees that
FutureOr<T> <: Object,
and also that FutureOr is covariant in its type parameter,
just like class types:
if S <: T then FutureOr<S> <: FutureOr<T>.

If the type arguments passed to FutureOr would incur compile-time errors
if applied to a normal generic class with one type parameter,
the same compile-time errors are issued for FutureOr.
The name FutureOr as an expression
denotes a Type object representing the type FutureOr<dynamic>.


The FutureOr<T> type represents a case where an object can be
either an instance of the type T
or the type Future<T>.
Such cases occur naturally in asynchronous code.
The available alternative would be to use a top type (e.g., ),
but FutureOr allows some tools to provide a more precise type analysis.

The type FutureOr<T> has an interface that is identical to that
of Object.

That is, only members that Object has can be invoked
on an object with static type FutureOr<T>.

We only want to allow invocations of members that are inherited from
a common supertype of both T and Future<T>.
In most cases the only common supertype is Object.
The exceptions, like FutureOr<Future<Object
which has Future<Object> as common supertype,
are few and not practically useful,
so for now we choose to only allow invocations of
members inherited from Object.

We define the auxiliary function
TfutureOrBase(t)@futureOrBase(T)
as follows:


  *  If T is FutureOr<S> for some S
  then T = S.

  *  Otherwise T = T.


 ¬ß.¬ß Type Void
typeVoid
The special type  is used to indicate
that the value of an expression is meaningless and intended to be discarded.


A typical case is that the type  is used as the return type
of a function that ‚Äúdoes not return anything‚Äù.
Technically, there will always be some object
which is returned
(<ref>).
But it is perfectly meaningful to have a function
whose sole purpose is to create side-effects,
such that any use of the returned object
would be misguided.

This does not mean that there is anything wrong
with the returned object as such.
It could be any object whatsoever.
But the developer who chose the return type 
did that to indicate that it is a misunderstanding to
ascribe any meaning to that object,
or to use it for any purpose.

The type  is a top type
(<ref>),
so  and Object are subtypes of each other
(<ref>),
which also implies that any object can be
the value of an expression of type .

Consequently, any instance of type Type which reifies the type 
must compare equal (according to the == operator <ref>)
to any instance of Type which reifies the type Object
(<ref>).
It is not guaranteed that identical(, Object) evaluates to true.
In fact, it is not recommended that implementations strive to achieve this,
because it may be more important to ensure that diagnostic messages
(including stack traces and dynamic error messages)
preserve enough information to use the word `void' when referring to types
which are specified as such in source code.

In support of the notion
that the value of an expression with static type  should be discarded,
such objects can only be used in specific situations:
The occurrence of an expression of type  is a compile-time error
unless it is permitted according to one of the following rules.


  * 
  In an expressionStatemente;, e may have type .
  The value of e is discarded.
  * 
  In the initialization and increment expressions of a for-loop,
   (e_1; e_2; e_3) ‚Ä¶,
  e_1 may have type ,
  and each of the expressions in the expression list e_3 may have type .
  The values of e_1 and e_3 are discarded.
  * 
  In a type cast e as T, e may have type .
  
  Developers thus obtain the ability to override the constraints
  on usages of values with static type .
  This means that it is not enforced that such values are discarded,
  but they can only be used when the wish to do so
  has been indicated explicitly.
  
  * 
  In a parenthesized expression (e), e may have type .
  
  Note that (e) itself has type ,
  which implies that it must occur in some context
  where it is not an error to have it.
  
  * 
  In a conditional expression e ? e_1 : e_2,
  e_1 and e_2 may have type .
  
  The static type of the conditional expression is then ,
  even if one of the branches has a different type,
  which means that the conditional expression must again occur
  in some context where it is not an error to have it.
  
  * 
  In a null coalescing expression e_1 ?? e_2,
  e_2 may have type .
  
  The static type of the null coalescing expression is then ,
  which in turn restricts where it can occur.
  
  * 
  In an expression of the form   e, e may have type .
  
  This rule was adopted because it was a substantial breaking change
  to turn this situation into an error
  at the time where the treatment of  was changed.
  Tools may choose to give a hint in such cases.
  
  * 
  In a return statement  e;,
  e may have type  in a number of situations
  (<ref>).
  
  * 
  In an arrow function body => e,
  the returned expression e may have type 
  in a number of situations
  (<ref>).
  
  * 
  An initializing expression for a variable of type 
  may have type .
  Usages of that variable are constrained.
  * 
  An actual parameter expression corresponding to a formal parameter
  whose statically known type annotation is 
  may have type .
  
  Usages of that parameter in the body of the callee
  are statically expected to be constrained by having type .
  See the discussion about soundness below
  (<ref>).
  
  * 
  In an expression of the form e_1 = e_2
  where e_1 is an assignableExpression
  denoting a variable or formal parameter of type ,
  e_2 may have type .
  
  Usages of that variable or formal parameter
  are statically expected to be constrained by having type .
  See the discussion about soundness below
  (<ref>).
  
  * 
  Let e be an expression ending in a cascadeSection
  of the form .. S s = e_1,
  where S is of the form

  (<cascadeSelector> <argumentPart>*)
    (<assignableSelector> <argumentPart>*)*
  and e_1 is of the form expressionWithoutCascade.

  If s is an assignableSelector of the
  form .ùïÄ or ?.ùïÄ
  where the static type of the identifier ùïÄ is ,
  e_1 may have type .
  Otherwise, if s is an assignableSelector of the form
  [e_0] where the static type of
  the first formal parameter in the statically known declaration
  of operator []= is ,
  e_0 may have type .
  Also, if the static type of the second formal parameter is ,
  e_1 may have type .

Finally, we need to address situations involving implicit usage of
an object whose static type can be .

It is a compile-time error for a for-in statement to have an iterator
expression of typeTsuch that Iterator<>
is the most specific instantiation of Iterator
that is a superinterface ofT, unless the
iteration variable has type .

It is a compile-time error for an asynchronous for-in statement
to have a stream expression of typeTsuch that Stream<> is the most specific
instantiation of Stream that is a superinterface ofT,
unless the iteration variable has type .


Here are some examples:
 (Object x in <>[]) {} // Error. (int x  new Stream<>.empty()) {} // Error. ( x  <>[]) {‚Ä¶} // OK. ( x  <>[]) {‚Ä¶} // OK, type of x inferred.
However, in the examples that are not errors
the usage of x in the loop body is constrained,
because it has type .


  ¬ß.¬ß.¬ß Void Soundness
voidSoundness
The constraints on usage of an object obtained from the evaluation of
an expression with static type 
are not strictly enforced.


The usage of a ‚Äúvoid value‚Äù is not a soundness issue, that is,
no invariants needed for correct execution of a Dart program
can be violated because of such a usage.

It could be said that the type  is used
to help developers maintain a certain self-imposed discipline
about the fact that certain objects are not intended to be used.

Because of the fact that enforcement is not necessary,
and because of the treatment of  in earlier versions of Dart,
the language uses a best effort approach to ensure
that the value of an expression of type 
will not be used.

In fact, there are numerous ways in addition to the type cast
in which a developer can get access to such an object:
 A<X> {
  final X x;
  A(this.x);
  Object foo(X x);
}
 B<X>  A<X> {
  B(X x): super(x);
  Object foo(Object x) => x;
}

Object f<X>(X x) => x;

 main() { x = 42;
  print(f(x)); // (1)

  A<> a = B<>(x);
  A<Object> aObject = a;
  print(aObject.x); // (2)
  print(a.foo(x)); // (3)}
At (1), a variable x of type  is passed to
a generic function f,
which is allowed because the actual type argument  is inferred,
and it is allowed to pass an actual argument of type  to
a formal parameter with the same type.

However, no special treatment is given when an expression has a type
which is or contains a type variable whose value could be ,
so we are allowed to return x in the body of f,
even though this means that we indirectly get access to the value
of an expression of type , under the static type Object.

At (2), we indirectly obtain access to the value of
the variable x with type ,
because we use an assignment to get access to the instance of B
which was created with type argument  under the type
A<Object>.
Note that A<Object> and A<> are subtypes of each other,
that is, they are equivalent according to the subtype rules,
so neither static nor dynamic type checks will fail.

At (3), we indirectly obtain access to the value of
the variable x with type 
under the static type Object,
because the statically known method signature of foo
has parameter type ,
but the actual implementation of foo which is invoked
is an override whose parameter type is Object,
which is allowed because Object and  are both top types.

Obviously, the support for preventing developers from using objects
obtained from expressions of type  is far from sound,
in the sense that there are many ways to circumvent the rule
that such an object should be discarded.

However, we have chosen to focus on the simple, first-order usage
(where an expression has type , and the value is used),
and we have left higher-order cases largely unchecked,
relying on additional tools such as linters to perform an analysis
which covers indirect data flows.

It would certainly have been possible to define sound rules,
such that the value of an expression of type 
would be guaranteed to be discarded after some number of transfers
from one variable or parameter to the next one, all with type ,
explicitly, or as the value of a type parameter.
In particular, we could require that method overrides should
never override return type Object by return type ,
or parameter types in the opposite direction;
parameterized types with type argument  could not be assigned
to variables where the corresponding type argument is anything other than
, etc. etc.

But this would be quite impractical.
In particular, the need to either prevent a large number of type variables
from ever having the value ,
or preventing certain usages of values whose type is such a type variable,
or whose type contains such a type variable,
that would be severely constraining on a very large part of all Dart code.

So we have chosen to help developers maintain this self-imposed discipline
in simple and direct cases,
and leave it to ad-hoc reasoning or separate tools to ensure
that the indirect cases are covered as closely as needed in practice.


 ¬ß.¬ß Parameterized Types
parameterizedTypes






A parameterized type is a syntactic construct
where the name of a generic type declaration is applied to
a list of actual type arguments.
A generic instantiation is the operation where
a generic type is applied to actual type arguments.


So a parameterized type is the syntactic concept that corresponds to
the semantic concept of a generic instantiation.
When using the former, we will often leave the latter implicit.

LetTbe a parameterized type G<S_1, ‚Ä¶, S_n>.


It is a compile-time error ifGis not a generic type,
orGis a generic type,
but the number of formal type parameters in the declaration ofGis notn.
Otherwise, letX_1, ‚Ä¶, X_nbe the formal type parameters ofG, and letB_1, ‚Ä¶, B_nbe the corresponding upper bounds, using  when no bound is declared.Tis malbounded iff eitherS_iis malbounded for one or morei ‚àà 1 .. n,
orTis not well-bounded (<ref>).


It is a compile-time error ifTis malbounded.Tis evaluated as follows.
Lett_ibe the result of evaluatingS_i, fori ‚àà 1 .. n.Tthen evaluates to the generic instantiation
whereGis applied tot_1, ‚Ä¶, t_n.


LetTbe a parameterized type of the form
G<A_1, ‚Ä¶, A_n>
and assume thatTis not malformed and not malbounded.
IfSis the static type of a membermofG,
then the static type of the membermof an expression of type
G<A_1, ‚Ä¶, A_n>
is[A_1/X_1, ‚Ä¶, A_n/X_n]S,
whereX_1, ‚Ä¶, X_nare the formal type parameters ofG.








  ¬ß.¬ß.¬ß Actual Types
actualTypes












LetTbe a term derived from type.
Let X1s be the formal type parameters in scope
at the location whereToccurs.
In a context where the actual type arguments corresponding to
X1s are t1s,
the actual value of the typeTis then[t_1/X_1, ‚Ä¶, t_s/X_s]T.


LetDbe a declaration with namenand type annotationT.
The actual type ofDand ofnin a given context is
then the actual value ofTin that context.


In the non-generic case where s = 0,
the actual type is equal to the declared type,
in the sense that we use simple terms like int to denote both.
Note that X1s may be declared by multiple entities, e.g.,
one or more enclosing generic functions and an enclosing generic class.

Let XB be a formal type parameter declaration.
The actual bound ofXin a given context is
the actual value ofBin that context.


Note that even though X may occur in B
it does not occur in the actual value of B,
because no type has an actual value that includes a type variable.


  ¬ß.¬ß.¬ß Least Upper Bounds
leastUpperBounds



Given two interfacesIandJ,
letS_Ibe the set of superinterfaces ofI,
letS_Jbe the set of superinterfaces ofJand letS = ({I}‚à™ S_I) ‚à© ({J}‚à™ S_J).
Furthermore,
we defineS_n = {T | T ‚àà S ‚àß depth(T) = n}for any finitenwheredepth(T)is the number of steps in the longest inheritance path
fromTto Object.

Letqbe the largest number such thatS_qhas cardinality one,
which must exist becauseS_0is{Object}.
The least upper bound ofIandJis the sole element ofS_q.


The least upper bound of  and any typeTis .
The least upper bound of  and any typeT is .
The least upper bound ofand any typeTisT.
LetUbe a type variable with upper boundB.
The least upper bound ofUand a typeT is
the least upper bound ofBandT.


The least upper bound operation is commutative and idempotent,
but it is not associative.



The least upper bound of a function type and an interface typeTis
the least upper bound of  andT.
LetFandGbe function types.
IfFandGdiffer in their number of required parameters,
then the least upper bound ofFandGis .
Otherwise:

  *  If

F = <X_1 B_1, ‚Ä¶, X_s B_s>(T_1, ‚Ä¶, T_r,[T_r+1, ‚Ä¶, T_n]) ‚Üí T_0 and

G = <X_1 B_1, ‚Ä¶, X_s B_s>(S_1, ‚Ä¶, S_r,[S_r+1, ‚Ä¶, S_k]) ‚Üí S_0
where k ‚â§ n then the least upper bound of F and G is

<X_1 B_1, ‚Ä¶, X_s B_s>(L_1, ‚Ä¶, L_r,[L_r+1, ‚Ä¶, L_k]) ‚Üí L_0
where L_i is the least upper bound of T_i and S_i, i ‚àà 0 .. k.

  *  If

F = <X_1 B_1, ‚Ä¶, X_s B_s>(T_1, ‚Ä¶, T_r,[T_r+1, ‚Ä¶, T_n]) ‚Üí T_0,

G = <X_1 B_1, ‚Ä¶, X_s B_s>(S_1, ‚Ä¶, S_r,{‚Ä¶}) ‚Üí S_0
then the least upper bound of F and G is

<X_1 B_1, ‚Ä¶, X_s B_s>(L_1, ‚Ä¶, L_r) ‚Üí L_0
where L_i is the least upper bound of T_i and S_i, i ‚àà 0 .. r.

  *  If

F = <X_1 B_1, ‚Ä¶, X_s B_s>(T_1, ‚Ä¶, T_r,{T_r+1 p_r+1, ‚Ä¶, T_f p_f}) ‚Üí T_0,

G = <X_1 B_1, ‚Ä¶, X_s B_s>(S_1, ‚Ä¶, S_r,{S_r+1 q_r+1, ‚Ä¶, S_g q_g}) ‚Üí S_0

then let
{x_m, ‚Ä¶, x_n} = {p_r+1, ‚Ä¶, p_f}‚à©{q_r+1, ‚Ä¶, q_g}
and let X_j be the least upper bound of the types of x_j in F and
G, j ‚àà m .. n.
Then the least upper bound of F and G is

<X_1 B_1, ‚Ä¶, X_s B_s>(L_1, ‚Ä¶, L_r,{X_m x_m, ‚Ä¶, X_n x_n}) ‚Üí L_0

where L_i is the least upper bound of T_i and S_i, i ‚àà 0 .. r
Note that the non-generic case is covered by using s = 0,
in which case the type parameter declarations are omitted (<ref>).


¬ß REFERENCE
reference

 ¬ß.¬ß Lexical Rules
lexicalRules
Dart source text is represented as a sequence of Unicode code points.
This sequence is first converted into a sequence of tokens
according to the lexical rules given in this specification.
At any point in the tokenization process,
the longest possible token is recognized.




  ¬ß.¬ß.¬ß Reserved Words
reservedWords
A reserved word can only be used in the syntactic positions
specified by the grammar.
In particular, a compile-time error occurs if a reserved word is used
where an identifier is expected.


Note that reserved words occur bold and unquoted in grammar rules
(e.g., )
even though the consistent notation would use quotes
(e.g., assert).
This notational abuse occurs because we believe
it makes the grammar rules more readable.

<RESERVED_WORD> ::=  |  |  |  |
     |  |  |  |  |  |
     |  |  |  |  |  |  |  |  |  |
     |  |  |  |  |  |  |  |  | 
In the grammar, the rule for reserved words above must occur
before the rule for BUILT_IN_IDENTIFIER
(<ref>).


This ensures that IDENTIFIER and IDENTIFIER_NO_DOLLAR do not
derive any reserved words, and they do not derive any built-in identifiers.


  ¬ß.¬ß.¬ß Comments
comments
Commentscomment
are sections of program text that are used for documentation.


<SINGLE_LINE_COMMENT> ::= 
  `//' (<LINE_BREAK>)* (<LINE_BREAK>)?

<MULTI_LINE_COMMENT> ::= 
  `/*' (<MULTI_LINE_COMMENT> |  `*/')* `*/'

Dart supports both single-line and multi-line comments.
A single line comment begins with the token //.
Everything between // and the end of line
must be ignored by the Dart compiler
unless the comment is a documentation comment.


A multi-line comment begins with the token /*
and ends with the token */.
Everything between /* and */
must be ignored by the Dart compiler
unless the comment is a documentation comment.
Comments may nest.


Documentation commentsdocumentation comments
are comments that begin with the tokens /// or /**.
Documentation comments are intended to be processed by
a tool that produces human readable documentation.


The current scope for a documentation comment immediately preceding
the declaration of a classCis the
body scopescope!for statement body
ofC.


The current scope for a documentation comment immediately preceding
the declaration of a non-redirecting generative constructorkwith initializing formals is the formal parameter initializer scope ofk(<ref>).


Otherwise, the current scope for a documentation comment immediately preceding
the declaration of a functionfis the formal parameter scope off(<ref>).




 ¬ß.¬ß Operator Precedence
operatorPrecedence
Operator precedence is given implicitly by the grammar.


The following non-normative table may be helpful

Description     Operator     Associativity     Precedence 

Unary postfix    e., e?., e++, e--, e1[e2],
e()    None     16 

Unary prefix    -e, !e, e, ++e, --e, e    None     15

Multiplicative    *, /, /, %    Left     14

Additive    +, -    Left     13

Shift    , ,     Left     12

Bitwise AND    &    Left     11

Bitwise XOR        Left     10

Bitwise Or    |    Left     9

Relational    <, >, <=, >=, , , !    None     8

Equality    ==, !=    None     7

Logical AND    &&    Left     6

Logical Or    ||    Left     5

If-null    ??    Left     4

Conditional    e1 ? e2 : e3    Right     3

Cascade    ..    Left     2

Assignment    =, *=, /=, +=, -=, &=, =, etc.     Right     1



¬ß APPENDIX: ALGORITHMIC SUBTYPING
algorithmicSubtyping


#1#2#3#4[#1]#3#4#1#2#3#4#5#6[#1]#3#4#5#6#1#2#3#4#5#6#7#8
    [#1]#3#4   #5#6#7#8#1#2#3#4#5
    [#1]#3#4#5#1#2#3#4[#1]#3#4
  [c]0.49ReflexivitySSSType Variable Reflexivity BXTXX & TRight FutureOr CŒî(X)FutureOr<T>XFutureOr<T>[c]0.49Type Variable ReflexivityXXType Variable Reflexivity CX & STX & SX & TRight FutureOr DSFutureOr<T>X & SFutureOr<T>
  Algorithmic subtype rules.
    Rules ‚Äì are unchanged and hence omitted here.
The text in this appendix is not part of the specification of the Dart language.
However, we still use the notation where precise information
uses the style associated with normative text in the specification (this style),
whereas examples and explanations use commentary style (like this).


This appendix presents a variant of the subtype rules given
in Figure¬†<ref> on page¬†fig:subtypeRules.


The rules will prove the same set of subtype relationships,
but the rules given here show that there is an efficient implementation
that will determine whether ST holds,
for any given types S and T.
It is easy to see that the algorithmic rules will prove at most
the same subtype relationships,
because all rules given here can be proven
by means of rules in Figure¬†<ref>.
It is also relatively straightforward to sketch out proofs
that the algorithmic rules can prove at least the same subtype relationships,
also when the following ordering and termination constraints are observed.

The only rule which is modified is number¬†,
which is modified to .
This only changes the applicability of the rule:
This rule is only used for types which are not atomic.
An atomic typetype!atomic
is a type which is not a type variable,
not a promoted type variable,
not a function type,
and not a parameterized type.


In other words, rule  is used for
special types like , , and ,
and it is used for non-generic classes,
but it is not used for any type where it is an operation
that takes more than one comparison to detect whether
it is the same as some other type.

The point is that the remaining rules will force
a structural traversal anyway, as far as needed,
and we may hence just as well omit the initial structural traversal
which might take many steps only to report that two large type terms
are not quite identical.

The rules are ordered by means of their rule numbers:
A rule given here numberedN.1is inserted immediately after ruleN,
followed by ruleN.2, and so on,
followed by the rule whose number isN+1.

So the order is
, ‚Äì,
, ,
,
, and so on.

We now specify the procedure which is used to determine whether
ST holds,
for some specific typesSandT:
Select the first ruleRwhose syntactic constraints are satisfied
by the given typesSandT,
and proceed to show that its premises hold.
If so, we terminate and conclude that the subtype relationship holds.
Otherwise we terminate and conclude
that the subtype relationship does not hold,
except ifRis
, ,
, or .

In particular, for the original query ST,
we do not backtrack into trying to use a rule that has
a higher rule number than that of R,
except that we may try all of
the rules with FutureOr<T> to the right.

Apart from the fact that the full complexity of subtyping
is potentially incurred each time it is checked whether a premise holds,
the checks applied for each rule is associated with an amount of work
which is constant for all rules except the following:
First, the group of rules
, ,
, and 
may cause backtracking to take place.
Next, rules ‚Äì
require work proportional to the size of S and T,
due to the number of premises that must be checked.
Finally, rule¬† requires work
proportional to the size of S,
and it may also incur the cost of searching up to the entire set of
direct and indirect superinterfaces of the candidate subtype S,
until the corresponding premise for one of them is shown to hold,
if any.

Additional optimizations are applicable.
For instance,
we can immediately conclude that the subtype relationship does not hold
when we are about to check rule¬†
if T is a type variable or a function type.
For several other forms of type, e.g.,
a promoted type variable,
Object, , ,
FutureOr<T> for any T, or ,
it is known that it will never occur as T for rule¬†,
which means that this seemingly expensive step can be confined to some extent.


¬ß APPENDIX: INTEGER IMPLEMENTATIONS
integerImplementations
The int type represents integers.
The specification is written with 64-bit two's complement integers as the
intended implementation. But when Dart is compiled to JavaScript,
the implementation of int will instead use the JavaScript number type
and the corresponding JavaScript operations,
except for bit operations as explained below.

This introduces a number of differences:

  ‚àô
  Valid values of JavaScript int are any IEEE-754 64-bit
  floating point number with no fractional part.  This includes
  positive and negative infinity, which can be reached by
  overflowing (integer division by zero is still a dynamic error).
  Otherwise valid integer literals (including any leading minus sign)
  that represent invalid JavaScript int values are compile-time
  errors when compiling to JavaScript.  Operations on integers may
  lose precision, because the operands and the result are represented
  as 64-bit floating point numbers that are limited to 53 significant
  bits.

  ‚àô
  JavaScript int instances also implement double, and
  integer-valued double instances also implement int.
  The int and double class are still separate subclasses
  of the class num, but instances of either class that
  represent an integer act as if they are actually instances of a
  common subclass implementing both int and double.
  Fractional numbers only implement double.

  ‚àô
  Bitwise operations on integers (&, |, ,
  , , and ) all truncate the
  operands to 32-bit two's complement integers, perform 32-bit
  operations on those, and the resulting 32 bits are interpreted as a
  32-bit unsigned integer. For example, -1  1 evaluates
  to 4294967294 (also known as (-2).toUnsigned(32)). The right
  shift operator, , performs a signed right shift on the
  32 bits when the original number is negative, and an unsigned right
  shift when the original number is non-negative. Both kinds of shift
  writes bit k+1 into position k, 0 ‚â§ k < 31; but the signed
  shift leaves bit 31 unchanged, and the unsigned shift writes a 0
  as bit 31. For example:
  0x80000002  1 == 0x40000001, but
  -0x7FFFFFFE  1 == 0xC0000001.
  In this example we note that both 0x80000002 and -0x7FFFFFFE
  yield the 32-bit two's complement representation 0x80000002,
  but they have different values for the IEEE 754 sign bit.

  ‚àô
  The identical method cannot distinguish the values 0.0 and
  -0.0, and it cannot recognize any NaN value as identical
  to itself.  For efficiency, the identical operation uses the
  JavaScript === operator.




[Text after  is ignored, hence we do not need "
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî-

* On Location Markers

This is a description of location markers, giving some information
about the underlying motivation and rationale, the actual
implementation, and the relevant tool support.

** What is a Location Marker?

In order to support more fine-grained update propagation from this
language specification to artifacts that depend on it, location
markers have been added.  The idea is that each logical unit (section,
subsection, etc) and each paragraph containing normative text should
be addressable using these markers, such that source code (compilers
and other tools, tests, etc.) can contain location markers, and the
corresponding location in the spec may be looked up using standard
document viewer search features.

An SHA1 hash value of the text is associated with each location
marker, such that changes in the text will incur changes in this hash
value.  Consequently, source code in tools/tests that depend on
specific parts of the spec may be flagged for revision by checking
whether these hash values have changed:  If a given test T depends on
a paragraph with hash value V in the spec, and the search for V fails
in a new version of the spec, then that paragraph has changed and T
should be revisited and possible revised.

As a result, the search for parts of source code and similar artifacts
in likely need of updates because of spec changes can be performed
mechanically, which should help ensure that the conformance of all
artifacts depending on this spec is maintained more easily, and hence
more consistently.  Note that it makes no difference whether the need
for an update has arisen in a very recent version of the spec or it
has existed for a long time, because the hash value just remains
different as long as the text is different from what it was when the
location marker was harvested from the spec.

** LaTeX Commands Supporting Location Markers

Concretely, this is based on the commands  and .
V is used to add the text V in the margin, intended to mark
a paragraph of normative text with the SHA1 hash value of the text, V.
L has the effect of , and moreover it shows the
text sec:L in the margin.  In order to indicate a dependency on a
section or subsection an  location marker is used, and in
order to indicate a dependency on a specific paragraph, the hash value
of that paragraph is used.

In this file, each normative paragraph has had the command 
added at the beginning, such that each of these paragraphs can be
decorated with their hash value.  Similarly, all 

¬ß 
s,


 ¬ß.¬ß 
s, 

  ¬ß.¬ß.¬ß 
s, and 

  
s have had
their ommands changed to , such that they are
decorated with logical names.

** Rationale

The design of location markers was proposed by Erik Ernst and
developed through discussions with several others, in particular Gilad
Bracha and Lars Bak.  Some discussions along the way that gave rise to
the given design are outlined below.

The basic idea is that a hash value based on the actual text will
serve well to identify a piece of text, because it will change
whenever the text changes, and it remains the same if the text is
moved to a different location; in other words, it characterizes the
text itself, independently of the rest of the document.  Hence:

  - references to specific paragraphs in the spec are easy to create:
    copy the marker and paste it into the source code (but see below
    why this uses an extra indirection as far as possible)

  - such references would be robust in the sense that they depend on
    the actual text alone, i.e., they would not be invalidated by
    updates to section numbers, relocation of the paragraph, or
    updates to text in different paragraphs; as Lars mentioned, we
    should use a "stripped" version of the text, removing comments,
    normalizing white space, etc., which would make the refs even more
    robust in case of "inessential" changes

  - artifacts depending on a given part of the spec that was
    changed could easily be pointed out: After an update to a
    part of the spec, that artifact would hold a marker associated
    with a hash value which does not any more occur in the spec,
    maintainers of the artifact would then receive a notification
    ("test1773 depends on a part of the spec that was updated").
    Nice tool support would show them the paragraph in the most recent
    version of the spec as well as the old version that the artifact
    used to depend on, and a comparison of the two would help
    clarifying what needs fixing because of this change, if anything.

However, there is a conflict in this scenario: Lars pointed out that
it is very inconvenient to have to create a lot of revision control
commits (e.g., new versions of tests), just because a large number of
artifacts depend on a specific hash value that changed, if that change
has no real impact on each of those artifacts.  The obvious solution
to this problem would be to use symbolic names and keep the actual
hash values out of the primary artifacts.

This approach has been used for 

¬ß 
s, 

 ¬ß.¬ß 
s, etc., by
using their labels as location markers.  For instance, dependency on


  ¬ß.¬ß.¬ß New
 would be marked as a dependency on 'sec:new',
which will (most likely) exist with the same label in the spec for a
long time.  To detect a need for updates, the hash value associated
with 

  ¬ß.¬ß.¬ß New
 from the date of the latest check of this
kind to the dependent artifact should be compared with the current
hash value for the same 

  ¬ß.¬ß.¬ß 
:  The artifact should be
revisited iff those hash values differ.  As an easy approximation to
this scheme, the hash values for all location markers would be
computed for each spec update, and the location markers that have new
hash values should cause revisits to all artifacts depending on that
location marker.

The symbolic location markers on larger units like 

¬ß 

etc. enable location marking in a hierarchical fashion: Dependencies
on a 

  ¬ß.¬ß.¬ß 
 or on a 

¬ß 
 can be chosen according to
the actual needs with each dependent artifact.  In general, fine
granularity helps avoiding false positives, where an update somewhere
in a large unit will flag too many dependent artifacts for revisits.
In contrast, coarse granularity enables other artifacts to declare the
actual dependencies when small units would be impractical because the
artifact depends on so many of them.  But there is a problem at the
bottom of this hierarchy, namely with paragraphs.

It would be very inconvenient to have to invent a logical name for
every paragraph.  Similarly, using a simple paragraph numbering would
be unstable (add one new paragraph in the beginning of a section, and
all the rest have new numbers, creating a massive flood of false
update alerts, or, even worse, corrupting the declared dependencies in
artifacts because they point to the wrong paragraphs).

Hence, paragraphs have no other label than their actual hash value.
Artifacts that depend on very specific elements in the spec may
declare so by using an actual hash value for a given paragraph, and in
return they pay in terms of potential updates to the marker when that
paragraph changes, even in cases where the actual change makes no
difference for that particular artifact.  This choice of granularity
vs. stability is up to the creator of each artifact.

** Maintenance of this document

The invariant that each normative paragraph is associated with a line
containing the text  should be maintained.  Extra occurrences
of  can be added if needed, e.g., in order to make
individual 
  * s in itemized lists addressable.  Each .. command
must occur on a separate line.   must occur immediately
before the associated paragraph, and  must occur immediately
after the associated 

¬ß ,


 ¬ß.¬ß 
 etc.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî-
